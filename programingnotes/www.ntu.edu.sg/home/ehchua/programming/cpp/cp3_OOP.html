<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Object-oriented Programming (OOP) in C++</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>C++ Programming Language</h1>
<h2>Object-Oriented Programming (OOP) in C++</h2>
</div>

<div id="content-main">

<h3>Why OOP?</h3>
<p>Suppose that you want to assemble your own PC, you go to a  hardware store and pick up a motherboard, a processor, some RAMs, a hard disk, a  casing, a power supply, and put them together.   You turn on the power, and the PC runs.   You need not worry whether the motherboard is a 4-layer or 6-layer  board, whether the hard disk has 4 or 6 plates; 3 inches or 5 inches in diameter,  whether the RAM is made in Japan  or Korea, and so on. You simply put the hardware <em>components</em> together and expect the machine to run.   Of course, you have to make sure that you have the correct <em>interfaces</em>, i.e., you pick an IDE hard disk rather  than a SCSI hard disk, if your motherboard supports only IDE; you have to select  RAMs with the correct speed rating, and so on.   Nevertheless, it is not difficult to set up a machine from hardware <em>components</em>.</p>

<p>Similarly, a car is assembled from parts and components, such as chassis, doors, engine, wheels, brake, and transmission. The components are reusable, e.g., a wheel can be used in many cars (of the same specifications).</p>
<p>Hardware, such as computers and cars, are assembled from parts, which are reusable components.</p>

<p>How about software?  Can  you &quot;assemble&quot; a software application by picking a routine here, a routine  there, and expect the program to run?   The answer is obviously no!  Unlike  hardware, it is very difficult to &quot;assemble&quot; an application from <em>software  components</em>.  Since the advent of  computer 60 years ago, we have written tons and tons of programs.  However, for each new application, we have to re-invent the wheels and write the program from scratch.</p>

<p>Why re-invent  the wheels?</p>

<h4>Traditional Procedural-Oriented languages</h4>

<img class="image-float-left" src="../java/images/OOP_CFunction.png" alt="OOP_CFunction.png" />

<p>Can we do this in traditional procedural-oriented programming language such as C, Fortran, Cobol, or Pascal?</p>

<p>Traditional procedural-oriented languages (such as C and Pascal) suffer some notable drawbacks in creating reusable software components:</p>

<ol class="float-left-ol-ul">
<li class="float-left-li">The programs are made up of functions. Functions are often not <em>reusable</em>. It is very difficult to copy a function from one program and reuse in another program because the the function is likely to reference the headers, global variables and other functions. In other words,  functions are not well-encapsulated as a self-contained <em>reusable unit</em>.</li>

<li class="float-left-li">The procedural languages are not suitable of <em>high-level abstraction</em> for solving real life problems.  For example, C programs uses constructs such as if-else, for-loop, array, function, pointer, which are low-level and hard to abstract real problems such as a Customer Relationship Management (CRM) system or a computer soccer game.  (Imagine using assembly codes, which is a very low level code, to write a computer soccer game.  C is better but no much better.)</li>
</ol>

<p>In brief, the traditional procedural-languages <em>separate</em> the data structures and algorithms of the software entities.</p>

<div class="side-note float-clear">
<p>In the early 1970s, the US Department of Defense (DoD) commissioned a task force to investigate why its IT budget always went out of control; but without much to show for. The findings are:</p>

<ol>
<li>80% of the budget went to the software (while the remaining 20% to the hardware).</li>
<li>More than 80% of the software budget went to maintenance (only the remaining 20% for new software development).</li>
<li>Hardware components could be applied to various products, and their integrity normally did not affect other products. (Hardware can share and reuse! Hardware faults are isolated!)</li>

<li>Software procedures were often non-sharable and not reusable.  Software faults could affect other programs running in computers.</li>
</ol>

<p>The task force proposed to make software behave like hardware OBJECT. Subsequently, DoD replaces over 450 computer languages, which were then used to build DoD systems, with an object-oriented language called Ada.</p>
</div>

<h4 class="float-clear">Object-Oriented Programming Languages</h4>

<img class="image-float-right" src="../java/images/OOP_Objects.png" alt="OOP_Objects.png" />

<p>Object-oriented programming (OOP) languages are designed to overcome these problems.</p>

<ol>
<li>The basic unit of OOP is a <em>class</em>, which encapsulates both the <em>static attributes</em> and <em>dynamic behaviors</em> within a &quot;box&quot;, and specifies the public interface for using these boxes. Since the class is well-encapsulated (compared with the function), it is easier to reuse these classes. In other words, OOP combines the data structures and algorithms of a software entity inside the same box.</li>

<li>OOP languages permit <em>higher level of abstraction</em> for solving real-life problems. The traditional procedural language (such as C and Pascal) forces you to think in terms of the structure of the computer (e.g. memory bits and bytes, array, decision, loop) rather than thinking in terms of the problem you are trying to solve.  The OOP languages (such as Java, C++, C#) let you think in the problem space, and use software objects to represent and abstract entities of the problem space to solve the problem.</li>
</ol>

<br class="float-clear" />

<img class="image-float-right" src="../java/images/OOP_SoccerGame.png" alt="OOP_SoccerGame.png" />

<p>As an example, suppose you wish to write a computer soccer games (which I consider as a complex application).  It is quite difficult to model the game in procedural-oriented languages.  But using OOP languages, you can easily model the program accordingly to the &quot;real things&quot; appear in the soccer games.</p>

<ul>
<li>Player: attributes include name, number, location in the field, and etc;  operations include run, jump, kick-the-ball, and etc.</li>
<li>Ball:</li>
<li>Reference:</li>
<li>Field:</li>
<li>Audience:</li>
<li>Weather:</li>
</ul>

<p>Most importantly, some of these classes (such as <code>Ball</code> and <code>Audience</code>) can be reused in another application, e.g., computer basketball game, with little or no modification.</p>

<h4 class="float-clear">Benefits of OOP</h4>

<p>The procedural-oriented languages focus on procedures, with function as the basic unit. You need to first figure out all the functions and then think about how to represent data.</p>

<p>The object-oriented languages focus on components that the user perceives, with objects as the basic unit. You figure out all the objects by putting all the data and operations that describe the user's interaction with the data.</p>

<p>Object-Oriented technology has many benefits:</p>
<ul>
<li><em>Ease in software design</em> as you could think in the problem space rather than the machine's bits and bytes.  You are dealing with high-level concepts and abstractions.  Ease in design leads to more productive software development.</li>
<li><em>Ease in software maintenance</em>:  object-oriented software are easier to understand, therefore easier to test, debug, and maintain.</li>
<li><em>Reusable software</em>: you don't need to keep re-inventing the wheels and re-write the same functions for different situations.  The fastest and safest way of developing a new application is to reuse existing codes - fully tested and proven codes.</li>
</ul>

<h3>OOP Basics</h3>
<h4>Classes &amp; Instances</h4>

<p><span class="line-heading">Class</span>: A<em> class is a definition of  objects of the same kind</em>.  In other words, a <em>class</em> is a blueprint, template, or prototype that defines and describes the <em>static attributes</em> and <em>dynamic behaviors</em> common to all objects of the same kind.</p>

<p><span class="line-heading">Instance</span>: An <em>instance</em> is <em>a realization of a particular item of a class</em>.  In other words, an instance is an <em>instantiation</em> of a class.  All the instances of a class have similar properties, as described in the class definition.  For example, you can define a class called &quot;<code>Student</code>&quot; and create three instances of the class &quot;<code>Student</code>&quot; for &quot;<code>Peter</code>&quot;, &quot;<code>Paul</code>&quot; and &quot;<code>Pauline</code>&quot;.</p>
<p>The term &quot;<em>object</em>&quot; usually refers to <em>instance</em>. But it  is often used quite loosely, which may refer to a class or an instance.</p>

<h4>A Class is a 3-Compartment Box encapsulating Data and Functions</h4>

<img class="image-float-left" src="images/OOP_ThreeCompartment.png" alt="OOP_ThreeCompartment.png" />

<p>A class can be visualized as a three-compartment box, as illustrated:</p>

<ol class="float-left-ol-ul">
<li class="float-left-li"><em><strong>Classname</strong></em> (or identifier):  identifies the class.</li>
<li class="float-left-li"><em><strong>Data Members</strong></em> or <em><strong>Variables</strong></em> (or <em>attributes</em>, <em>states</em>, <em>fields</em>):  contains the <em>static attributes</em> of the class.</li>
<li class="float-left-li"><em><strong>Member Functions</strong></em> (or <em>methods</em>, <em>behaviors</em>, <em>operations</em>):  contains the <em>dynamic operations</em> of the class.</li>
</ol>

<p>In other words, a class encapsulates the static attributes (data) and dynamic behaviors (operations that operate on the data) in a box.</p>

<p><span class="line-heading">Class Members</span>: The <em>data members</em> and <em>member functions</em> are collectively called <em>class members</em>.</p>

<p class="float-clear">The followings figure shows a few examples of classes:</p>
<img class="image-center" src="images/OOP_ClassExamples.png" alt="OOP_ClassExamples.png" />

<p>The following figure shows two instances of the class <code>Student</code>, identified as &quot;<code>paul</code>&quot; and &quot;<code>peter</code>&quot;.</p>

<img class="image-center" src="images/OOP_InstanceExamples.png" alt="OOP_InstanceExamples.png" />

<p><span class="line-heading">Unified Modeling Language (UML) Class and Instance Diagrams:</span> The above class diagrams are drawn according to the UML notations. A class is represented as a 3-compartment box, containing name, data members (variables), and member functions, respectively. classname is shown in bold and centralized. An instance (object) is also represented as a 3-compartment box, with instance name shown as <span class="underline"><code>instanceName:Classname</code></span> and underlined.</p>

<h5>Brief Summary</h5>

<ol>
<li>A <em>class</em> is a programmer-defined, abstract, self-contained, reusable software entity that mimics a real-world thing.</li>

<li>A class is a 3-compartment box containing the name, data members (variables) and the member functions.</li>

<li>A class encapsulates the data structures (in data members) and algorithms (member functions). The values of the data members constitute its <em>state</em>. The member functions constitute its <em>behaviors</em>.</li>

<li>An <em>instance</em> is an instantiation (or realization) of a particular item of a class.</li>
</ol>

<h4>Class Definition</h4>
<p>In C++, we use the keyword <code>class</code> to define a class.  There are two sections in the class declaration: <code>private</code> and <code>public</code>, which will be explained later. For examples,</p>
<pre class="color-example">
<strong>class</strong> <strong>Circle</strong> {         <span class="color-comment">// classname</span>
private:
   double radius;      <span class="color-comment">// Data members (variables)</span>
   string color;
public:   
   double getRadius(); <span class="color-comment">// Member functions</span>
   double getArea();
}</pre>

<pre class="color-example" >
<strong>class</strong> <strong>SoccerPlayer</strong> {   <span class="color-comment">// classname</span>
private:
   int number;         <span class="color-comment">// Data members (variables)</span>
   string name;
   int x, y;
public:   
   void run();         <span class="color-comment">// Member functions</span>
   void kickBall();
}</pre>

<p><span class="line-heading">Class Naming Convention:</span> A classname shall be a noun or a noun phrase made up of several words. All the words shall be initial-capitalized (camel-case).  Use a <em>singular</em> noun for classname.  Choose a meaningful and self-descriptive classname.  For examples, <code>SoccerPlayer</code>, <code>HttpProxyServer</code>, <code>FileInputStream</code>, <code>PrintStream</code> and <code>SocketFactory</code>.</p>

<h4>Creating Instances of a Class</h4>
<p>To create <em>an instance of a class</em>, you have to:</p>
<ol>
<li>Declare an instance identifier (name) of a particular class.</li>
<li>Invoke a constructor to construct the instance (i.e., allocate storage for the instance and initialize the variables).</li>
</ol>

<p>For examples, suppose that we have a class called <code>Circle</code>, we can create instances of <code>Circle</code> as follows:</p>
<pre class="color-example">
<span class="color-comment">// Construct 3 instances of the class Circle: c1, c2, and c3</span>
Circle c1(1.2, "red");  <span class="color-comment">// radius, color</span>
Circle c2(3.4);         <span class="color-comment">// radius, default color</span>
Circle c3;              <span class="color-comment">// default radius and color</span></pre>

<p>Alternatively, you can invoke the constructor explicitly using the following syntax:</p>

<pre class="color-example">
Circle c1 = Circle(1.2, "red");  <span class="color-comment">// radius, color</span>
Circle c2 = Circle(3.4);         <span class="color-comment">// radius, default color</span>
Circle c3 = Circle();            <span class="color-comment">// default radius and color</span></pre>

<h4>Dot (<span class="font-code">.</span>) Operator</h4>
<p>To reference a <em>member of a object</em> (data member or member function), you must:</p>
<ol>
<li>First identify the instance you are interested in, and then</li>
<li>Use the <em>dot operator</em> (<code>.</code>) to reference  the member, in the form of <code><em>instanceName.memberName</em></code>.</li>
</ol>

<p>For example, suppose that we have a class called <code>Circle</code>, with two data members (<code>radius</code> and <code>color</code>) and two functions (<code>getRadius()</code> and <code>getArea()</code>). We have created three instances of the class <code>Circle</code>, namely, <code>c1</code>, <code>c2</code> and <code>c3</code>. To invoke the function <code>getArea()</code>, you must first identity the instance of interest, says <code>c2</code>, then use the <em>dot operator</em>, in the form of <code>c2.getArea()</code>, to invoke the <code>getArea()</code> function of instance <code>c2</code>.</p>
<p>For example,</p>
<pre class="color-example">
<span class="color-comment">// Declare and construct instances c1 and c2 of the class Circle</span>
Circle c1(1.2, &quot;blue&quot;);
Circle c2(3.4, &quot;green&quot;);
<span class="color-comment"></span><span class="color-comment">// Invoke member function via dot operator</span>
cout &lt;&lt; c1.getArea() &lt;&lt; endl;
<span class="color-comment"></span>cout &lt;&lt; c2.getArea() &lt;&lt; endl;
<span class="color-comment">// Reference data members via dot operator</span>
c1.radius = 5.5;
c2.radius = 6.6;</pre>

<p>Calling <code>getArea()</code> without identifying the instance is meaningless, as the radius is unknown (there could be many instances of <code>Circle</code> - each maintaining its own radius).</p>

<p>In general, suppose there is a class called <em><code>AClass</code></em> with a data member called <em><code>aData</code></em> and a member function called <code><em>aFunction</em>()</code>.  An instance called <em><code>anInstance</code></em> is constructed for <em><code>AClass</code></em>.  You use <em><code>anInstance.aData</code></em> and <code><em>anInstance.aFunction</em>()</code>.</p>

<h4>Data Members (Variables)</h4>
<p>A <em>data member</em> (<em>variable</em>) has a <em>name</em> (or <em>identifier</em>) and a <em>type</em>; and holds a <em>value</em> of that particular type (as descried in the earlier chapter). A data member can also be an instance of a certain class (to be discussed later).</p>

<p><span class="line-heading">Data Member Naming Convention:</span> A data member name shall be a noun or a noun phrase made up of several words.  The first word is in lowercase and the rest of the words are initial-capitalized (camel-case), e.g., <code>fontSize</code>, <code>roomNumber</code>, <code>xMax</code>, <code>yMin</code> and <code>xTopLeft</code>. Take note that variable name begins with an lowercase, while classname begins with an uppercase.</p>

<h4>Member Functions</h4>

<p>A member function (as described in the earlier chapter):</p>
<ol>
<li>receives parameters from the caller,</li>
<li>performs the operations defined in the function body, and</li>
<li>returns a piece of result (or void) to the caller.</li>
</ol>

<p><span class="line-heading">Member Function Naming Convention:</span> A function name shall be a verb, or a verb phrase made up of several words. The first word is in lowercase and the rest of the words are initial-capitalized (camel-case).  For example, <code>getRadius()</code>, <code>getParameterValues()</code>.</p>

<p> Take note that data member name is a noun (denoting a static attribute), while function name is a verb (denoting an action). They have the same naming convention.  Nevertheless, you can easily distinguish them from the context. Functions take arguments in parentheses (possibly zero argument with empty parentheses), but variables do not. In this writing, functions are denoted with a pair of parentheses, e.g., <code>println()</code>, <code>getArea()</code> for clarity.</p>

<h4>Putting them Together: An OOP Example</h4>

<img class="image-float-left" src="../java/images/OOP_Circle.png" alt="OOP_Circle.png" />

<p>A class called <code>Circle</code> is to be defined as illustrated in the class diagram. It contains two data members: <code>radius</code> (of type <code>double</code>) and <code>color</code> (of type <code>String</code>); and three member functions: <code>getRadius()</code>, <code>getColor()</code>, and <code>getArea()</code>.</p>

<p>Three instances of <code>Circle</code>s called <code>c1</code>, <code>c2</code>, and <code>c3</code> shall then be constructed with their respective data members, as shown in the instance diagrams.</p>

<p>In this example, we shall keep all the codes in a single source file called <code>CircleAIO.cpp</code>.</p>

<h5 class="float-clear"><span class="font-code">CircleAIO.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></td>
<td>
<pre>
<span class="color-comment">/* The Circle class (All source codes in one file) (CircleAIO.cpp) */</span>
#include &lt;iostream&gt;   <span class="color-comment"> // using IO functions</span>
#include &lt;string&gt;     <span class="color-comment"> // using string</span>
using namespace std;
 
class Circle {
private:
   double radius;     <span class="color-comment"> // Data member (Variable)</span>
   string color;      <span class="color-comment"> // Data member (Variable)</span>
 
public:
  <span class="color-comment"> // Constructor with default values for data members</span>
   Circle(double r = 1.0, string c = &quot;red&quot;) {
      radius = r;
      color = c;
   }
 
   double getRadius() { <span class="color-comment"> // Member function (Getter)</span>
      return radius;
   }
 
   string getColor() {  <span class="color-comment"> // Member function (Getter)</span>
      return color;
   }
 
   double getArea() {   <span class="color-comment"> // Member function</span>
      return radius*radius*3.1416;
   }
};  <span class="color-comment"> // need to end the class declaration with a semi-colon</span>
 
<span class="color-comment">// Test driver function</span>
int main() {
  <span class="color-comment"> // Construct a Circle instance</span>
   Circle c1(1.2, &quot;blue&quot;);
   cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c1.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c1.getArea()
        &lt;&lt; &quot; Color=&quot; &lt;&lt; c1.getColor() &lt;&lt; endl;
 
  <span class="color-comment"> // Construct another Circle instance</span>
   Circle c2(3.4);<span class="color-comment"> // default color</span>
   cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c2.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c2.getArea()
        &lt;&lt; &quot; Color=&quot; &lt;&lt; c2.getColor() &lt;&lt; endl;
 
  <span class="color-comment"> // Construct a Circle instance using default no-arg constructor</span>
   Circle c3;     <span class="color-comment"> // default radius and color</span>
   cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c3.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c3.getArea()
        &lt;&lt; &quot; Color=&quot; &lt;&lt; c3.getColor() &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>To compile and run the program (with GNU GCC under Windows):</p>

<pre class="color-command">
&gt; <strong>g++ -o CircleAIO.exe CircleAIO.cpp</strong>
   <span class="color-comment">// -o specifies the output file name</span>
 
&gt; <strong>CircleAIO</strong>
Radius=1.2 Area=4.5239 Color=blue
Radius=3.4 Area=36.3169 Color=red
Radius=1 Area=3.1416 Color=red</pre>

<h4>Constructors</h4>

<p>A <em>constructor</em> is a special function that has the <em>function name same as the classname</em>. In the above <code>Circle</code> class, we define a constructor as follows:</p>

<pre class="color-example">
<span class="color-comment">// Constructor has the same name as the class</span>
Circle(double r = 1.0, string c = &quot;red&quot;) {
   radius = r;
   color = c;
}</pre>

<p>A constructor is used to construct and <em>initialize all the data members</em>. To create a new instance of a class, you need to declare the name of the instance and invoke the constructor. For example,</p>

<pre class="color-example">
Circle c1(1.2, &quot;blue&quot;);
Circle c2(3.4);      <span class="color-comment">// default color</span>
Circle c3;           <span class="color-comment">// default radius and color
                     // Take note that there is no empty bracket ()</span>
</pre>

<p>A constructor function is different from an ordinary function in the following aspects:</p>

<ul>
<li>The name of the constructor is the same as the classname.</li>
<li>Constructor has no return type (or implicitly returns <code>void</code>).  Hence, no <code>return</code> statement is allowed inside the constructor's body.</li>
<li>Constructor can only be invoked <em>once</em> to initialize the instance constructed. You cannot call the constructor afterwards in your program.</li>
<li>Constructors are not inherited (to be explained later).</li>
</ul>

<h4>Default Arguments for Functions</h4>

<p>In C++, you can specify the default value for the trailing arguments of a function (including constructor) in the function header. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test function default arguments (TestFnDefault.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Function prototype</span>
int sum(int n1, int n2, int n3 <span class="color-new">= 0</span>, int n4 <span class="color-new">= 0</span>, int n5 <span class="color-new">= 0</span>);
 
int main() {
   cout &lt;&lt; sum(1, 1, 1, 1, 1) &lt;&lt; endl;<span class="color-comment"> // 5</span>
   cout &lt;&lt; sum(1, 1, 1, 1) &lt;&lt; endl;   <span class="color-comment"> // 4</span>
   cout &lt;&lt; sum(1, 1, 1) &lt;&lt; endl;      <span class="color-comment"> // 3</span>
   cout &lt;&lt; sum(1, 1) &lt;&lt; endl;         <span class="color-comment"> // 2</span>
<span class="color-error">//</span> cout &lt;&lt; sum(1) &lt;&lt; endl; <span class="color-error"> // error: too few arguments</span>
}
 
<span class="color-comment">// Function definition</span>
<span class="color-comment">// The default values shall be specified in function prototype,</span>
<span class="color-comment">//   not the function implementation</span>
int sum(int n1, int n2, int n3, int n4, int n5) {
   return n1 + n2 + n3 + n4 + n5;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>&quot;<span class="font-code">public</span>&quot; vs. &quot;<span class="font-code">private</span>&quot; Access Control Modifiers</h4>

<p>An <em>access control modifier</em> can be used to control the visibility of a data member or a member function within a class.  We begin with the following two access control modifiers:</p>

<ol>
<li><code><strong>public</strong></code>: The member (data or function) is accessible and available to <em>all</em> in the system.</li>
<li><code><strong>private</strong></code>: The member (data or function) is accessible and available <em>within this class only</em>.</li>
</ol>

<p>For example, in the above <code>Circle</code> definition, the data member <code>radius</code> is declared <code>private</code>. As the result, <code>radius</code> is accessible inside the <code>Circle</code> class, but NOT outside the<code> </code>class. In other words, you cannot use &quot;<code>c1.radius</code>&quot; to refer to <code>c1</code>'s <code>radius</code> in <code>main()</code>. Try inserting the statement &quot;<code>cout &lt;&lt; c1.radius;</code>&quot; in <code>main()</code> and observe the error message:</p>

<pre class="color-example">
CircleAIO.cpp:8:11: error: 'double Circle::radius' is private</pre>

<p> Try moving <code>radius</code> to the <code>public</code> section, and re-run the statement.</p>

<p>On the other hand, the function <code>getRadius()</code> is declared <code>public</code> in the <code>Circle</code> class. Hence, it can be invoked in the <code>main()</code>.</p>

<p><span class="line-heading">UML Notation:</span> In <acronym title="Unified Modeling Language">UML</acronym> notation, <code>public</code> members are denoted with a &quot;<code>+</code>&quot;, while <code>private</code> members with a &quot;<code>-</code>&quot; in the class diagram.</p>

<h4>Information Hiding and Encapsulation</h4>
<p>A class encapsulates the static attributes and the dynamic behaviors into a &quot;3-compartment box&quot;.  Once a class is defined, you can seal up the &quot;box&quot; and put the &quot;box&quot; on the shelve for others to use and reuse.  Anyone can pick up the &quot;box&quot; and use it in their application.  This cannot be done in the traditional procedural-oriented language like C, as the static attributes (or variables) are scattered over the entire program and header files.  You cannot &quot;cut&quot; out a portion of C program, plug into another program and expect the program to run without extensive changes.</p>

<p>Data member of a class are typically hidden from the outside word, with  <code>private</code> access control modifier.  Access to the private data members are provided via  <code>public</code> assessor functions, e.g., <code>getRadius()</code> and <code>getColor()</code>.</p>

<p>This follows the principle of <em>information hiding</em>.  That is, objects communicate with each others using well-defined interfaces (public functions).  Objects are not allowed to know the implementation details of others.  The implementation details are hidden or encapsulated within the class.  Information hiding facilitates reuse of the class.</p>

<p><span class="line-heading">Rule of Thumb:</span> Do not make any data member <code>public</code>, unless you have a good reason.</p>

<h4>Getters and Setters</h4>
<p>To allow other  to <em>read</em> the value of a <code>private</code> data member says <code>xxx</code>, you shall provide a <em>get function</em> (or <em>getter</em> or <em>accessor function</em>) called <code>getXxx()</code>.  A getter need not expose the data in raw format.  It can process the data and limit the view of the data others will see.  Getters shall not modify the data member.</p>

<p>To allow other classes to <em>modify</em> the value of a <code>private</code> data member says <code>xxx</code>, you shall provide a <em>set function</em> (or <em>setter</em> or <em>mutator function</em>) called <code>setXxx()</code>.  A setter could provide data validation (such as range checking), and transform the raw data into the internal representation.</p>

<p>For example, in our <code>Circle</code> class, the data members <code>radius</code> and <code>color</code> are declared <code>private</code>. That is to say, they are only available within the <code>Circle</code> class and not visible outside the <code>Circle</code> class - including <code>main()</code>.  You cannot access the <code>private</code> data members <code>radius</code> and <code>color</code> from the <code>main()</code> directly - via says <code>c1.radius</code> or <code>c1.color</code>.  The <code>Circle</code> class provides two public accessor functions, namely, <code>getRadius()</code> and <code>getColor()</code>.  These functions are declared <code>public</code>.  The <code>main()</code> can invoke these public accessor functions to retrieve the <code>radius</code> and <code>color</code> of a <code>Circle</code> object, via says <code>c1.getRadius()</code> and <code>c1.getColor()</code>.</p>

<p>There is no way you can change the <code>radius</code> or <code>color</code> of a <code>Circle</code> object, after it is constructed in <code>main()</code>.  You cannot issue statements such as <code>c1.radius = 5.0</code> to change the <code>radius</code> of instance <code>c1</code>, as <code>radius</code> is declared as <code>private</code> in the <code>Circle</code> class and is not visible to other  including<code> main()</code>.</p>

<p>If the designer of the <code>Circle</code> class permits the change the <code>radius</code> and <code>color</code> after a <code>Circle</code> object is constructed, he has to provide the appropriate setter, e.g.,</p>
<pre class="color-example">
<span class="color-comment">// Setter for color</span>
void setColor(string c) {
   color = c;
}
   
<span class="color-comment">// Setter for radius</span>
void setRadius(double r) {
   radius = r;
}</pre>

<p>With proper implementation of <em>information hiding</em>, the designer of a class has full control of what the user of the class can and cannot do.</p>

<h4>Keyword &quot;<span class="font-code">this</span>&quot;</h4>

<p>You can use keyword &quot;<code>this</code>&quot; to refer to <em>this </em>instance inside a class definition.</p>

<p>One of the main usage of keyword <code>this</code> is to resolve ambiguity between the names of data member and function parameter. For example,</p>

<pre class="color-example">
class Circle {
private:
   double <span class="color-new">radius</span>;   <span class="color-comment">              // Member variable called &quot;radius&quot;</span>
   ......
public:
   void setRadius(double <span class="color-new">radius</span>) { <span class="color-comment">// Function's argument also called &quot;radius&quot;</span>
      <span class="color-new">this-&gt;radius = radius</span>;
         <span class="color-comment">// &quot;this.radius&quot; refers to this instance's member variable
         // &quot;radius&quot; resolved to the function's argument.</span>
   }
   ......
}</pre>

<p>In the above codes, there are two identifiers called <code>radius</code> - a data member and the function parameter. This  causes naming conflict. To resolve the naming conflict, you could name the function parameter <code>r</code> instead of <code>radius</code>. However, <code>radius</code> is more approximate and meaningful in this context. You can use keyword <code>this</code> to resolve this naming conflict. &quot;<code>this-&gt;radius</code>&quot; refers to the data member; while &quot;<code>radius</code>&quot; resolves to the function parameter.</p>

<p>&quot;<code>this</code>&quot; is actually a <em>pointer</em> to this object. I will explain pointer and the meaning of &quot;<code>-&gt;</code>&quot; operator later.</p>

<p>Alternatively, you could use a prefix (such as <code>m_</code>) or suffix (such as <code>_</code>) to name the data members to avoid name crashes. For example,</p>

<pre class="color-example">
class Circle {
private:
   double <span class="color-new">m_radius</span>;  <span class="color-comment">// or <span class="color-new">radius_</span></span>
   ......
public:
   void setRadius(double radius) {
      <span class="color-new">m_radius</span> = radius;  <span class="color-comment">// or <span class="color-new">radius_ = radius</span></span>
   }
   ......
}</pre>

<p>C++ Compiler internally names their data members beginning with a leading underscore (<code>e.g., _xxx</code>) and local variables with 2 leading underscores (e.g., <code>__xxx</code>). Hence, avoid name beginning with underscore in your program.</p>

<h4>&quot;<span class="font-code">const</span>&quot; Member Functions</h4>

<p>A <code>const</code> member function, identified by a <code>const</code> keyword at the end of the member function's header, cannot modifies any data member of this object. For example,</p>

<pre class="color-example">
double getRadius() <span class="color-new">const</span> {  <span class="color-comment">// const member function</span>
   <span class="color-new">radius = 0</span>;  
      <span class="color-error">// error: assignment of data-member 'Circle::radius' in read-only structure</span>
   return radius;
}</pre>
  
<h4>Convention for Getters/Setters and Constructors</h4>

<p>The constructor, getter and setter functions for a <code>private</code> data member called <code>xxx</code> of type <code>T</code> in a class <code>Aaa</code> have the following conventions:</p>

<pre class="color-syntax">
class Aaa {
private:
<span class="color-comment">   // A private variable named xxx of type T</span>
   T xxx;
public:
   <span class="color-comment">// Constructor</span>
   Aaa(T x) { xxx = x; }
   <span class="color-comment">// OR</span>
   Aaa(T xxx) { this-&gt;xxx = xxx; }
   <span class="color-comment">// OR using member initializer list (to be explained later)</span>
   Aaa(T xxx) : xxx(xxx) { }
 
<span class="color-comment">   // A getter for variable xxx of type T receives no argument and return a value of type T</span>
   T getXxx() const { return xxx; }
 
<span class="color-comment">   // A setter for variable xxx of type T receives a parameter of type T and return void</span>
   void setXxx(T x) { xxx = x; }
   <span class="color-comment">// OR</span>
   void setXxx(T xxx) { this-&gt;xxx = xxx; }
}</pre>

<p>For a <code>bool</code> variable <code>xxx</code>, the getter shall be named <code>isXxx()</code>, instead of <code>getXxx()</code>, as follows:</p>
<pre class="color-syntax">
private:
   <span class="color-comment">// Private boolean variable</span>
   bool xxx;
public: 
   <span class="color-comment">// Getter</span>
   bool isXxx() const { return xxx; }
 
   <span class="color-comment">// Setter</span>
   void setXxx(bool x) { xxx = x; }
   <span class="color-comment">// OR</span>
   void setXxx(bool xxx) { this-&gt;xxx = xxx; }</pre>

<h4>Default Constructor</h4>
<p>A default constructor is a constructor with no parameters, or having default values for all the parameters. For example, the above <code>Circle</code>'s constructor can be served as default constructor with all the parameters default.</p>

<pre class="color-example">
Circle c1;   <span class="color-comment">// Declare c1 as an instance of Circle, and invoke the default constructor</span>
<span class="color-new">Circle c1();</span> <span class="color-error">// Error!
             // (This declares c1 as a function that takes no parameter and returns a Circle instance)</span></pre>

<p>If C++, if you did not provide ANY constructor, the compiler automatically provides a default constructor that does nothing. That is,</p>

<pre class="color-example">
<em>ClassName</em>::<em>ClassName</em>() { }  <span class="color-comment">// Take no argument and do nothing</span></pre>

<p>Compiler will not provide a default constructor if you define any constructor(s). If all the constructors you defined require arguments, invoking no-argument default constructor results in error. This is to allow class designer to make it impossible to create an <em>uninitialized</em> instance, by NOT providing an explicit default constructor.</p>

<h4>Constructor's Member Initializer List</h4>

<p>Instead of initializing the private data members inside the body of the constructor, as follows:</p>

<pre class="color-example">
Circle(double r = 1.0, string c = &quot;red&quot;) {
   <span class="color-new">radius = r;
   color = c;</span>
}</pre>

<p>We can use an alternate syntax called <em> member initializer list </em>as follows:</p>

<pre class="color-example">
Circle(double r = 1.0, string c = &quot;red&quot;) <span class="color-new">: radius(r), color(c)</span> { }</pre>

<p>Member initializer list is placed after the constructor's header, separated by a colon (<code>:</code>). Each initializer is in the form of <code><em>data_member_name</em>(<em>parameter_name</em>)</code>. For fundamental type, it is equivalent to <code><em>data_member_name</em> = <em>parameter_name</em></code>. For object, the constructor will be invoked to construct the object. The constructor's body (empty in this case) will be run after the completion of  member initializer list.</p>
<p>It is recommended to use member initializer list to initialize all the data members, as it is often more efficient than doing assignment inside the constructor's body.</p>

<h4>*Destructor</h4>

<p>A <em>destructor</em>, similar to constructor, is a special function that has the same name as the classname, with a prefix <code>~</code>, e.g., <code>~Circle()</code>. Destructor is called implicitly when an object is destroyed.</p>
<p>If you do not define a destructor, the compiler provides a default, which does nothing.</p>

<pre class="color-syntax">
class MyClass {
public:
   <span class="color-comment">// The default destructor that does nothing</span>
   ~MyClass() { }
......
}</pre>

<h5>Advanced Notes</h5>

<ul>
<li>If your class contains data member which is dynamically allocated (via <code>new</code> or <code>new[]</code> operator), you need to free the storage via <code>delete</code> or <code>delete[]</code>.</li>

</ul>


<h4>*Copy Constructor</h4>

<p>A <em>copy constructor</em> constructs a new object by copying an existing object of the same type. In other words, a copy constructor takes an argument, which is an object of the same class.</p>

<p>If you do not define a copy constructor, the compiler provides a default which  copies all the data members of the given object. For example,</p>

<pre class="color-example">
Circle c4(7.8, &quot;blue&quot;);
cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c4.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c4.getArea()
     &lt;&lt; &quot; Color=&quot; &lt;&lt; c4.getColor() &lt;&lt; endl;
               <span class="color-comment"> // Radius=7.8 Area=191.135 Color=blue</span>
 
<span class="color-comment">// Construct a new object by copying an existing object</span>
<span class="color-comment">// via the so-called default copy constructor</span>
<span class="color-new">Circle c5(c4);</span>
cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c5.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c5.getArea()
     &lt;&lt; &quot; Color=&quot; &lt;&lt; c5.getColor() &lt;&lt; endl;
               <span class="color-comment"> // Radius=7.8 Area=191.135 Color=blue</span></pre>

<p>The copy constructor is particularly important. When an object is passed into a function <em>by value</em>, the copy constructor will be used to make a clone copy of the argument.</p>


<h5>Advanced Notes</h5>

<ul>
<li>Pass-by-value for object means calling the copy constructor. To avoid the overhead of creating a clone copy, it is usually better to pass-by-reference-to-<code>const</code>, which will not have side effect on modifying the caller's object.</li>
<li>The copy constructor has the following signature:
  <pre class="color-syntax">
class MyClass {
private:
   T1 member1;
   T2 member2;
public:
   <span class="color-comment">// The default copy constructor which</span> <span class="color-comment">constructs an object via memberwise copy</span>
   <span class="color-new">MyClass(const MyClass &amp; rhs)</span> {
      member1 = rhs.member1;
      member2 = rhs.member2;
   }
......
}</pre>
</li>

<li>The default copy constructor performs <em>shadow copy</em>. It does not copy the dynamically allocated data members created via <code>new</code> or <code>new[]</code> operator.</li>
</ul>


<h4>*Copy Assignment Operator (<span class="font-code">=</span>)</h4>

<p>The compiler also provides a default assignment operator (<code>=</code>), which can be used to assign one object to another object of the same class via memberwise copy. For example, using the <code>Circle</code> class defined earlier,</p>

<pre class="color-example">
Circle c6(5.6, &quot;orange&quot;), <span class="color-new">c7</span>;
cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c6.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c6.getArea()
     &lt;&lt; &quot; Color=&quot; &lt;&lt; c6.getColor() &lt;&lt; endl;
               <span class="color-comment"> // Radius=5.6 Area=98.5206 Color=orange</span>
cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c7.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c7.getArea()
     &lt;&lt; &quot; Color=&quot; &lt;&lt; c7.getColor() &lt;&lt; endl;
               <span class="color-comment"> // Radius=1 Area=3.1416 Color=red (default constructor)</span>
 
<span class="color-new">c7 = c6;</span><span class="color-comment"> // memberwise copy assignment</span>
cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c7.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c7.getArea()
     &lt;&lt; &quot; Color=&quot; &lt;&lt; c7.getColor() &lt;&lt; endl;
               <span class="color-comment"> // Radius=5.6 Area=98.5206 Color=orange</span>
</pre>

<h5>Advanced Notes</h5>
<ul>
<li>You could overload the assignment opeator to override the default.</li>

<li>The copy constructor, instead of copy assignment operator, is used in declaration:

  <pre class="color-example">
Circle c8 = c6;  <span class="color-comment">// Invoke the copy constructor, NOT copy assignment operator
                 // Same as Circle c8(c6)</span></pre></li>

<li>The default copy assignment operator performs <em>shadow copy</em>. It does not copy the dynamically allocated data members created via <code>new</code> or <code>new[]</code> operator.</li>

<li>The copy assignment operator has the following signature:
  <pre class="color-syntax">
class MyClass {
private:
   T1 member1;
   T2 member2;
public:
   <span class="color-comment">// The default copy assignment operator which assigns an object via memberwise copy</span>
   <span class="color-new">MyClass &amp; operator=(const MyClass &amp; rhs)</span> {
      member1 = rhs.member1;
      member2 = rhs.member2;
      return *this;
   }
......
}</pre></li>

<li>The copy assignment operator differs from the copy constructor in that it must release the dynamically allocated contents of the target and prevent self assignment. The assignment operator shall return a reference of this object to allow chaining operation (such as <code>x = y = z</code>).</li>
<li>The default constructor, default destructor, default copy constructor, default copy assignment operators are known as <em>special member functions</em>, in which the compiler will automatically generate a copy if they are used in the program and not explicitly defined.</li>
</ul>

<h3>Separating Header and Implementation</h3>

<p>For better software engineering, it is recommended that the class declaration and implementation be kept in 2 separate files: declaration is a header file &quot;<code>.h</code>&quot;; while implementation in a &quot;<code>.cpp</code>&quot;. This is known as separating the public interface (header declaration) and the implementation. Interface is defined by the designer, implementation can be supplied by others. While the interface is fixed, different vendors can provide different implementations. Furthermore, only the header files are exposed to the users, the implementation can be provided in an object file &quot;<code>.o</code>&quot; (or in a library). The source code needs not given to the users.</p>

<p>I shall illustrate with the following examples.</p>

<h3>Example: The <span class="font-code">Circle</span> Class</h3>

<img class="image-float-left" src="images/ClassDiagramCircle.png" alt="ClassDiagramCircle.png"/>

<p>Instead of putting all the codes in a single file. We shall &quot;separate the interface and implementation&quot; by placing the codes in 3 files.</p>

<ol class="float-left-ol-ul">
<li class="float-left-li"><code>Circle.h</code>:  defines the public interface of the <code>Circle</code> class.</li>
<li class="float-left-li"><code>Circle.cpp</code>:  provides the implementation of the <code>Circle</code> class.</li>
<li class="float-left-li"><code>TestCircle.cpp</code>: A test driver program for the <code>Circle</code> class.</li>
</ol>

<h5 class="float-clear"><span class="font-code">Circle.h</span> - Header</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
<span class="color-comment">/* The Circle class Header (Circle.h) */</span>
#include &lt;string&gt;  <span class="color-comment"> // using string</span>
using namespace std;
 
<span class="color-comment">// Circle class declaration</span>
class Circle {
private:  <span class="color-comment"> // Accessible by members of this class only</span>
  <span class="color-comment"> // private data members (variables)</span>
   double radius;
   string color;
 
public:   <span class="color-comment"> // Accessible by ALL</span>
  <span class="color-comment"> // Declare prototype of member functions</span>
   <span class="color-comment">// Constructor with default values</span>
   Circle(double radius = 1.0, string color = &quot;red&quot;);
 
   <span class="color-comment">// Public getters &amp; setters for private data members</span>
   double getRadius() const;
   void setRadius(double radius);
   string getColor() const;
   void setColor(string color);
 
   <span class="color-comment">// Public member Function</span>
   double getArea() const;
};</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>The header file contains  <em>declaration</em> statements, that tell the compiler about the names and types, and function prototypes without the implementation details.</li>
<li>C++98/03 does NOT allow you to assign an initial value to a data member (except <code>const</code> <code>static</code> members). Date members are to be initialized via the constructor. For example,
  <pre class="color-example">
double radius <span class="color-new">= 1.0</span>;
   <span class="color-error">// error: ISO C++ forbids in-class initialization of non-const static member 'radius'</span></pre>
  C++11 allows in-class initialization of data members.</li>

<li>You can provide default value to function's arguments in the header. For example,
  <pre class="color-example">
Circle(double radius <span class="color-new">= 1.0</span>, string color <span class="color-new">= &quot;red&quot;</span>);</pre></li>

<li>Header contains function prototype, the parameter names are ignored by the compiler, but good to serve as documentation. For example, you can leave out the parameter names in the prototype as follows:
  <pre class="color-example">
Circle(double = 1.0, string = &quot;red&quot;);   <span class="color-comment">// without identifiers</span>
   <span class="color-comment">// Identifiers not needed in prototype but good to serve as documentation</span></pre>
</li>
</ul>

<p>Header files shall contains constants, function prototypes, class/struct declarations.</p>

<h5><span class="font-code">Circle.cpp</span> - Implementation</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre>
</td>
<td>
<pre>
<span class="color-comment">/* The Circle class Implementation (Circle.cpp) */</span>
#include &quot;Circle.h&quot;<span class="color-comment"> // user-defined header in the same directory</span>
 
<span class="color-comment">// Constructor
// default values shall only be specified in the declaration,
// cannot be repeated in definition</span>
Circle::Circle(double r, string c) {
   radius = r;
   color = c;
}
 
<span class="color-comment">// Public getter for private data member radius</span>
double Circle::getRadius() const {
   return radius;
}
 
<span class="color-comment">// Public setter for private data member radius</span>
void Circle::setRadius(double r) {
   radius = r;
}
 
<span class="color-comment">// Public getter for private data member color</span>
string Circle::getColor() const {
   return color;
}
 
<span class="color-comment">// Public setter for private data member color</span>
void Circle::setColor(string c) {
   color = c;
}
 
<span class="color-comment">// A public member function</span>
double Circle::getArea() const {
   return radius*radius*3.14159265;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>The implementation file provides the <em>definition</em> of the functions, which are omitted from the <em>declaration</em> in the header file.</li>

<li><span class="line-heading-code-new">#include &quot;Circle.h&quot;</span><br />
The compiler searches the headers in double quotes (such as <code>&quot;Circle.h&quot;</code>) in the <em>current directory</em> first, then the system's include directories. For header in angle bracket (such as <code>&lt;iostream&gt;</code>), the compiler does NOT searches the current directory, but only the system's include directories. Hence, use double quotes for user-defined headers.</li>

<li><span class="line-heading-code-new">Circle::Circle(double r, string c) {</span><br />
You need to include the <code><em>className</em>::</code> (called <em>class scope resolution operator</em>) in front of all the members names, so as to inform the compiler this member belong to a particular class.<br />

(Class Scope: Names defined inside a class have so-called <em>class scope</em>. They are visible within the class only. Hence, you can use the same name in two different classes. To use these names outside the class, the class scope resolution operator <code><em>className</em>::</code> is needed.)</li>

<li>You CANNOT place the default arguments in the implementation (they shall be placed in the header). For example,
<pre class="color-example">
Circle::Circle(double r <span class="color-error">= 1.0</span>, string c <span class="color-error">= &quot;red&quot;</span>) {   <span class="color-error">// error!</span></pre></li>
</ul>

<h5>Compiling the <span class="font-code">Circle</span> Class</h5>
<p>You can compile the <code>Circle.cpp</code> to an object file called <code>Circle.o</code>, via option <code>-c</code> (compile-only) in GNU GCC:</p>

<pre class="color-command">
&gt; <strong>g++ -c Circle.cpp</strong>
    <span class="color-comment">// option –c for compile-only, output is Circle.o</span></pre>

<p>To use the <code>Circle</code> class, the user needs <code>Circle.h</code> and <code>Circle.o</code>.  He does not need <code>Circle.cpp</code>. In other words, you do not need to give away your source codes, but merely the public declarations and the object codes.</p>

<h5><span class="font-code">TestCircle.cpp</span> - Test Driver</h5>

<p>Let's write a test program to use the <code>Circle</code> class created.</p>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
<span class="color-comment">/* A test driver for the Circle class (TestCircle.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Circle.h&quot;  <span class="color-comment"> // using Circle class</span>
using namespace std;
 
int main() {
  <span class="color-comment"> // Construct an instance of Circle c1</span>
   Circle c1(1.2, &quot;red&quot;);
   cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c1.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c1.getArea()
        &lt;&lt; &quot; Color=&quot; &lt;&lt; c1.getColor() &lt;&lt; endl;
 
   c1.setRadius(2.1);  <span class="color-comment"> // Change radius and color of c1</span>
   c1.setColor(&quot;blue&quot;);
   cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c1.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c1.getArea()
        &lt;&lt; &quot; Color=&quot; &lt;&lt; c1.getColor() &lt;&lt; endl;
 
  <span class="color-comment"> // Construct another instance using the default constructor</span>
   Circle c2;
   cout &lt;&lt; &quot;Radius=&quot; &lt;&lt; c2.getRadius() &lt;&lt; &quot; Area=&quot; &lt;&lt; c2.getArea()
        &lt;&lt; &quot; Color=&quot; &lt;&lt; c2.getColor()  &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Compiling the Test Program</h5>

<p>To compile <code>TestCircle.cpp</code> with the object code <code>Circle.o</code> (and <code>Circle.h</code>):</p>

<pre class="color-command">
&gt; <strong>g++ -o TestCircle.exe TestCircle.cpp Circle.o</strong>
     <span class="color-comment">// option -o specifies the output filename</span></pre>

<p>You can also compile <code>TestCircle.cpp</code> with the source code <code>Circle.cpp</code> (and <code>Circle.h</code>)</p>

<pre class="color-command">
&gt; <strong>g++ -o TestCircle.exe TestCircle.cpp Circle.cpp</strong></pre>

<h3 id="timeclass">Example: The <span class="font-code">Time</span> Class</h3>

<img class="image-float-left" src="images/ClassDiagramTime.png" alt="class diagram" />

<p>Let's write a class called <code>Time</code>, which models a specific instance of time with hour, minute and second values, as shown in the class diagram.</p>

<p>The class <code>Time</code> contains the following members:</p>

<ul class="float-left-ol-ul">
<li class="float-left-li">Three <code>private</code> data members: <code>hour</code> (0-23), <code>minute</code> (0-59) and <code>second</code> (0-59), with default values of 0.</li>

<li class="float-left-li">A <code>public</code> constructor <code>Time()</code>, which initializes the  data members <code>hour</code>, <code>minute</code> and <code>second</code> with the  values provided by the caller.</li>

<li class="float-left-li"><code>public</code> getters and setters for private data members: <code>getHour()</code>, <code>getMinute()</code>, <code>getSecond()</code>, <code>setHour()</code>, <code>setMinute()</code>, and <code>setSecond()</code>.</li>

<li class="float-left-li">A <code>public</code> member function <code>setTime()</code> to set the values of <code>hour<span class="color-comment"></span></code>, <code>minute</code> and <code>second</code> given by the caller.</li>

<li class="float-left-li">A <code>public</code> member function <code></code><code>print()</code> to print this <code>Time</code> instance in the format &quot;<code>hh:mm:ss</code>&quot;, zero-filled, e.g., <code>01:30:04</code>.</li>

<li class="float-left-li">A <code>public</code> member function <code>nextSecond()</code>, which increase this instance by one second. <code>nextSecond()</code> of <code>23:59:59</code> shall be <code>00:00:00</code>.</li>
</ul>

<p>Let's write the code for the <code>Time</code> class, with the header and implementation separated in two files: <code>Time.h</code> and <code>Time.cpp</code>.</p>

<h5 class="float-clear">Header - <span class="font-code">Time.h</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Header for the Time class (Time.h) */</span>
<span class="color-new">#ifndef TIME_H</span>  <span class="color-comment"> // Include this &quot;block&quot; only if TIME_H is NOT defined</span>
<span class="color-new">#define TIME_H</span>  <span class="color-comment"> // Upon the first inclusion, define TIME_H so that</span>
                 <span class="color-comment">//  this header will not get included more than once</span>
class Time {
private:  <span class="color-comment">// private section</span>
  <span class="color-comment"> // private data members</span>
   int hour;    <span class="color-comment"> // 0 - 23</span>
   int minute;  <span class="color-comment"> // 0 - 59</span>
   int second;  <span class="color-comment"> // 0 - 59</span>
 
public:   <span class="color-comment">// public section</span>
  <span class="color-comment"> // public member function prototypes</span>
   Time(int h = 0, int m = 0, int s = 0);<span class="color-comment"> // Constructor with default values</span>
   int getHour() const;   <span class="color-comment">// public getter for private data member hour</span>
   void setHour(int h);  <span class="color-comment"> // public setter for private data member hour</span>
   int getMinute() const; <span class="color-comment">// public getter for private data member minute</span>
   void setMinute(int m);<span class="color-comment"> // public setter for private data member minute</span>
   int getSecond() const; <span class="color-comment">// public getter for private data member second</span>
   void setSecond(int s);<span class="color-comment"> // public setter for private data member second</span>
   void setTime(int h, int m, int s);  <span class="color-comment"> // set hour, minute and second</span>
   void print() const;<span class="color-comment"> // Print a description of this instance in &quot;hh:mm:ss&quot;</span>
   void nextSecond(); <span class="color-comment"> // Increase this instance by one second</span>
}; <span class="color-comment"> // need to terminate the class declaration with a semicolon</span>
 
<span class="color-new">#endif</span> <span class="color-comment"> // end of &quot;#ifndef&quot; block</span></pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting <span class="font-code">Time.h</span></h5>

<p><span class="line-heading-code-new">#ifndef TIME_H<br />
#define TIME_H<br />
......<br />
#endif</span><br />
To prevent an header file from included <em>more than once</em> into a source file (which could result in compilation error if an entity is declared twice, e.g., <code>int i</code>), we wrap the header codes within a pair of <em>preprocessor directives</em> <code>#ifndef</code> (if not define) and <code>#endif</code>. The codes within the if-block will only be included if the identifier <code>TIME_H</code> has not been defined. This is true for the first inclusion, which also defines the identifier <code>TIME_H</code> (the first directive in body of the if-block). No subsequent inclusion is possible, since <code>TIME_H</code> has been defined during the first inclusion. By convention, use the identifier <code>XXX_H</code> (or <code>XXX_H_INCLUDED</code>) for header <code>Xxx.h</code>.</p>

<p><span class="line-heading-code-new">class Time {<br />
private:<br />
......<br />
public:<br />
......<br />
};</span><br />
The header <code>Time.h</code> contains the <em>class declaration</em> for the class <code>Time</code>. It is divided into two sections: <code>private</code> and <code>public</code>. The <code>private</code> members (data or functions) are accessible by members of this class only, while <code>public</code> members are visible by all (such as the <code>main()</code> function which is outside the class). The class declaration must be terminated by a semicolon.</p>

<p><span class="line-heading-code-new">private:<br />
&nbsp;&nbsp;&nbsp;int hour;<br />
&nbsp;&nbsp;&nbsp;int minute;<br />
&nbsp;&nbsp;&nbsp;int second;<br />
public:<br />
&nbsp;&nbsp;&nbsp;......</span><br />
We declare 3 private data members called <code>hour</code>, <code>minute</code> and <code>second</code>. In C++98/C++03, you are NOT allow to initialize a data member in the class declaration (except <code>const</code> <code>static</code> <code>int</code> data members). For example, setting <code>hour = 0</code> causes a compilation error.  Instead, the data members are to be initialized in the constructor (to be shown later). The newer C++11 allows initialization of data members.</p>
<p>Only <em>member function prototypes</em> are listed in the class declaration. A function prototype consists of the return-type, function name and parameter types.</p>

<p><span class="line-heading-code-new">Time(int h = 0, int m = 0, int s = 0);</span><br />
declares the so-called <em>constructor</em>. A constructor is a special function that has the same name as the class. A constructor has no return type, or implicitly return <code>void</code>. No <code>return</code> statement is allowed inside the constructor's body. A constructor can only be used during the instance declaration to initialize the data members of the instance. It cannot be invoked thereafter.</p>
<p>In the function prototypes of the header, we can set the default values of the function's parameters for any function member using &quot;<code>= <em>default-value</em></code>&quot;.
  In this case, this constructor can be invoked with 0 to 3 arguments, the omitted <em>trailing</em> arguments will be set to their default values, e.g.,</p>

<pre class="color-example">
Time t1(1, 2, 3); <span class="color-comment">// no default used</span>
Time t2(1, 2);    <span class="color-comment">// s = 0 (default)</span>
Time t3(1);       <span class="color-comment">// m = 0, s = 0 (defaults)</span>
Time t4;          <span class="color-comment">// h = 0, m = 0, s = 0 (all defaults) - no empty parentheses ()</span></pre>

<p>The identifiers <code>h</code>, <code>m</code> and <code>s</code> are not needed in the function prototype - you only need to specify the parameters' types. But they serve as  proper documentation, and are strongly recommended.</p>

<p><span class="line-heading-code-new">int getHour() const;<br />
void setHour(int h);<br />
int getHour() const;<br />
void setHour(int h);<br />
int getHour() const;<br />
void setHour(int h);<br />
</span>

declare the so-called <em>getter</em> and <em>setter</em> for the private data member <code>hour</code>, <code>minute</code> and <code>second</code>. Since the data members are <code>private</code> and are not accessible outside the class, <code>public</code> getters and setters are often provided to read and modify the <code>private</code> data members.  By convention, a getter receives nothing (<code>void</code>) from the caller and returns a value of the type of the data member; a setter receives a value of the type of the data member and returns <code>void</code>. Setters may validate the input before setting the value of the data member.<br />
  We declare the getter function<code></code> <em>constant</em>, by placing the keyword <code>const</code> after the function parameter list. A <code>const</code> member function cannot modify any data member of this object. Getter does not need to modify any data member.</p>

<p><span class="line-heading-code-new">void setTime(int h, int m, int s);<br />
</span>
declares a public member function to set the <code>hour</code>, <code>minute</code> and <code>second</code> of this instance in one call.</p>

<p><span class="line-heading-code-new">void print() const;<br />
</span>
declares a public member function to print this instance in the format <code>HH:MM:SS</code>, zero-filled, e.g., <code>01:56:09</code>. The function <code>print()</code> returns <code>void</code>.</p>

<p><span class="line-heading-code-new">void nextSecond();<br />
</span>
declares a public member function to increase this instance by one second. For example, <code>23:59:59</code> becomes <code>00:00:00</code>. The function <code>nextSecond()</code> returns <code>void</code>.</p>

<h5>Implementation - <span class="font-code">Time.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Implementation for the Time Class (Time.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &quot;Time.h&quot;   <span class="color-comment"> // include header of Time class</span>
using namespace std;
 
<span class="color-comment">// Constructor with default values. No input validation</span>
Time::Time(int h, int m, int s) {
   hour = h;
   minute = m;
   second = s;
}
 
<span class="color-comment">// public getter for private data member hour</span>
int Time::getHour() const {
   return hour;
}
 
<span class="color-comment">// public setter for private data member hour. No input validation</span>
void Time::setHour(int h) {
   hour = h;
}
 
<span class="color-comment">// public getter for private data member minute</span>
int Time::getMinute() const {
   return minute;
}
 
<span class="color-comment">// public setter for private data member minute. No input validation</span>
void Time::setMinute(int m) {
   minute = m;
}
 
<span class="color-comment">// public getter for private data member second</span>
int Time::getSecond() const {
   return second;
}
 
<span class="color-comment">// public setter for private data member second. No input validation</span>
void Time::setSecond(int s) {
   second = s;
}
 
<span class="color-comment">// Set hour, minute and second. No input validation</span>
void Time::setTime(int h, int m, int s) {
   hour = h;
   minute = m;
   second = s;
}
 
<span class="color-comment">// Print this Time instance in the format of &quot;hh:mm:ss&quot;, zero filled</span>
void Time::print() const {
   cout &lt;&lt; setfill('0');   <span class="color-comment"> // zero-filled, need &lt;iomanip&gt;, sticky</span>
   cout &lt;&lt; setw(2) &lt;&lt; hour <span class="color-comment"> // set width to 2 spaces, need &lt;iomanip&gt;, non-sticky</span>
        &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; minute
        &lt;&lt; &quot;:&quot; &lt;&lt; setw(2) &lt;&lt; second &lt;&lt; endl;
}
 
<span class="color-comment">// Increase this instance by one second</span>
void Time::nextSecond() {
   ++second;
   if (second &gt;= 60) {
      second = 0;
      ++minute;
   }
   if (minute &gt;= 60) {
      minute = 0;
      ++hour;
   }
   if (hour &gt;= 24) {
      hour = 0;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting <span class="font-code">Time.cpp</span></h5>

<p>The implementation file <code>Time.cpp</code> contains member's definitions (whereas the header file contains the declarations), in particular, member functions.</p>
<p>All member's identifiers in the implementation are preceded by the <em>classname</em> and the <em>scope resolution operator</em> (<code>::</code>), e.g., <code>Time::Time</code> and <code>Time::getHour</code>, so that the compiler can tell that these identifiers belong to a particular class, in this case, <code>Time</code>.</p>

<p><span class="line-heading-code-new">Time::Time(int h, int m, int s) {<br />
&nbsp;&nbsp;&nbsp;hour = h;<br />
&nbsp;&nbsp;&nbsp;minute = m;<br />
&nbsp;&nbsp;&nbsp;second = s;<br />
}</span><br />
In the constructor, we initialize the <code>private</code> data members <code>hour</code>, <code>minute</code> and <code>second</code> based on the inputs provided by the caller. C++ does NOT initialize  fundamental-type (e.g., <code>int</code>, <code>double</code>) data members. It also does NOT issue an error message if you use an data member before it is initialized. Hence, It is strongly recommended to initialize all the data members in the constructor, so that the constructed instance is complete, instead of relying on the user to set the values of the data members after construction.</p>
<p>The default values of the parameters are specified in the class declaration (in the header), NOT in the function definition. Placing a default value in function definition (e.g., <code>h = 0</code>) causes a compilation error.</p>

<p>Take note that we have not included input validation (e.g., hour shall be between 0 and 23) in the constructor (and setters). We shall do that in the later example.</p>

<p><span class="line-heading-code-new">int Time::getHour() const {<br />
&nbsp;&nbsp;&nbsp;return hour;<br />
}</span><br />
the public getter for private data member <code>hour</code> simply returns the value of the data member <code>hour</code>.</p>

<p><span class="line-heading-code-new">void Time::setHour(int h) {<br />
&nbsp;&nbsp;&nbsp;hour = h;<br />
}</span><br />
the public setter for private data member <code>hour</code> sets the data member <code>hour</code> to the given value <code>h</code>. Again, there is no input validation for h (shall be between 0 to 23).</p>

<p>The rest of the function definitions are self-explanatory.</p>

<h5>"<span class="font-code">this</span>" Pointer</h5>
<p>Instead of naming the function parameters <code>h</code>, <code>m</code> and <code>s</code>, we would like to name the parameters <code>hour</code>, <code>minute</code> and <code>second</code>, which are semantically more meaningful. However, these names crashes with the names of private data members. C++ provides a keyword <code>this</code> (which is a pointer to this instance - to be discussed later) to differentiate between the data members and function parameters. <code>this-&gt;hour</code>, <code>this-&gt;minute</code> and <code>this-&gt;second</code> refer to the data members; while <code>hour</code>, <code>minute</code>, and <code>second</code> refer to the function parameters. We can rewrite the constructor and setter as follows:</p>

<pre class="color-example">
Time::Time(int hour, int minute, int second) {  <span class="color-comment">// Constructor</span>
   this-&gt;hour = hour;
   this-&gt;minute = minute;
   this-&gt;second = second;
}
 
Time::setHour(int hour) {   <span class="color-comment">// Setter for hour</span>
   this-&gt;hour = hour;
}
 
Time::getHour() const {  <span class="color-comment">// Getter for hour</span>
   return this-&gt;hour;    <span class="color-comment">// this-&gt; is the default, and hence optional</span>
}</pre>


<h5>Member Initializer List</h5>
<p>C++ provide an <em>alternative syntax</em> to initialize data members in the constructor called <em> member initializer list</em>. For example,</p>

<pre class="color-example">
Time::Time(int h, int m, int s) <span class="color-new">: hour(h), minute(m), second(s)</span> { 
   <span class="color-comment">// The body runs after the member initializer list
   // empty in this case</span>
}</pre>

<p>The  member initializer list is placed after the function parameter list, separated by a colon, in the form of <code><em>dataMemberName</em>(<em>parameters</em>)</code>. For fundamental-type data members (e.g., <code>int</code>, <code>double</code>), <code>hour(h)</code> is the same as <code>hour = h</code>. For object data members (to be discussed later), the <em>copy constructor</em> will be invoked. The function body will be executed <em>after</em> the  member initializer list, which is empty in this case.</p>
<p>The data members in the initializer list are initialized in the order of their declarations in the class declaration, not the order in the initializer list.</p>

<h5>Test Driver - <span class="font-code">TestTime.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Driver for the Time class (TestTime.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Time.h&quot;   <span class="color-comment"> // include header of Time class</span>
using namespace std;
 
int main() {
   Time t1(23, 59, 59);  <span class="color-comment"> // Test constructor</span>
 
  <span class="color-comment"> // Test all public member functions</span>
   t1.print();      <span class="color-comment"> // 23:59:59</span>
   t1.setHour(12);
   t1.setMinute(30);
   t1.setSecond(15);
   t1.print();      <span class="color-comment"> // 12:30:15</span>
   cout &lt;&lt; &quot;Hour is &quot;   &lt;&lt; t1.getHour()   &lt;&lt; endl;
   cout &lt;&lt; &quot;Minute is &quot; &lt;&lt; t1.getMinute() &lt;&lt; endl;
   cout &lt;&lt; &quot;Second is &quot; &lt;&lt; t1.getSecond() &lt;&lt; endl;
 
   Time t2;    <span class="color-comment"> // Test constructor with default values for hour, minute and second</span>
   t2.print(); <span class="color-comment"> // 00:00:00</span>
   t2.setTime(1, 2, 3);
   t2.print(); <span class="color-comment"> // 01:02:03</span>
 
   Time t3(12);<span class="color-comment"> // Use default values for minute and second</span>
   t3.print(); <span class="color-comment"> // 12:00:00</span>
 
  <span class="color-comment"> // Test nextSecond()</span>
   Time t4(23, 59, 58);
   t4.print();
   t4.nextSecond();
   t4.print();
   t4.nextSecond();
   t4.print();
 
  <span class="color-comment"> // No input validation</span>
   Time t5(25, 61, 99);<span class="color-comment"> // values out of range</span>
   t5.print(); <span class="color-comment"> // 25:61:99</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting <span class="font-code">TestTime.cpp</span></h5>

<p>The test driver tests the constructor (with and without the default values) and all the public member functions. Clearly, no input validation is carried out, as reflected in instance <code>t5</code>.</p>

<h5>Exercise</h5>
<p>Add member functions <code>previousSecond()</code>, <code>nextMinute()</code>, <code>previousMinute()</code>, <code>nextHour()</code>, <code>previousHour()</code> to the <code>Time</code> class.</p>

<h5>Compiling the Program</h5>

<p>You can compile all the source file together to get the executable file as follows:</p>
<pre class="color-command">
<span class="color-comment">// Using GCC on Windows</span>
<span class="color-comment">// Compile all source files, -o specifies the output</span>
&gt; g++ -o TestTime.exe <span class="color-new">Time.cpp</span> TestTime.cpp  
<span class="color-comment">// Execute the program</span>
&gt; TestTime</pre>

<p>Alternatively, you can compile <code>Time.cpp</code> into an object file <code>Time.o</code>, and then the test driver with the object file. In this way, you only distribute the object file and header file, not the source file.</p>

<pre class="color-command">
<span class="color-comment">// Compile Time.cpp into object file Time.o, with -c option</span>
&gt; g++ -c Time.cpp
<span class="color-comment">// Compile test driver with object file</span>
&gt; g++ -o TestTime.exe TestTime.cpp <span class="color-new">Time.o</span>
<span class="color-comment">// Execute the test driver</span>
&gt; TestTime</pre>


<h3>Example: The <span class="font-code">Point</span> Class</h3>

<img class="image-float-left" src="images/ClassDiagramPoint.png" alt="ClassDiagramPoint.png" />

<p>The <code>Point</code> class, as shown in the class diagram, models 2D points with x and y co-ordinates.</p>

<p>In the class diagram, &quot;<code>-</code>&quot; denotes <code>private</code> member; &quot;<code>+</code>&quot; denotes <code>public</code> member. &quot;<code>= xxx</code>&quot; specifies the default value of a data member.</p>

<p>The <code>Point</code> class contains the followings:</p>

<ul class="float-left-ol-ul">
<li class="float-left-li">Private data members <code>x</code> and <code>y</code> (of type <code>int</code>), with default values of 0.</li>

<li class="float-left-li">A constructor, getters and setters for private data member <code>x</code> and <code>y</code>.</li>

<li class="float-left-li">A function setXY() to set both <code>x</code> and <code>y</code> coordinates of a <code>Point</code>.</li>

<li class="float-left-li">A function <code>getMagnitude()</code> which returns <code>√(x<sup>2</sup>+y<sup>2</sup>)</code>. You can use the built-in <code>sqrt()</code> function in <code>&lt;cmath&gt;</code> to compute the square root.</li>

<li class="float-left-li">A function <code>getArgument()</code> which returns <code>tan<sup>-1</sup>(y/x)</code>. You can use the built-in <code>atan2(y, x)</code> function in <code>&lt;cmath&gt;</code> to compute the gradient in radians.</li>

<li class="float-left-li">A function <code>print()</code> which prints &quot;<code>(x,y)</code>&quot; of this instance.</li>
</ul>

<h5 class="float-clear"><span class="font-code">Point.h</span> - Header</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
<span class="color-comment">/* The Point class Header (Point.h) */</span>
#ifndef POINT_H
#define POINT_H
 
<span class="color-comment">// Point class declaration</span>
class Point {
private:
   <span class="color-comment">// private data members (variables)</span>
   int x;
   int y;
 
public:
  <span class="color-comment"> // Declare member function prototypes</span>
   Point(int x = 0, int y = 0); <span class="color-comment"> // Constructor with default values</span>
   int getX() const;
   void setX(int x);
   int getY() const;
   void setY(int y);
   void setXY(int x, int y);
   double getMagnitude() const;
   double getArgument() const;
   void print() const;
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<h5><span class="font-code">Point.cpp</span> - Implementation</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre>
</td>
<td>
<pre>
<span class="color-comment">/* The Point class Implementation (Point.cpp) */</span>
#include &quot;Point.h&quot;<span class="color-comment"> // user-defined header in the same directory</span>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
 
<span class="color-comment">// Constructor (default values can only be specified in the declaration)</span>
Point::Point(int x, int y) : x(x), y(y) { }  <span class="color-comment">// Use member initializer list</span>
 
<span class="color-comment">// Public getter for private data member x</span>
int Point::getX() const {
   return x;
}
 
<span class="color-comment">// Public setter for private data member x</span>
void Point::setX(int x) {
   this-&gt;x = x;
}
 
<span class="color-comment">// Public getter for private data member y</span>
int Point::getY() const {
   return y;
}
 
<span class="color-comment">// Public setter for private data member y</span>
void Point::setY(int y) {
   this-&gt;y = y;
}
 
<span class="color-comment">// Public member function to set both x and y</span>
void Point::setXY(int x, int y) {
   this-&gt;x = x;
   this-&gt;y = y;
}
 
<span class="color-comment">// Public member function to return the magitude</span>
double Point::getMagnitude() const {
   return sqrt(x*x + y*y);   <span class="color-comment"> // sqrt in &lt;cmath&gt;</span>
}
 
<span class="color-comment">// Public member function to return the argument</span>
double Point::getArgument() const {
   return atan2(y, x);   <span class="color-comment"> // atan2 in &lt;cmath&gt;</span>
}
 
<span class="color-comment">// Public member function to print description about this point</span>
void Point::print() const {
   cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5><span class="font-code">TestPoint.cpp</span> - Test Driver</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
<span class="color-comment">/* A test driver for the Point class (TestPoint.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &quot;Point.h&quot;  <span class="color-comment"> // using Point class</span>
using namespace std;
 
int main() {
  <span class="color-comment"> // Construct an instance of Point p1</span>
   Point p1(3, 4);
   p1.print();
   cout &lt;&lt; &quot;x = &quot; &lt;&lt; p1.getX() &lt;&lt; endl;
   cout &lt;&lt; &quot;y = &quot; &lt;&lt; p1.getY() &lt;&lt; endl;
   cout &lt;&lt; fixed &lt;&lt; setprecision(2);
   cout &lt;&lt; &quot;mag = &quot; &lt;&lt; p1.getMagnitude() &lt;&lt; endl;
   cout &lt;&lt; &quot;arg = &quot; &lt;&lt; p1.getArgument() &lt;&lt; endl;
   p1.setX(6);
   p1.setY(8);
   p1.print();
   p1.setXY(1, 2);
   p1.print();
 
  <span class="color-comment"> // Construct an instance of Point using default constructor</span>
   Point p2;
   p2.print();
}</pre>
</td>
</tr>
</tbody>
</table>


<h3 id="accountclass">Example: The <span class="font-code">Account</span> Class</h3>

<img class="image-float-left" src="images/ClassDiagramAccount.png" alt="class diagram" />

<p>A class called <code>Account</code>, which models a bank account, is designed as shown in the class diagram. It contains:</p>

<ul class="float-left-ol-ul">
<li class="float-left-li">Two private data members: <code>accountNumber</code> (<code>int</code>) and <code>balance</code> (<code>double</code>), which maintains the current account balance.</li>

<li class="float-left-li">Public functions <code>credit()</code> and <code>debit()</code>, which adds or subtracts the given amount from the balance, respectively. The <code>debit()</code> function shall print &quot;amount withdrawn exceeds the current balance!&quot; if <code>amount</code> is more than <code>balance</code>.</li>

<li class="float-left-li">A public function <code>print()</code>, which shall print &quot;A/C no: xxx Balance=xxx&quot; (e.g., A/C no: 991234 Balance=$88.88), with <code>balance</code> rounded to two decimal places.</li>
</ul>

<h5 class="float-clear">Header file - <span class="font-code">Account.h</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Header for Account class (Account.h) */</span>
#ifndef ACCOUNT_H
#define ACCOUNT_H
 
class Account {
private:
   int accountNumber;
   double balance;
 
public:
   Account(int accountNumber, double balance = 0.0);
   int getAccountNumber() const;
   double getBalance() const;
   void setBalance(double balance);
   void credit(double amount);
   void debit(double amount);
   void print() const;
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<h5>Implementation file - <span class="font-code">Account.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td>
<td>
<pre>
<span class="color-comment">/* Implementation for the Account class (Account.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &quot;Account.h&quot;
using namespace std;
 
<span class="color-comment">// Constructor</span>
Account::Account(int no, double b) : accountNumber(no), balance(b) { }
 
<span class="color-comment">// Public getter for private data member accountNumber</span>
int Account::getAccountNumber() const {
   return accountNumber;
}
 
<span class="color-comment">// Public getter for private data member balance</span>
double Account::getBalance() const {
   return balance;
}
 
<span class="color-comment">// Public setter for private data member balance</span>
void Account::setBalance(double b) {
   balance = b;
}
 
<span class="color-comment">// Adds the given amount to the balance</span>
void Account::credit(double amount) {
   balance += amount;
}
 
<span class="color-comment">// Subtract the given amount from the balance</span>
void Account::debit(double amount) {
   if (amount &lt;= balance) {
      balance -= amount;
   } else {
      cout &lt;&lt; &quot;Amount withdrawn exceeds the current balance!&quot; &lt;&lt; endl;
   }
}
 
<span class="color-comment">// Print description for this Account instance</span>
void Account::print() const {
   cout &lt;&lt; fixed &lt;&lt; setprecision(2);
   cout &lt;&lt; &quot;A/C no: &quot; &lt;&lt; accountNumber &lt;&lt; &quot; Balance=$&quot; &lt;&lt; balance &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Test Driver - <span class="font-code">TestAccount.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Driver for Account class (TestAccount.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Account.h&quot;
 
using namespace std;
 
int main() {
    Account a1(8111, 99.99);
    a1.print();    <span class="color-comment"> // A/C no: 8111 Balance=$99.99</span>
    a1.credit(20);
    a1.debit(10);
    a1.print();    <span class="color-comment"> // A/C no: 8111 Balance=$109.99</span>
 
    Account a2(8222); <span class="color-comment"> // default balance</span>
    a2.print();       <span class="color-comment"> // A/C no: 8222 Balance=$0.00</span>
    a2.setBalance(100);
    a2.credit(20);
    a2.debit(200); <span class="color-comment"> // Amount withdrawn exceeds the current balance!</span>
    a2.print();    <span class="color-comment"> // A/C no: 8222 Balance=$120.00</span>
    return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h3 id="ballclass">Example: The <span class="font-code">Ball</span> class</h3>

<img class="image-float-left" src="images/ClassDiagramBall.png" alt="class diagram" />

<p>A <code>Ball</code> class models a moving ball, designed as shown in the class diagram, contains the following members:</p>

<ul class="float-left-ol-ul">
<li class="float-left-li">Four <code>private</code> data members <code>x</code>, <code>y</code>, <code>xSpeed</code> and <code>ySpeed</code> to maintain the position and speed of the ball.</li>

<li class="float-left-li">A constructor, and public getters and setters for the private data members.</li>

<li class="float-left-li">A function <code>setXY()</code>, which sets the position of the ball and <code>setXYSpeed()</code> to set the speed of the ball.</li>

<li class="float-left-li">A function <code>move()</code>, which increases <code>x</code> and <code>y</code> by <code>xSpeed</code> and <code>ySpeed</code>, respectively.</li>

<li class="float-left-li">A function <code>print()</code>, which prints &quot;<code>Ball @ (x,y) with speed (xSpeed,ySpeed)</code>&quot;, to 2 decimal places.</li>
</ul>

<h5 class="float-clear">Header File - <span class="font-code">Ball.h</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Header for the Ball class (Ball.h) */</span>
#ifndef BALL_H
#define BALL_H
 
class Ball {
private:
   double x, y;          <span class="color-comment"> // Position of the ball</span>
   double xSpeed, ySpeed;<span class="color-comment"> // Speed of the ball</span>
 
public:
   Ball(double x = 0.0, double y = 0.0, <span class="color-comment"> // Constructor with default values</span>
        double xSpeed = 0.0, double ySpeed = 0.0);
   double getX() const;
   void setX(double x);
   double getY() const;
   void setY(double y);
   double getXSpeed() const;
   void setXSpeed(double xSpeed);
   double getYSpeed() const;
   void setYSpeed(double ySpeed);
   void setXY(double x, double y);
   void setXYSpeed(double xSpeed, double ySpeed);
   void move();
   void print() const;
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<h5>Implementation File - <span class="font-code">Ball.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></td>
<td>
<pre>
<span class="color-comment">/* Implementation for the Ball Class (Ball.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &quot;Ball.h&quot;   <span class="color-comment"> // include header of Ball class</span>
using namespace std;
 
<span class="color-comment">// Constructor with default values. No input validation</span>
Ball::Ball(double x, double y, double xSpeed, double ySpeed)
      : x(x), y(y), xSpeed(xSpeed), ySpeed(ySpeed) { } <span class="color-comment"> // use member initializer list</span>
 
<span class="color-comment">// public getters/setters for private data members</span>
double Ball::getX() const {
   return x;
}
double Ball::getY() const {
   return y;
}
void Ball::setX(double x) {
   this-&gt;x = x;
}
void Ball::setY(double y) {
   this-&gt;y = y;
}
double Ball::getXSpeed() const {
   return xSpeed;
}
double Ball::getYSpeed() const {
   return ySpeed;
}
void Ball::setXSpeed(double xSpeed) {
   this-&gt;xSpeed = xSpeed;
}
void Ball::setYSpeed(double ySpeed) {
   this-&gt;ySpeed = ySpeed;
}
 
<span class="color-comment">// Set position (x,y)</span>
void Ball::setXY(double x, double y) {
   this-&gt;x = x;
   this-&gt;y = y;
}
 
<span class="color-comment">// Set speed (xSpeed,ySpeed)</span>
void Ball::setXYSpeed(double xSpeed, double ySpeed) {
   this-&gt;xSpeed = xSpeed;
   this-&gt;ySpeed = ySpeed;
}
 
<span class="color-comment">// Move the ball by increases x and y by xSpeed and ySpeed</span>
void Ball::move() {
   x += xSpeed;   <span class="color-comment">// increment x by xSpeed</span>
   y += ySpeed;   <span class="color-comment">// increment y by ySpeed</span>
}
 
<span class="color-comment">// Print a description about this Ball instance</span>
void Ball::print() const {
   cout &lt;&lt; fixed &lt;&lt; setprecision(2);
   cout &lt;&lt; &quot;Ball @ (&quot; &lt;&lt; x &lt;&lt; ',' &lt;&lt; y &lt;&lt; &quot;) with speed (&quot;
        &lt;&lt; xSpeed &lt;&lt; ',' &lt;&lt; ySpeed &lt;&lt; ')' &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Test Driver - <span class="font-code">TestBall.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Driver for the Ball class (TestBall.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Ball.h&quot;   <span class="color-comment"> // include header of Ball class</span>
using namespace std;
 
int main() {
   Ball ball;
   ball.print();   <span class="color-comment"> // Ball @ (0.00,0.00) with speed (0.00,0.00)</span>
   ball.setXY(1.1, 2.2);
   ball.setXYSpeed(3.3, 4.4);
   ball.print();   <span class="color-comment"> // Ball @ (1.10,2.20) with speed (3.30,4.40)</span>
   ball.setX(5.5);
   ball.setY(6.6);
   cout &lt;&lt; &quot;x is &quot; &lt;&lt; ball.getX() &lt;&lt; endl; <span class="color-comment"> // x is 5.50</span>
   cout &lt;&lt; &quot;y is &quot; &lt;&lt; ball.getY() &lt;&lt; endl; <span class="color-comment"> // y is 6.60</span>
   ball.move();
   ball.print();   <span class="color-comment"> // Ball @ (8.80,11.00) with speed (3.30,4.40)</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h3 id="authorbook">Example: The <span class="font-code">Author</span> and <span class="font-code">Book</span> Classes (for a Bookstore)</h3>

<h4>Let's start with the <span class="font-code">Author</span> class</h4>

<img class="image-float-left" src="images/ClassDiagramAuthor.png" alt="class diagram" />

<p>Let's begin with a class called <code>Author</code>, designed as shown in the class diagram. It contains:</p>

<ul class="float-left-ol-ul">
<li class="float-left-li">Three <code>private</code> data members: <code>name</code> (<code>string</code>), <code>email</code> (<code>string</code>), and <code>gender</code> (<code>char</code> of <code>'m'</code>, <code>'f'</code> or <code>'u'</code> for unknown).</li>

<li class="float-left-li">A constructor to initialize the <code>name</code>, <code>email</code> and <code>gender</code> with the given values. There are no default values for data members.</li>

<li class="float-left-li">Getters for <code>name</code>, <code>email</code> and <code>gender</code>, and setter for <code>email</code>. There is no setter for <code>name</code> and <code>gender</code> as we assume that these attributes cannot be changed.</li>

<li class="float-left-li">A <code>print()</code> member function that prints &quot;<em>name</em> (<em>gender</em>) at <em>email</em>&quot;, e.g., &quot;Peter Jones (m) at peter@somewhere.com&quot;.</li>
</ul>

<h5 class="float-clear">Header File - <span class="font-code">Author.h</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Header for the Author class (Author.h) */</span>
#ifndef AUTHOR_H
#define AUTHOR_H
 
#include &lt;string&gt;
using namespace std;
 
class Author {
private:
   string name;
   string email;
   char gender;   <span class="color-comment">// 'm', 'f', or 'u' for unknown</span>
 
public:
   Author(string name, string email, char gender);
   string getName() const;
   string getEmail() const;
   void setEmail(string email);
   char getGender() const;
   void print() const;
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<h5>Implementation File - <span class="font-code">Author.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Implementation for the Author class (Author.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Author.h&quot;
using namespace std;
 
<span class="color-comment">// Constructor, with input validation</span>
Author::Author(string name, string email, char gender) {
   this-&gt;name = name;
   setEmail(email);  <span class="color-comment">// Call setter to check for valid email</span>
   if (gender == 'm' || gender == 'f') {
      this-&gt;gender = gender;
   } else {
      cout &lt;&lt; &quot;Invalid gender! Set to 'u' (unknown).&quot; &lt;&lt; endl;
      this-&gt;gender = 'u';
   }
}
 
string Author::getName() const {
   return name;
}
 
string Author::getEmail() const {
   return email;
}
 
void Author::setEmail(string email) {
   <span class="color-comment">// Check for valid email. Assume that a valid email contains</span>
   <span class="color-comment">//  a '@' that is not the first nor last character.</span>
   size_t atIndex = email.find('@');
   if (atIndex != string::npos &amp;&amp; atIndex != 0 &amp;&amp; atIndex != email.length()-1) {
      this-&gt;email = email;
   } else {
      cout &lt;&lt; &quot;Invalid email! Set to empty string.&quot; &lt;&lt; endl;
      this-&gt;email = &quot;&quot;;
   }
}
 
char Author::getGender() const {
   return gender;
}
 
<span class="color-comment">// print in the format &quot;name (gender) at email&quot;</span>
void Author::print() const {
   cout &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; gender &lt;&lt; &quot;) at &quot; &lt;&lt; email &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the <span class="font-code">Author.cpp</span></h5>

<p><span class="line-heading-code-new">Author::Author(string name, string email, char gender) {<br />
&nbsp;&nbsp;&nbsp;this-&gt;name = name;<br />
&nbsp;&nbsp;&nbsp;setEmail(email);<br />
</span>
In this example, we use identifier <code>name</code> in the function's parameter, which crashes with the data member's identifier <code>name</code>. To differentiate between the two identifiers, we use the keyword <code>this</code>, which is a pointer to this instance. <code>this-&gt;name</code> refers to the data member; while <code>name</code> refers to the function's parameter.<br />
No input validation is done on the parameter <code>name</code>.  On the other hand, for <code>email</code>, we invoke setter <code>setEmail()</code> which performs input validation.</p>

<p><span class="line-heading-code-new">&nbsp;&nbsp;&nbsp;if (gender == 'm' || gender == 'f') {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;gender = gender;<br />
&nbsp;&nbsp;&nbsp;} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &quot;Invalid gender! Set to 'u' (unknown).&quot; &lt;&lt; endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;gender = 'u';<br />
&nbsp;&nbsp;&nbsp;}<br />
}</span><br />
We validate the input for <code>gender</code> (<code>'m'</code>, <code>'f'</code>, or <code>'u'</code> for unknown). We assign <code>'u'</code> for any other inputs.</p>


<p><span class="line-heading-code-new">void Author::setEmail(string email) {<br />
&nbsp;&nbsp;&nbsp;size_t found = email.find('@');<br />
&nbsp;&nbsp;&nbsp;if (found != string::npos &amp;&amp; found != 0 &amp;&amp; found != email.length()-1) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;email = email;<br />
&nbsp;&nbsp;&nbsp;} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &quot;Invalid email! Set to empty string.&quot; &lt;&lt; endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;email = &quot;&quot;;<br />
&nbsp;&nbsp;&nbsp;}<br />
}</span><br />
To validate <code>email</code>, we assume that there is an <code>'@'</code> which is not the first or last character (there are other stricter email validation criteria). We use the <code>string</code> class function <code>find()</code> to find the position of the character <code>'@'</code>, which returns a value of type <code>size_t</code> (typically same as <code>unsigned int</code>). The function <code>find()</code> returns a special constant <code>string::npos</code> (which is typically set to -1) to indicate &quot;not found&quot;; 0 for the first character and <code>length()-1</code> for the last character (where <code>string</code>'s function <code>length()</code> returns the length of the string).</p>

<h5 class="font-code">TestAuthor.cpp</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Driver for the Author class (TestAuthor.cpp) */</span>
#include &quot;Author.h&quot;
 
int main() {
  <span class="color-comment"> // Declare and construct an instance of Author</span>
   Author peter(&quot;Peter Jones&quot;, &quot;peter@somewhere.com&quot;, 'm');
   peter.print();
     <span class="color-comment"> // Peter Jones (m) at peter@somewhere.com</span>
   peter.setEmail(&quot;peter@xyz.com&quot;);
   peter.print();
     <span class="color-comment"> // Peter Jones (m) at peter@xyz.com</span>
 
   Author paul(&quot;Paul Jones&quot;, &quot;@somewhere.com&quot;, 'n');
     <span class="color-comment"> // Invalid email! Set to empty string.</span>
     <span class="color-comment"> // Invalid gender! Set to 'u' (unknown).</span>
   paul.setEmail(&quot;paul@&quot;);
     <span class="color-comment"> // Invalid email! Set to empty string.</span>
   paul.print();
     <span class="color-comment"> // Paul Jones (u) at</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>A Book is written by an Author - Using an &quot;Object&quot; Data Member</h4>

<img class="image-float-left" src="images/ClassDiagramBook.png" alt="class diagram" />

<p>Let's design a <code>Book</code> class. Assume that a book is written by one and only one author. The <code>Book</code> class (as shown in the class diagram) contains the following members:</p>

<ul class="float-left-ol-ul">
<li class="float-left-li">Four <code>private</code> data members: <code>name</code> (<code>string</code>), <code>author</code> (an instance of the class <code>Author</code> that we have created earlier), <code>price</code> (<code>double</code>), and <code>qtyInStock</code> (<code>int</code>, with default value of 0). The <code>price</code> shall be positive and the <code>qtyInStock</code> shall be zero or positive.<br />
Take note that data member <code>author</code> is an instance (object)  of the class <code>Author</code>, instead of a fundamental types (such as <code>int</code>, <code>double</code>). In fact, <code>name</code> is an object of the class <code>string</code> too.</li>

<li class="float-left-li">The <code>public</code> getters and setters for the <code>private</code> data members. Take note that <code>getAuthor()</code> returns an object (an instance of class <code>Author</code>).</li>

<li class="float-left-li">A <code>public</code> member function <code>print()</code>, which prints &quot;'<em>book-name</em>' by <em>author-name</em> (<em>gender</em>) @ <em>email</em>&quot;.</li>

<li class="float-left-li">A <code>public</code> member function <code>getAuthorName()</code>, which returns the <code>name</code> of the author of this <code>Book</code> instance.</li>
</ul>

<p>The <em>hallow diamond shape</em> in the class diagram denotes <em>aggregation</em> (or <em>has-a</em>) association relationship. That is, a <code>Book</code> instance <em>has</em> one (and only one) <code>Author</code> instance as its component.</p>

<h5 class="float-clear">Header File - <span class="font-code">Book.h</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></td>
<td>
<pre>
<span class="color-comment">/* Header for the class Book (Book.h) */</span>
#ifndef BOOK_H
#define BOOK_H
 
#include &lt;string&gt;
<span class="color-new">#include &quot;Author.h&quot;</span>   <span class="color-comment">// Use the Author class</span>
using namespace std;
 
class Book {
private:
   string name;
   <span class="color-new">Author author;</span> <span class="color-comment">// data member author is an instance of class Author</span>
   double price;
   int qtyInStock;
 
public:
   Book(string name, <span class="color-new">Author author</span>, double price, int qtyInStock = 0);
      <span class="color-comment">// To recieve an instance of class Author as argument</span>
   string getName() const;
   <span class="color-new">Author getAuthor() const;</span>  <span class="color-comment">// Returns an instance of the class Author</span>
   double getPrice() const;
   void setPrice(double price);
   int getQtyInStock() const;
   void setQtyInStock(int qtyInStock);
   void print() const;
   <span class="color-new">string getAuthorName() const;</span>
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading-code-new">#include &quot;Author.h&quot;<br /></span>
We need to include the &quot;<code>Author.h</code>&quot; header, as we use the <code>Author</code> class in this class <code>Book</code>.</p>

<p><span class="line-heading-code-new">private:<br />
&nbsp;&nbsp;&nbsp;Author author;<br />
</span>
We declare a <code>private</code> data member <code>author</code> as an instance of class <code>Author</code>, defined earlier.</p>

<h5>Implementation File - <span class="font-code">Book.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Implementation for the class Book (Book.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Book.h&quot;
using namespace std;
 
<span class="color-comment">// Constructor, with member initializer list to initialize the</span>
<span class="color-comment">//  component Author instance</span>
Book::Book(string name, <span class="color-new">Author author</span>, double price, int qtyInStock)
      : name(name), <span class="color-new">author(author)</span> {   <span class="color-comment">// Must use member initializer list to construct object</span>
   <span class="color-comment">// Call setters to validate price and qtyInStock</span>
   setPrice(price);
   setQtyInStock(qtyInStock);
}
 
string Book::getName() const {
   return name;
}
 
Author Book::getAuthor() const {
   return author;
}
 
double Book::getPrice() const {
   return price;
}
 
<span class="color-comment">// Validate price, which shall be positive</span>
void Book::setPrice(double price) {
   <span class="color-new">if (price &gt; 0) {
      this-&gt;price = price;
   } else {
      cout &lt;&lt; &quot;price should be positive! Set to 0&quot; &lt;&lt; endl;
      this-&gt;price = 0;
   }</span>
}
 
int Book::getQtyInStock() const {
   return qtyInStock;
}
 
<span class="color-comment">// Validate qtyInStock, which cannot be negative</span>
void Book::setQtyInStock(int qtyInStock) {
   if (qtyInStock &gt;= 0) {
      this-&gt;qtyInStock = qtyInStock;
   } else {
      cout &lt;&lt; &quot;qtyInStock cannot be negative! Set to 0&quot; &lt;&lt; endl;
      this-&gt;qtyInStock = 0;
   }
}
 
<span class="color-comment">// print in the format &quot;&quot;Book-name&quot; by author-name (gender) at email&quot;</span>
void Book::print() const {
   cout &lt;&lt; &quot;'&quot; &lt;&lt; name &lt;&lt; &quot;' by &quot;;
   author.print();
}
 
<span class="color-comment">// Return the author' name for this Book</span>
<span class="color-new">string Book::getAuthorName() const {
   return author.getName();   <span class="color-comment">// invoke the getName() on instance author</span>
}</span></pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading-code-new">Book::Book(string name, <strong>Author author</strong>, double price, int qtyInStock)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: name(name), <strong>author(author)</strong> {<br />
&nbsp;&nbsp;&nbsp;setPrice(price);<br />
&nbsp;&nbsp;&nbsp;setQtyInStock(qtyInStock);<br />
}</span><br />
In the constructor, the caller is supposed to create an instance of <code>Author</code>, and pass the instance into the constructor. We use <em>member initializer list</em> to initialize data members <code>name</code> and <code>author</code>. We call setters in the body, which perform input validation to set the <code>price</code> and <code>qtyInStock</code>. The body is run after the  member initializer list. The <code>author(author)</code> invokes the default <em>copy constructor</em> of the <code>Author</code> class, which performs memberwise copy for all the data members. Object data member shall be constructed via the  member initializer list, not in the body. Otherwise, the default constructor will be invoked to construct the object.</p>

<p><span class="line-heading-code-new">void Book::setPrice(double price) {<br />
&nbsp;&nbsp;&nbsp;if (price &gt; 0) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;price = price;<br />
&nbsp;&nbsp;&nbsp;} else {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &quot;price should be positive! Set to 0&quot; &lt;&lt; endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this-&gt;price = 0;<br />
&nbsp;&nbsp;&nbsp;}<br />
}<br />
</span>
The setter for <code>price</code> validates the given input.</p>

<p><span class="line-heading-code-new">string Book::getAuthorName() const {<br />
&nbsp;&nbsp;&nbsp;return author.getName();<br />
}</span><br />
Invoke the <code>getName()</code> of the data member <code>author</code>, which returns the author's name of this <code>Book</code> instance.</p>

<h5 class="font-code">TestBook.cpp</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Driver for the Book class (TestBook.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Book.h&quot;
using namespace std;
 
int main() {
  <span class="color-comment"> // Declare and construct an instance of Author</span>
   Author peter(&quot;Peter Jones&quot;, &quot;peter@somewhere.com&quot;, 'm');
   peter.print(); <span class="color-comment"> // Peter Jones (m) at peter@somewhere.com</span>
 
  <span class="color-comment"> // Declare and construct an instance of Book</span>
   Book cppDummy(&quot;C++ for Dummies&quot;, peter, 19.99);
   cppDummy.setQtyInStock(88);
   cppDummy.print();
     <span class="color-comment"> // 'C++ for Dummies' by Peter Jones (m) at peter@somewhere.com</span>
 
   cout &lt;&lt; cppDummy.getQtyInStock() &lt;&lt; endl; <span class="color-comment"> // 88</span>
   cout &lt;&lt; cppDummy.getPrice() &lt;&lt; endl;      <span class="color-comment"> // 19.99</span>
   cout &lt;&lt; cppDummy.getAuthor().getName() &lt;&lt; endl; <span class="color-comment"> // &quot;Peter Jones&quot;</span>
   cout &lt;&lt; cppDummy.getAuthor().getEmail() &lt;&lt; endl;<span class="color-comment"> // &quot;peter@somewhere.com&quot;</span>
   cout &lt;&lt; cppDummy.getAuthorName() &lt;&lt; endl;       <span class="color-comment"> // &quot;Peter Jones&quot;</span>
 
   Book moreCpp(&quot;More C++ for Dummies&quot;, peter, -19.99);
     <span class="color-comment"> // price should be positive! Set to 0</span>
   cout &lt;&lt; moreCpp.getPrice() &lt;&lt; endl;  <span class="color-comment"> // 0</span>
}</pre>
</td>
</tr>
</tbody>
</table>


<h5>The Default Copy Constructor</h5>
<p>The initializer <code>author(author)</code> in the constructor invokes the so-called <em>copy constructor</em>. A <em>copy constructor</em> creates a new instance by copying the given instance of the same class. If you do not provide a copy constructor in your class, C++ provides a <em>default</em> <em>copy constructor</em>, which construct a new object via memberwise copy. For example, for <code>Author</code> class, the default copy constructor provided by the compiler is as follows:</p>

<pre class="color-example">
<span class="color-comment">// Default copy constructor of Author class provided by C++</span>
Author::Author(const Author&amp; other)
      : name(other.name), email(other.email), gender(other.gender) { }  <span class="color-comment">// memberwise copy</span></pre>
      
<h4>Pass-by-Reference for Objects Function Parameters <span class="font-code">Author</span> and <span class="font-code">string</span></h4>

<p>By default, objects are pass-by-value into functions. That is, a clone copy is created and pass into the function, instead of the original copy. Pass-by-value for huge objects depicts performance due to the overhead of creating a clone copy.</p>

<p>Instead, we could pass an object into function <em>by reference</em>, via the reference (<code>&amp;</code>) declaration in the parameter list. If we do not intend to modify the object inside the function (with side effect to the original copy), we set it as <code>const</code>.</p>

<p>In the <code>Book</code> class,  data members of <code>string</code> and <code>Author</code> are objects. <code>Author</code> class was defined earlier; <code>string</code> is a class provided in C++ header <code>&lt;string&gt;</code>, belonging to the namespace <code>std</code>. Instead of including &quot;<code>using namespace std;</code>&quot; in the header (which is a poor practice as this statement will be included in all the files using this header), we shall use the scope resolution operator and refer to it as <code>std::string</code>.</p>
<p>Let's modify our <code>Book</code> class to illustrate pass-by-reference (for  performance).</p>

<h5><span class="font-code">Author.h</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Header for Author class (Author.h) */</span>
#ifndef AUTHOR_H
#define AUTHOR_H
 
#include &lt;string&gt;
 
class Author {
private:
   std::string name;
   std::string email;
   char gender;  <span class="color-comment"> // 'm', 'f', or 'u' for unknown</span>
 
public:
   Author(<span class="color-new">const std::string &amp; name, const std::string &amp; email</span>, char gender);
          <span class="color-comment">// &amp; specifies pass by reference, const for non-mutable</span>
   std::string getName() const;
   std::string getEmail() const;
   void setEmail(<span class="color-new">const std::string &amp; email</span>);
   char getGender() const;
   void print() const;
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>In C++, <code>string</code> is a class in the standard library (in header &lt;string&gt;, belonging to namespace <code>std</code>), just like <code>Point</code>, <code>Circle</code> classes that we have defined.</li>
<li>Instead of including &quot;<code>using namespace std;</code>&quot;, which is a poor practice as this statement will be included in all the files using this header, we use the fully-qualified name <code>std::string</code>.</li>
<li>Instead of passing <code>string</code> objects by value into function, which affects performance as a clone copy needs to be made. We pass the <code>string</code> objects by reference (indicated by <code>&amp;</code>).</li>
<li>However, in pass-by-reference, changes inside the function will affect the caller's copy outside the function.</li>
<li>If we do not intend to change the object inside the function, we could use keyword <code>const</code> to indicate immutability. If the object is inadvertently changed inside the function, compiler would issue an error.</li>

</ul>

<h5><span class="font-code">Author.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></td>
<td>
<pre>
<span class="color-comment">/* Implementation for the Author class (Author.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Author.h&quot;
using namespace std;
 
<span class="color-comment">// Constructor, with input validation</span>
Author::Author(<span class="color-new">const string &amp; name, const string &amp; email</span>, char gender) : name(name) {
   setEmail(email); <span class="color-comment"> // Call setter to check for valid email</span>
   if (gender == 'm' || gender == 'f') {
      this-&gt;gender = gender;
   } else {
      cout &lt;&lt; &quot;Invalid gender! Set to 'u' (unknown).&quot; &lt;&lt; endl;
      this-&gt;gender = 'u';
   }
}
 
string Author::getName() const {
   return name;
}
 
string Author::getEmail() const {
   return email;
}
 
void Author::setEmail(<span class="color-new">const string &amp; email</span>) {
  <span class="color-comment"> // Check for valid email. Assume that a valid email contains</span>
  <span class="color-comment"> //  a '@' that is not the first nor last character.</span>
   size_t atIndex = email.find('@');
   if (atIndex != string::npos &amp;&amp; atIndex != 0 &amp;&amp; atIndex != email.length()-1) {
      this-&gt;email = email;
   } else {
      cout &lt;&lt; &quot;Invalid email! Set to empty string.&quot; &lt;&lt; endl;
      this-&gt;email = &quot;&quot;;
   }
}
 
char Author::getGender() const {
   return gender;
}
 
<span class="color-comment">// print in the format &quot;name (gender) at email&quot;</span>
void Author::print() const {
   cout &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; gender &lt;&lt; &quot;) at &quot; &lt;&lt; email &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li><span class="line-heading-code-new">Author::Author(<strong>const string &amp; name</strong>, <strong>const string &amp; email</strong>, char gender) { ...... }</span><br />
In the constructor, the <code>string</code> objects are passed by reference. This improves the performance as it eliminates the need of creating a temporary (clone) object. The constructor then invokes the <em>copy constructor</em> of the <code>string</code> class to memberwise copy the arguments into its data members <code>name</code> and <code>email</code>.<br />
We make the parameters <code>const</code> to prevent them from modifying inside the function (with side effect to the original copies).</li>

</ul>

<h5><span class="font-code">Book.h</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td>
<td>
<pre>
<span class="color-comment">/* Header for the class Book (Book.h) */</span>
#ifndef BOOK_H
#define BOOK_H
 
#include &lt;string&gt;
#include &quot;Author.h&quot;  <span class="color-comment"> // Use the Author class</span>
using namespace std;
 
class Book {
private:
   <span class="color-new">string name;</span>
   <span class="color-new">Author author;</span>
   double price;
   int qtyInStock;
 
public:
   Book(<span class="color-new">const string &amp; name</span>, <span class="color-new">const Author &amp;</span> author, double price, int qtyInStock = 0);
   <span class="color-new">string</span> getName() const;
   <span class="color-new">Author</span> getAuthor() const;
   double getPrice() const;
   void setPrice(double price);
   int getQtyInStock() const;
   void setQtyInStock(int qtyInStock);
   void print() const;
   <span class="color-new">string</span> getAuthorName() const;
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li><span class="line-heading-code-new">Book(<strong>const string &amp; name</strong>, <strong>const Author &amp; author</strong>, double price, int qtyInStock = 0);</span><br /> 
  <code>string</code> and <code>Author</code> objects <code></code>are passed into the constructor via reference. This improves performance as it eliminates the creation of a temporary clone copy in pass-by-value. The parameters are marked <code>const</code> as we do not intend to modify them inside the function (with side effect to the original copies).</li>

<li><span class="line-heading-code-new"><strong>Author </strong>getAuthor() const;</span><br />
The getter returns a <em>copy </em>of the data member <code>author</code><code></code>.</li>
</ul>

<h5><span class="font-code">Book.cpp</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Implementation for the class Book (Book.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Book.h&quot;
using namespace std;
 
<span class="color-comment">// Constructor, with member initializer list to initialize the</span>
<span class="color-comment">//  component Author instance</span>
Book::Book(<span class="color-new">const string &amp; name</span>, <span class="color-new">const Author &amp; author</span>, double price, int qtyInStock)
      : <span class="color-new">name(name), author(author)</span> {<span class="color-comment"> // Init object reference in member initializer list</span>
  <span class="color-comment"> // Call setters to validate price and qtyInStock</span>
   setPrice(price);
   setQtyInStock(qtyInStock);
}
 
<span class="color-new">string Book::getName() const {
   return name;
}
 
Author Book::getAuthor() {
   return author;
}</span>
 
double Book::getPrice() const {
   return price;
}
 
<span class="color-comment">// Validate price, which shall be positive</span>
void Book::setPrice(double price) {
   if (price &gt; 0) {
      this-&gt;price = price;
   } else {
      cout &lt;&lt; &quot;price should be positive! Set to 0&quot; &lt;&lt; endl;
      this-&gt;price = 0;
   }
}
 
int Book::getQtyInStock() const {
   return qtyInStock;
}
 
<span class="color-comment">// Validate qtyInStock, which cannot be negative</span>
void Book::setQtyInStock(int qtyInStock) {
   if (qtyInStock &gt;= 0) {
      this-&gt;qtyInStock = qtyInStock;
   } else {
      cout &lt;&lt; &quot;qtyInStock cannnot be negative! Set to 0&quot; &lt;&lt; endl;
      this-&gt;qtyInStock = 0;
   }
}
 
<span class="color-comment">// print in the format &quot;&quot;Book-name&quot; by author-name (gender) at email&quot;</span>
void Book::print() const {
   cout &lt;&lt; &quot;'&quot; &lt;&lt; name &lt;&lt; &quot;' by &quot;;
   author.print();
}
 
<span class="color-comment">// Return the author' name for this Book</span>
string Book::getAuthorName() const {
   return author.getName();  <span class="color-comment"> // invoke the getName() on instance author</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<ul>
<li><span class="line-heading-code-new">Book::Book(<strong>const string &amp; name</strong>, <strong>Author &amp; author</strong>, double price, int qtyInStock)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <strong>name(name)</strong>, <strong>author(author)</strong> { ...... }<br />
</span><code>name(name)</code> and <code>author(author)</code> invoke the default copy constructors to construct new instances of <code>string</code> and <code>Author</code> by memberwise copy the parameters.</li>

<li><span class="line-heading-code-new"><strong>Author </strong>Book::getAuthor() { return <strong>author</strong>; }</span><br /> 
A copy of the data member <code>author</code> is returned to the caller. <br />
You should avoid returning a reference of a private data member to the caller (e.g., <code>Author &amp; Book::getAuthro() { return author; }</code>), as the caller can change the private data member via the reference, which breaks the concept of &quot;information hiding and encapsulation&quot;.</li>
</ul>

<h5>Test Driver - <span class="font-code">TestBook.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Driver for the Book class (TestBook.cpp) */</span>
#include &lt;iostream&gt;
#include &quot;Book.h&quot;
using namespace std;
 
int main() {
  <span class="color-comment"> // Declare and construct an instance of Author</span>
   Author peter(&quot;Peter Jones&quot;, &quot;peter@somewhere.com&quot;, 'm');
   peter.print(); <span class="color-comment"> // Peter Jones (m) at peter@somewhere.com</span>
 
  <span class="color-comment"> // Declare and construct an instance of Book</span>
   Book cppDummy(&quot;C++ for Dummies&quot;, peter, 19.99);
   cppDummy.print();
     <span class="color-comment"> // 'C++ for Dummies' by Peter Jones (m) at peter@somewhere.com</span>
 
   peter.setEmail(&quot;peter@xyz.com&quot;);
   peter.print();  <span class="color-comment"> // Peter Jones (m) at peter@xyz.com</span>
   cppDummy.print();
     <span class="color-comment"> // 'C++ for Dummies' by Peter Jones (m) at peter@somewhere.com</span>
 
   cppDummy.getAuthor().setEmail(&quot;peter@abc.com&quot;);
   cppDummy.print();
     <span class="color-comment"> // 'C++ for Dummies' by Peter Jones (m) at peter@somewhere.com</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In the above test program, an instance of <code>Author</code> called <code>peter</code> is constructed (in Line 8). This instance is passed by reference into <code>Book</code>'s constructor (Line 12) to create the <code>Book</code>'s instance <code>cppDummy</code>.</p>

<h5>Summary</h5>

<p>All the codes in this version of example (using references) is exactly the same as the previous version (without using references), except that the object function parameters are marked with &quot;<code>const <em>classname</em> &amp;</code>&quot; (e.g., <code>const string &amp;</code>, <code>const Author &amp;</code>). This eliminates the creation of temporary clone object as in the pass-by-value, which improves the performance. Take note that the constructor actually invokes the copy constructor to make a copy for its data member, instead of referencing the copy provided by the caller.</p>

<a class="references" href="../howto/References.html#cpp">Link to &quot;C++ References &amp; Resources&quot;</a>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: GCC (G++) 4.6.2<br />
Last modified: May, 2013</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->

</body>
</html>
