<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>C++ Basics - C++ Programming Tutorial</title>

<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>C++ Programming Language</h1>
<h2>Basics</h2>
</div>

<div id="content-main">

<p>This chapter explains the features, technical details and syntaxes of the C++ programming language. I assume that you could write some simple programs. Otherwise, read &quot;<a href="cp0_Introduction.html">Introduction To C++ Programming for Novices and First-time Programmers</a>&quot;.</p>

<p>To be a proficient programmer, you need to master two things: (1) the syntax of the programming language, and (2) the core libraries (i.e., <acronym title="Application Programmer Interface">API</acronym>) associated with the language.</p>

<h3>Introduction to C++</h3>

<h5>C++ Standards</h5>

<p>C++ is standardized as ISO/IEC 14882. Currently, there are two versions:</p>

<ol>
<li>C++98 (ISO/IEC 14882:1998): 1st standard version of C++.</li>
<li>C++03 (ISO/IEC 14882:2003): minor &quot;bug-fix&quot; to C++98 with no change to the language. Commonly refer to as C++98/C++03 or First C++ standard.</li>
<li>C++11 (ISO/IEC 14882:2011): 2nd standard version of C++. Formerly called C++0x, as it was expected to finalize in 200x. It adds some new features to the language; more significantly, it greatly extends the C++ standard library and standard template library (STL).</li>
</ol>

<h5>C++ Features</h5>

<ol>
<li><em>C++ is C</em>. C++ supports (almost) all the features of C. Like C, C++ allows programmers to manage the memory directly, so as to develop efficient programs.</li>
<li><em>C++ is OO</em>. C++ enhances  the procedural-oriented C language with the object-oriented extension. The OO extension facilitates design, reuse and maintenance for complex software.</li>
<li><em>Template C++</em>. C++ introduces generic programming, via the so-called template. You can apply the same algorithm to different data types.</li>
<li><em>STL</em>. C++ provides a huge set of reusable standard libraries, in particular, the Standard Template Library (STL).</li>
</ol>

<h5>C++ Strength and Pitfall</h5>

<p>C++ is a powerful language for high-performance applications, including writing operating systems and their subsystems, games and animation. C++ is also a complex and difficult programming language, which is really not meant for dummies. For example, to effectively use the C++ Standard Template Library (STL), you need to understand these difficult concepts: pointers, references, operator overloading and template, on top of the object-oriented programming concepts such as classes and objects, inheritance and polymorphism; and the traditional constructs such as decision and loop. C++ is performance centric. The C++ compiler does not issue warning/error message for many obvious programming mistakes, undefined and unspecified behaviors, such as array index out of range, using an uninitialized variable, etc, due to the focus on performance and efficiency rather than the ease of use - it assumes that those who choose to program in C++ are not dummies.</p>

<h3>Basic Syntaxes</h3>

<h4>Revision</h4>

<p>Below is a simple C++ program that illustrates the important programming constructs (<em>sequential flow</em>, <em>while-loop</em>, and <em>if-else</em>) and input/output. Read &quot;<a href="cp0_Introduction.html">Introduction To C++ Programming for Novices and First-time Programmers</a>&quot; if you need help in understanding this program.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Sum the odd and even numbers, respectively, from 1 to a given upperbound.
 * Also compute the absolute difference.
 * (SumOddEven.cpp)
 */</span>
#include &lt;iostream&gt;   <span class="color-comment">// Needed to use IO functions</span>
using namespace std;
 
int main() {
   int sumOdd  = 0;<span class="color-comment"> // For accumulating odd numbers, init to 0</span>
   int sumEven = 0;<span class="color-comment"> // For accumulating even numbers, init to 0</span>
   int upperbound; <span class="color-comment"> // Sum from 1 to this upperbound</span>
   int absDiff;    <span class="color-comment"> // The absolute difference between the two sums</span>
 
  <span class="color-comment"> // Prompt user for an upperbound</span>
   cout &lt;&lt; &quot;Enter the upperbound: &quot;;
   cin &gt;&gt; upperbound;
 
  <span class="color-comment"> // Use a while-loop to repeatedly add 1, 2, 3,..., to the upperbound</span>
   int number = 1;
   while (number &lt;= upperbound) {
      if (number % 2 == 0) { <span class="color-comment"> // Even number</span>
         sumEven += number;  <span class="color-comment"> // Add number into sumEven</span>
      } else {               <span class="color-comment"> // Odd number</span>
         sumOdd += number;   <span class="color-comment"> // Add number into sumOdd</span>
      }
      ++number;<span class="color-comment"> // increment number by 1</span>
   }
 
  <span class="color-comment"> // Compute the absolute difference between the two sums</span>
   if (sumOdd &gt; sumEven) {
      absDiff = sumOdd - sumEven;
   } else {
      absDiff = sumEven - sumOdd;
   }
 
  <span class="color-comment"> // Print the results</span>
   cout &lt;&lt; &quot;The sum of odd numbers is &quot; &lt;&lt; sumOdd &lt;&lt; endl;
   cout &lt;&lt; &quot;The sum of even numbers is &quot; &lt;&lt; sumEven &lt;&lt; endl;
   cout &lt;&lt; &quot;The absolute difference is &quot; &lt;&lt; absDiff &lt;&lt; endl;
 
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Enter the upperbound: <strong>1000</strong>
The sum of odd numbers is 250000
The sum of even numbers is 250500
The absolute difference is 500</pre>

<h5>Program Notes</h5>

<p><span class="line-heading-code-new">using namespace std;</span><br />
The names <code>cout</code> and <code>endl</code> belong to the <code>std</code> namespace. They can be referenced via <em>fully qualified name</em> <code>std::cout</code> and <code>std::endl</code>, or simply as <code>cout</code> and <code>endl</code> with a &quot;<code>using namespace std;&quot;</code> statement. For simplicity, I shall use the latter approach in this section. I will discuss the significance later.</p>

<p><span class="line-heading-code-new">return 0;</span><br />
The return value of 0 indicates normal termination; while non-zero (typically 1) indicates abnormal termination. C++ compiler will automatically 

insert a &quot;<code>return 0;</code>&quot; at the end of the the <code>main()</code> function, thus, it statement can be omitted.</p>
<p>Instead of using numeric value of zero and non-zero, you can also use <code>EXIT_SUCESS</code> or <code>EXIT_FAILURE</code>, which is defined in the <code>cstdlib</code> header (i.e., you need to &quot;<code>#include &lt;cstdlib&gt;</code>&quot;.</p>

<h4>Comments</h4>

<p>Comments are used to document and explain your codes and program logic.  Comments are not programming statements and are <em>ignored</em> by the compiler, but they VERY IMPORTANT for providing documentation and explanation for others to understand your program (and also for yourself three days later).</p>

<p>There are two kinds of comments in C/C++:</p>

<ol>
<li><em>Multi-line Comment</em>: begins with a <code>/*</code> and ends with a <code>*/</code>, and can span several lines.</li>

<li><em>End-of-line Comment</em>: begins with <code>//</code> and lasts till the end of the current line.</li>
</ol>

<p>You should use comments <em>liberally</em> to explain and document your codes.  During program development, instead of deleting a chunk of statements permanently, you could <em>comment-out</em> these statements so that you could get them back later, if needed.</p>

<h4>Statements and Blocks</h4>

<p><span class="line-heading">Statement</span>: A programming <em>statement</em> is the smallest independent unit in a program, just like a sentence in the English language. It performs <em>a piece of programming action</em>. A programming statement must be terminated by a semi-colon (<code>;</code>), just like an English sentence ends with a period. (Why not ends with a period like an english sentence? This is because period crashes with decimal point - it is hard for the dumb computer to differentiate between period and decimal point!)</p>
<p>For examples,</p>

<pre class="color-example">
<span class="color-comment">// Each of the following lines is a programming statement, which ends with a semi-colon (;)</span>
int number1 = 10;
int number2, number3 = 99;
int product;
product = number1 * number2 * number3;
cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;</pre>

<p><span class="line-heading">Block</span>: A <em>block</em> (or a <em>compound statement</em>) is a group of  statements surrounded by braces <code>{ }</code>. All the statements inside the block is treated as one unit. Blocks are used as the <em>body</em> in constructs like function, if-else and loop, which may contain multiple statements but are treated as one unit. There is no need to put a semi-colon after the closing brace to end a complex statement. Empty block (without any statement) is permitted. For examples,</p>

<pre class="color-example">
<span class="color-comment">// Each of the followings is a &quot;complex&quot; statement comprising one or more blocks of statements.
// No terminating semi-colon needed after the closing brace to end the &quot;complex&quot; statement.
// Take note that a &quot;complex&quot; statement is usually written over a few lines for readability.</span>
if (mark &gt;= 50) {
   cout &lt;&lt; &quot;PASS&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Well Done!&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Keep it Up!&quot; &lt;&lt; endl;
}
 
if (number == 88) {
   cout &lt;&lt; &quot;Got it&quot; &lt;&lt; endl; 
} else { 
   cout &lt;&lt; &quot;Try Again&quot; &lt;&lt; endl; 
}
 
i = 1;
while (i &lt; 8) {
   cout &lt;&lt; i &lt;&lt; endl;
   ++i; 
}
 
int main() {
   ...<em>statements...</em> 
}</pre>


<h4>White Spaces and Formatting Source Codes</h4>

<p><span class="line-heading">White Spaces</span>: <em>Blank</em>, <em>tab</em> and <em>new-line</em> are collectively called <em>white spaces</em>. C++, like most of the computing languages, ignores <em>extra</em> white spaces.  That is, multiple contiguous white spaces are treated as a single white space. </p>

<p>You need to use a white space to separate two keywords or tokens, e.g.,</p>
<pre class="color-example">
int sum=0;          <span class="color-comment">// Need a white space between int and sum</span>
double average;     <span class="color-comment">// Need a white space between double and average</span>
average=sum/100.0;</pre>
<p>Additional white spaces and extra lines are, however, ignored, e.g.,</p>
<pre class="color-example">
<span class="color-comment">// same as above</span>
int  sum  
   =  0 ;

   double  average  ;
average = sum / 100.0;</pre>

<p><span class="line-heading">Formatting Source Codes</span>: As mentioned, extra white spaces are ignored and have no computational significance. However, proper indentation (with tabs and  blanks) and extra empty lines greatly improves the readability of the program, which is extremely important for others (and yourself three days later) to understand your programs. For example, the following hello-world works, but can you understand the program?</p>

<pre class="color-example">
<span class="color-comment"></span>#include &lt;iostream&gt;
using namespace std;int main(){cout&lt;&lt;&quot;Hello, world!&quot;&lt;&lt;endl;return 0;}</pre>

<p><span class="line-heading">Braces</span>: Place the beginning brace at the end of the line, and align the ending brace with the start of the statement.</p>

<p><span class="line-heading">Indentation</span>: Indent the body of a block by an extra 3 (or 4 spaces), according to its <em>level</em>.</p>

<p>For example,</p>

<pre class="color-example">
<span class="color-comment">/*
 * Recommended Programming style.
 */</span>
#include &lt;iostream&gt;
using namespace std;
                           <span class="color-comment">// blank line to separate sections of codes</span>
int main() <strong>{</strong>  <span class="color-comment">// Place the beginning brace at the end of the current line</span>
   <span class="color-comment">// Indent the body by an extra 3 or 4 spaces for each level</span>
 
   int mark = 70;
   if (mark &gt;= 50) <strong>{</strong>               <span class="color-comment">// in level-1 block, indent once</span>
      cout &lt;&lt; &quot;You Pass!&quot; &lt;&lt; endl; <span class="color-comment">// in level-2 block, indent twice</span>
   <strong>}</strong> else <strong>{</strong>
      cout &lt;&lt; &quot;You Fail!&quot; &lt;&lt; endl;
   <strong>}</strong>
 
   return 0;
<strong>}</strong>   <span class="color-comment">// ending brace aligned with the start of the statement</span></pre>

<p>Most IDEs (such as CodeBlocks, Eclipse and NetBeans) have a command to <em>re-format</em> your source code automatically.</p>

<p>Note: Traditional C-style formatting places the beginning and ending braces on the same column. For example,</p>

<pre class="color-example">
<span class="color-comment">/*
 * Traditional C-style.
 */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main()
<strong>{</strong>
   if (mark &gt;= 50)                 <span class="color-comment">// in level-1 block, indent once</span>
   <strong>{</strong>
      cout &lt;&lt; &quot;You Pass!&quot; &lt;&lt; endl; <span class="color-comment">// in level-2 block, indent twice</span>
   <strong>}</strong>
   else
   <strong>{</strong>
      cout &lt;&lt; &quot;You Fail!&quot; &lt;&lt; endl;
   <strong>}</strong>
<strong>}</strong></pre>

<h4>Preprocessor Directives</h4>

<p>C++ source code is <em>pre-processed</em> before it is <em>compiled</em> into object code (as illustrated).</p>

<img class="image-center" src="images/CompilationProcess.png" alt="CompilationProcess.png" />

<p>A <em>preprocessor directive</em>, which begins with a <code>#</code> sign (such as <code>#include</code>, <code>#define</code>), tells the preprocessor to perform a certain action (such as including a header file, or performing text replacement), before compiling the source code into object code. Preprocessor directives  are not programming statements, and therefore should NOT be terminated with a semi-colon. For example,</p>

<pre class="color-example">
#include &lt;iostream&gt;  <span class="color-comment">// To include the IO library header</span>
#include &lt;cmath&gt;     <span class="color-comment">// To include the Math library header</span>
#define PI 3.14159265    <span class="color-comment">// To substitute the term PI with 3.14159265 in this file</span>
   <span class="color-comment"></span><span class="color-new">// DO NOT terminate preprocessor directive with a semi-colon</span></pre>
   
<p>In almost all of the C++ programs, we use <code>#include &lt;iostream&gt;</code> to include the input/output stream library header into our program, so as to use the IO library function to carry out input/output operations (such as <code>cin</code> and <code>cout</code>).</p>

<p>More on preprocessor directives later.</p>

<h3>Variables and Types</h3>

<h4>Variables</h4>

<p>Computer programs manipulate (or process) data. A <em>variable</em> is used to <em>store a piece of data</em> for processing. It is called <em>variable</em> because you can change the value stored.</p>

<p>More precisely, a <em>variable</em> is a <em>named</em> storage location, that stores a <em>value</em> of a particular data <em>type</em>. In other words, a <em>variable</em> has a <em>name</em>, a <em>type</em> and stores a <em>value</em>.</p>

<ul>
<li>A variable has a <em>name</em> (or <em>identifier</em>), e.g., <code>radius</code>, <code>area</code>, <code>age</code>, <code>height</code>. The name is needed to uniquely identify each variable, so as to assign a value to the variable (e.g., <code>radius=1.2</code>), and retrieve the value stored (e.g., <code>area = radius*radius*3.1416</code>).</li>

<li>A variable has a <em>type</em>. Examples of <em>type</em> are,

<ul>
<li><code>int</code>: for integers (whole numbers) such as <code>123</code> and <code>-456</code>;</li>

<li><code>double</code>: for floating-point or real numbers such as <code>3.1416</code>, <code>-55.66</code>, having a decimal point and fractional part.</li>
</ul></li>

<li>A variable can store a <em>value</em> of that particular <em>type</em>. It is important to take note that a variable in most programming languages is associated with a type, and can only store value of the particular type. For example, a <code>int</code> variable can store an integer value such as <code>123</code>, but NOT real number such as <code>12.34</code>, nor texts such as <code>&quot;Hello&quot;</code>.</li>

<li>The concept of <em>type</em> was introduced into the early programming languages to simplify interpretation of data made up of 0s and 1s. The type determines the size and layout of the data, the range of its values, and the set of operations that can be applied.</li>
</ul>

<p>The following diagram illustrates two types of variables: <code>int</code> and <code>double</code>. An <code>int</code> variable stores an integer (whole number). A <code>double</code> variable stores a real number.</p>
<img class="image-center" src="images/BasicsVariable.png" alt="variable" />

<h4>Identifiers</h4>

<p>An <em>identifier</em> is needed to <em>name</em> a variable (or any other entity such as a function or a class). C++ imposes the following <em>rules on identifiers</em>:</p>

<ul>
<li>An identifier is a sequence of characters, of up to a certain length (compiler-dependent, typically 255 characters), comprising uppercase and lowercase letters <code>(a-z, A-Z)</code>, digits <code>(0-9)</code>, and underscore <code>&quot;_&quot;</code>.</li>

<li>White space (blank, tab, new-line) and other special characters (such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,  <code>@</code>, <code>&amp;</code>, commas, etc.) are not allowed.</li>

<li>An identifier must begin with a letter or underscore. It cannot begin with a digit. Identifiers beginning with an underscore are typically reserved for system use.</li>

<li>An identifier cannot be a reserved keyword or a reserved literal (e.g.,<code>int</code>, <code>double</code>, <code>if</code>, <code>else</code>, <code>for</code>).</li>

<li>Identifiers are case-sensitive. A <code>rose</code> is NOT a <code>Rose</code>, and is NOT a <code>ROSE</code>.</li>
</ul>

<p><span class="line-heading color-error">Caution</span>: Programmers don't use <em>blank</em> character in names. It is either not supported, or will pose you more challenges.</p>

<h5>Variable Naming Convention</h5>

<p>A variable name is a noun, or a noun phrase made up of several  words. The first word is in lowercase, while the remaining words are initial-capitalized, with no spaces between words. For example, <code>thefontSize</code>, <code>roomNumber</code>, <code>xMax</code>, <code>yMin</code>,  <code>xTopLeft</code> and <code>thisIsAVeryLongVariableName</code>. This convention is also known as <em>camel-case</em>.</p>

<h5>Recommendations</h5>

<ol>
<li>It is important to choose a name that is <em>self-descriptive</em> and closely reflects the meaning of the variable, e.g., <code>numberOfStudents</code> or <code>numStudents</code>.</li>

<li>Do not use meaningless names like <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>i</code>, <code>j</code>, <code>k</code>, <code>i1</code>, <code>j99</code>.</li>

<li>Avoid single-alphabet names, which is easier to type but often meaningless, unless they are common names like <code>x</code>, <code>y</code>, <code>z</code> for coordinates, <code>i</code> for index.</li>

<li>It is perfectly okay to use long names of says 30 characters to make sure that the name accurately reflects its meaning!</li>

<li>Use singular and plural nouns  prudently to differentiate between singular and plural variables.  For example, you may use the variable <code>row</code> to refer to a single row number and the variable <code>rows</code>  to refer to many rows (such as an array of rows - to be discussed later).</li>
</ol>

<h4>Variable Declaration</h4>

<p>To use a variable in your program, you need to first &quot;introduce&quot; it by <em>declaring</em> its <em>name</em> and <em>type</em>, in one of the following syntaxes:</p>

<table class="table-program">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>
<tr>
<td><pre class="color-syntax"><span class="color-comment">// Declare a variable of a specified type</span>
<em>type identifier</em><strong>;</strong>
<span class="color-comment">// Declare multiple variables of the same type, separated by commas</span>
<em>type identifier-1</em><strong>,</strong> <em>identifier-2</em><strong>,</strong> ...<strong>,</strong> <em>identifier-n</em><strong>;</strong>
<span class="color-comment">// Declare a variable and assign an initial value</span>
<em>type identifier</em> <strong>=</strong> <em>value</em><strong>;</strong>
<span class="color-comment">// Declare multiple variables with initial values</span>
<em>type identifier-1</em> <strong>=</strong> <em>value-1</em><strong>,</strong> ...<strong>,</strong> <em>identifier-n</em> <strong>=</strong> <em>value-n</em><strong>;</strong></pre>
</td>

<td>
<pre class="color-example">&nbsp;
int option;
&nbsp;
double sum, difference, product, quotient;
&nbsp;
int magicNumber = 88;
&nbsp;
double sum = 0.0, product = 1.0;</pre>
</td>
</tr>
</table>

<p>Example,</p>

<pre class="color-example">
int mark1;           <span class="color-comment">// Declare an int variable called mark1</span>
mark1 = 76;          <span class="color-comment">// Use mark1</span>
int mark2;           <span class="color-comment">// Declare int variable mark2</span>
mark2 = mark1 + 10;  <span class="color-comment">// Use mark2 and mark1</span>
double average;      <span class="color-comment">// Declare double variable average</span>
average = (mark1 + mark2) / 2.0;   <span class="color-comment">// Use average, mark1 and mark2</span>
<span class="color-error">int mark1;</span>           <span class="color-comment">// Error: Declare twice</span>
<span class="color-error">mark2 = &quot;Hello&quot;;</span>     <span class="color-comment">// Error: Assign value of a different type</span></pre>

<p>Take note that:</p>

<ul>
<li>In C++, you need to declare the name of a variable before it can be used.</li>

<li>C++ is a &quot;strongly-type&quot; language. A variable takes on a  type. Once the <em>type</em> of a variable is declared, it can only store a value belonging to this particular type. For example, an <code>int</code> variable can hold only integer such as <code>123</code>, and NOT floating-point number such as <code>-2.17</code> or text string such as <code>&quot;Hello&quot;</code>. The concept of <em>type</em> was introduced into the early programming languages to simplify interpretation of data made up of 0s and 1s. Knowing the <em>type</em> of a piece of data greatly simplifies its interpretation and processing.</li>

<li>Each variable can only be declared once.</li>

<li>In C++, you can declare a variable anywhere inside the program, as long as it is declared before used. (In C prior to C99, all the variables must be declared at the beginning of functions.) It is recommended that your declare a variable just before it is first used.</li>

<li> The type of a variable cannot be changed inside the program.</li>
</ul>

<h5><span class="color-error">CAUTION</span>: Uninitialized Variables</h5>

<p>When a variable is declared, it contains garbage until you assign an initial value. It is important to take note that C/C++ does not issue any warning/error if you use a variable before initialize it - which certainly leads to some unexpected results. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9</pre>
</td>
<td>
<pre>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int number;            <span class="color-comment"> // Declared but not initialized</span>
   cout &lt;&lt; number &lt;&lt; endl;<span class="color-comment"> // Used before initialized
                           // No warning/error, BUT unexpected result</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Constants (<span class="font-code">const</span>)</h4>

<p>Constants are <em>non-modifiable</em> variables, declared with keyword <code>const</code>. Their values cannot be changed during program execution. Also, <code>const</code> must be initialized during declaration. For examples:</p>
<pre class="color-example">
<strong>const</strong> double PI = 3.1415926;  <span class="color-comment">// Need to initialize</span></pre>

<p><span class="line-heading">Constant Naming Convention:</span> Use uppercase words, joined with underscore. For example, <code>MIN_VALUE</code>, <code>MAX_SIZE</code>.</p>

<h4>Expressions</h4>

<p>An <em>expression</em> is a combination of <em>operators</em> (such as addition <code>'+'</code>, subtraction <code>'-'</code>, multiplication <code>'*'</code>, division <code>'/'</code>) and <em>operands</em> (variables or literal values), that can be <em>evaluated to yield a single value of a certain type</em>. For example,</p>

<pre class="color-example">
<span class="color-comment"></span>1 + 2 * 3           <span class="color-comment">// give int 7</span>
 
int sum, number;
sum + number        <span class="color-comment">// evaluated to an int value</span>
 
double principal, interestRate;
principal * (1 + interestRate)  <span class="color-comment">// evaluated to a double value</span></pre>

<h4>Assignment (<span class="font-code">=</span>)</h4>

<p>An <em>assignment statement</em>:</p>

<ol>
<li>assigns a literal value (of the RHS) to a variable (of the LHS); or</li>
<li>evaluates an expression (of the RHS) and assign the resultant value to a variable (of the LHS).</li>
</ol>

<p>The RHS shall be a value; and the LHS shall be a variable (or memory address).</p>

<p>The syntax for assignment statement is:</p>

<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
  </tr>
  <tr>
    <td><pre class="color-syntax"><span class="color-comment">// Assign the literal value (of the RHS) to the variable (of the LHS)</span>
<em>variable</em> <strong>=</strong> <em>literal-value</em><strong>;</strong>
<span class="color-comment">// Evaluate the expression (RHS) and assign the result to the variable (LHS)</span>
<em>variable</em> <strong>=</strong> <em>expression</em><strong>;</strong></pre></td>
    <td><pre class="color-example">&nbsp;
number = 88;
&nbsp;
sum = sum + number;</pre></td>
  </tr>
</table>
<p>The assignment statement should be interpreted this way: The <em>expression</em> on the right-hand-side (RHS) is first evaluated to produce a resultant value (called <em>rvalue</em> or right-value). The <em>rvalue</em> is then assigned to the variable on the left-hand-side (LHS) (or <em>lvalue</em>, which is a location that can hold a <em>rvalue</em>). Take note that you have to first evaluate the RHS, before assigning the resultant value to the LHS. For examples,</p>
<pre class="color-example">
number = 8;           <span class="color-comment">// Assign literal value of 8 to the variable number</span>
number = number + 1;  <span class="color-comment">// Evaluate the expression of number + 1,
                      //  and assign the resultant value back to the variable number</span></pre>
<p>The symbol &quot;<code>=</code>&quot; is known as the <em>assignment operator</em>. The meaning of &quot;<code>=</code>&quot; in programming is different from Mathematics. It denotes <em>assignment</em> instead of <em>equality</em>. The RHS is a literal value; or an expression that evaluates to a value; while the LHS must be a variable. Note that <code>x = x + 1</code> is valid (and often used) in programming. It evaluates <code>x + 1</code> and assign the resultant value to the variable <code>x</code>. <code>x = x + 1</code> illegal in Mathematics. While <code>x + y = 1</code> is allowed in Mathematics, it is invalid in programming (because the LHS of an assignment statement must be a variable). Some programming languages use symbol &quot;<code>:=</code>&quot;, &quot;&larr;&quot;, &quot;-&gt;&quot;, or &quot;&rarr;&quot; as the assignment operator to avoid confusion with equality.</p>

<h4>Fundamental Types</h4>

<p><span class="line-heading">Integers:</span> C++ supports these integer types: <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> (in C++11) in a non-decreasing order of size. The actual size depends on the implementation. The integers (except <code>char</code>) are <em>signed</em> number (which can hold zero, positive and negative numbers). You could use the keyword <code>unsigned [char|short|int|long|long long]</code> to declare an <em>unsigned</em> integers (which can hold zero and positive numbers). There are a total 10 types of integers - <code>signed|unsigned</code> combined with <code>char|short|int|long|long long</code>.</p>

<p><span class="line-heading">Characters:</span> Characters (e.g., <code>'a'</code>, <code>'Z'</code>, <code>'0'</code>, <code>'9'</code>) are encoded in ASCII into integers, and kept in type <code>char</code>. For example, character <code>'0'</code> is <code>48</code> (decimal) or <code>30H</code> (hexadecimal); character <code>'A'</code> is <code>65</code> (decimal) or <code>41H</code> (hexadecimal); character <code>'a'</code> is <code>97</code> (decimal) or <code>61H</code> (hexadecimal). Take note that the type <code>char</code> can be interpreted as character in ASCII code, or an 8-bit integer. Unlike <code>int</code> or <code>long</code>, which is <code>signed</code>, <code>char</code> could be <code>signed</code> or <code>unsigned</code>, depending on the implementation. You can use <code>signed char</code> or <code>unsigned char</code> to explicitly declare <code>signed</code> or <code>unsigned char</code>.</p>

<p><span class="line-heading">Floating-point Numbers:</span> There are 3 floating point types: <code>float</code>, <code>double</code> and <code>long double</code>, for single, double and long double precision floating point numbers. <code>float</code> and <code>double</code> are represented as specified by IEEE 754 standard. A <code>float</code> can represent a number between <code>&plusmn;1.40239846&times;10^-45</code> and <code>&plusmn;3.40282347&times;10^38</code>, approximated. A <code>double</code> can represented a number between <code>&plusmn;4.94065645841246544&times;10^-324</code> and <code>&plusmn;1.79769313486231570&times;10^308</code>, approximated. Take note that not all real numbers can be represented by <code>float</code> and <code>double</code>, because there are infinite real numbers. Most of the values are approximated.</p>

<p><span class="line-heading">Boolean Numbers:</span> A special type called <code>bool</code> (for boolean), which takes a value of either <code>true</code> or <code>false</code>.</p>

<p>The table below shows the <em>typical</em> size, minimum, maximum for the primitive types. Again, take note that the sizes are implementation dependent.</p>

<table class="table-zebra">
  <thead>
  <tr>
    <th>Category</th>
    <th>Type</th>
    <th>Description</th>
    <th>Bytes<br />(Typical)</th>
    <th>Minimum<br />(Typical)</th>
    <th>Maximum<br />(Typical)</th>
  </tr>
  </thead>
  <tbody class="font-code"> 
  
  <tr>
    <td rowspan="11">Integers</td>
    <td>int<br />
      (or signed int)</td>
    <td class="font-normal">Signed integer (of at least 16 bits)</td>
    <td>4 (2)</td>
    <td>-2147483648</td>
    <td>2147483647</td>
  </tr>
  <tr class="tr-alt">
    <td>unsigned int</td>
    <td class="font-normal">Unsigned integer (of at least 16 bits)</td>
    <td>4 (2)</td>
    <td>0</td>
    <td>4294967295</td>
  </tr>
  <tr>
    <td>char</td>
    <td class="font-normal">Character <br />
      (can be either signed or unsigned depends on implementation)</td>
    <td>1</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr class="tr-alt">
    <td>signed char</td>
    <td class="font-normal">Character or signed tiny integer <br />
      (guarantee to be signed)</td>
    <td>1</td>
    <td>-128</td>
    <td>127</td>
  </tr>
  <tr>
    <td>unsigned char</td>
    <td class="font-normal">Character or unsigned tiny integer  <br />
      (guarantee to be unsigned)</td>
    <td>1</td>
    <td>0</td>
    <td>255</td>
  </tr>
  <tr class="tr-alt">
    <td>short <br />
      (or short int)<br />
      (or signed short)<br />
      (or signed short int)</td>
    <td class="font-normal">Short signed integer (of at least 16 bits)</td>
    <td>2</td>
    <td>-32768</td>
    <td>32767</td>
  </tr>
  <tr>
    <td>unsigned short<br />
      (or unsigned shot int)</td>
    <td class="font-normal">Unsigned short integer (of at least 16 bits)</td>
    <td>2</td>
    <td>0</td>
    <td>65535</td>
  </tr>
  <tr class="tr-alt">
    <td>long <br />
      (or long int)<br />
      (or signed long)<br />
      (or signed long int)</td>
    <td class="font-normal">Long signed integer (of at least 32 bits)</td>
    <td>4 (8)</td>
    <td>-2147483648</td>
    <td>2147483647</td>
  </tr>
  <tr>
    <td>unsigned long<br />
      (or unsigned long int)</td>
    <td class="font-normal">Unsigned long integer (of at least 32 bits)</td>
    <td>4 (8)</td>
    <td>0</td>
    <td class="font-normal">same as above</td>
  </tr>
  <tr class="tr-alt">
    <td>long long <br />
      (or long long int)<br />
      (or signed long long)<br />
      (or signed long long int) (C++11)</td>
    <td class="font-normal">Very long signed integer (of at least 64 bits)</td>
    <td>8</td>
    <td>-2<sup>63</sup></td>
    <td>2<sup>63</sup>-1</td>
  </tr>
  <tr>
    <td>unsigned long long<br />
      (or unsigned long long int) (C++11)</td>
    <td class="font-normal">Unsigned very long integer (of at least 64 bits)</td>
    <td>8</td>
    <td>0</td>
    <td>2<sup>64</sup>-1</td>
  </tr>
  <tr class="tr-alt">
    <td rowspan="3">Real Numbers</td>
    <td>float</td>
    <td class="font-normal">Floating-point number, &asymp;7 digits<br />
    (IEEE 754 single-precision floating point format)</td>
    <td>4</td>
    <td>3.4e38</td>
    <td>3.4e-38</td>
  </tr>
  <tr>
    <td>double</td>
    <td class="font-normal">Double precision floating-point number, &asymp;15 digits<br />
    (IEEE 754 double-precision floating point format)</td>
    <td>8</td>
    <td>1.7e308</td>
    <td>1.7e-308</td>
  </tr>
  <tr class="tr-alt">
    <td>long double</td>
    <td class="font-normal">Long double precision floating-point number, &asymp;19 digits<br />
    (IEEE 754 quadruple-precision floating point format)</td>
    <td>12 (8)</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Boolean<br />
      Numbers</td>
    <td>bool</td>
    <td class="font-normal">Boolean value of either <code>true</code> or <code>false</code> </td>
    <td>1</td>
    <td>false (0)</td>
    <td>true (1 or non-zero)</td>
  </tr>
  <tr class="tr-alt">
    <td>Wide <br />
      Characters</td>
    <td>wchar_t<br />
      char16_t (C++11)<br />
      char32_t (C++11)</td>
    <td class="font-normal">Wide (double-byte) character</td>
    <td>2 (4)</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  </tbody>
</table>

<p>In addition, many C++ library functions use a type called <code>size_t</code>, which is equivalent (<code>typedef</code>) to a <code>unsigned int</code>, meant for counting, size or length, with 0 and positive integers.</p>

<h5>*The <span class="font-code">sizeof</span> Operator</h5>

<p>C/C++ provides an unary <code>sizeof</code> operator to get the size of the operand (in bytes). The following program uses <code>sizeof</code> operator to print the size of the fundamental types.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Print Size of Fundamental Types (SizeofTypes.cpp).
 */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   cout &lt;&lt; &quot;sizeof(char) is &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(short) is &quot; &lt;&lt; sizeof(short) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(int) is &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(long) is &quot; &lt;&lt; sizeof(long) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(long long) is &quot; &lt;&lt; sizeof(long long) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(float) is &quot; &lt;&lt; sizeof(float) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(double) is &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(long double) is &quot; &lt;&lt; sizeof(long double) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;sizeof(bool) is &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
sizeof(char) is 1 bytes
sizeof(short) is 2 bytes
sizeof(int) is 4 bytes
sizeof(long) is 4 bytes
sizeof(long long) is 8 bytes
sizeof(float) is 4 bytes
sizeof(double) is 8 bytes
sizeof(long double) is 12 bytes
sizeof(bool) is 1 bytes</pre>

<p>The results may vary among different systems.</p>

<h5>*Header <span class="font-code">&lt;climits&gt;</span></h5>

<p>The <code>climits</code> header (ported to C++ from C's <code>limits.h</code>) contains information about limits of integer type. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test integer limits in &lt;climits&gt; header */</span>
#include &lt;iostream&gt;
#include &lt;climits&gt;  <span class="color-comment"> // integer limits</span>
using namespace std;
 
int main() {
   cout &lt;&lt; &quot;int max = &quot; &lt;&lt; INT_MAX &lt;&lt; endl;
   cout &lt;&lt; &quot;int min = &quot; &lt;&lt; INT_MIN &lt;&lt; endl;
   cout &lt;&lt; &quot;unsigned int max = &quot; &lt;&lt; UINT_MAX &lt;&lt; endl;
   cout &lt;&lt; &quot;long long max = &quot; &lt;&lt; LLONG_MAX &lt;&lt; endl;
   cout &lt;&lt; &quot;long long min = &quot; &lt;&lt; LLONG_MIN &lt;&lt; endl;
   cout &lt;&lt; &quot;unsigned long long max = &quot; &lt;&lt; ULLONG_MAX &lt;&lt; endl;
   cout &lt;&lt; &quot;Bits in char = &quot; &lt;&lt; CHAR_BIT &lt;&lt; endl;
   cout &lt;&lt; &quot;char max = &quot; &lt;&lt; CHAR_MAX &lt;&lt; endl;
   cout &lt;&lt; &quot;char min = &quot; &lt;&lt; CHAR_MIN &lt;&lt; endl;
   cout &lt;&lt; &quot;signed char max = &quot; &lt;&lt; SCHAR_MAX &lt;&lt; endl;
   cout &lt;&lt; &quot;signed char min = &quot; &lt;&lt; SCHAR_MIN &lt;&lt; endl;
   cout &lt;&lt; &quot;unsigned char max = &quot; &lt;&lt; UCHAR_MAX &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
int max = 2147483647
int min = -2147483648
unsigned int max = 4294967295
long long max = 9223372036854775807
long long min = -9223372036854775808
unsigned long long max = 18446744073709551615
Bits in char = 8
char max = 127
char min = -128
signed char max = 127
signed char min = -128
unsigned char max = 255</pre>

<p>Again, the outputs depend on the system.</p>

<p>The minimum of unsigned integer is always 0. The other constants are <code>SHRT_MAX</code>, <code>SHRT_MIN</code>, <code>USHRT_MAX</code>, <code>LONG_MIN</code>, <code>LONG_MAX</code>, <code>ULONG_MAX</code>. Try inspecting this header (search for <code>climits</code> under your compiler).</p>

<h5>*Header <span class="font-code">&lt;cfloat&gt;</span></h5>

<p>Similarly, the <code>cfloat</code> header (ported from C's <code>float.h</code>) contain information on limits for floating point numbers, such as minimum number of significant digits (<code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code> for <code>float</code>, <code>double</code> and <code>long double</code>), number of bits for mantissa (<code>FLT_MANT_DIG</code>, <code>DBL_MANT_DIG</code>, <code>LDBL_MANT_DIG</code>), maximum and minimum exponent values, etc. Try inspecting this header (search for <code>cfloat</code> under your compiler).</p>

<h5>*Header <span class="font-code">&lt;limits&gt;</span></h5>

<p>The <code>climits</code> and <code>cfloat</code> headers are ported over from C's <code>limit.h</code> and <code>float.h</code>. C++ added a new header called <code>limits</code>.</p>
<p>[TODO]</p>

<h5>Choosing Types</h5>

<p>As a programmer, you need to choose variables and decide on the type of the variables to be used in your programs. Most of the times, the decision is intuitive. For example, use an integer type for counting and whole number; a floating-point type for number with fractional part,<code> char</code> for a single character, and <code>boolean</code> for binary outcome.</p>

<h5>Rule of Thumb</h5>

<ul>
<li>Use <code>int</code> for integer and <code>double</code> for floating point numbers. Use <code>byte</code>, <code>short</code>, <code>long</code> and <code>float</code> only if you have a good reason to choose that specific precision.</li>

<li>Use <code>int</code> (or <code>unsigned int</code>) for <em>counting</em> and <em>indexing</em>, NOT floating-point type (<code>float</code> or <code>double</code>). This is because integer type are precise and more efficient in operations.</li>

<li>Use an integer type if possible. Use a floating-point type only if the number contains a fractional part.</li>
</ul>

<p>Read my article on &quot;<a href="../java/DataRepresentation.html">Data Representation</a>&quot; if you wish to understand how the numbers and characters are represented inside the computer memory. In brief,  It is important to take note that <code>char '1'</code> is different from <code>int 1</code>, <code>short 1</code>, <code>float 1.0</code>, <code>double 1.0</code>, and <code>String &quot;1&quot;</code>. They are represented differently in the computer memory, with different precision and interpretation. For example, <code>short 1</code> is <code>&quot;00000000 00000001&quot;</code>, <code>int 1</code> is <code>&quot;00000000 00000000 00000000 00000001&quot;</code>, <code>long long 1</code> is <code>&quot;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001&quot;</code>, <code>float 1.0</code> is <code>&quot;0 01111111 0000000 00000000 00000000&quot;</code>, <code>double 1.0</code> is <code>&quot;0 01111111111 0000 00000000 00000000 00000000 00000000 00000000 00000000&quot;</code>, <code>char '1'</code> is <code>&quot;00110001&quot;</code>.</p>

<p> There is a subtle difference between <code>int 0</code> and <code>double 0.0</code>.</p>

<p>Furthermore, you MUST know the type of a value before you can interpret a value. For example, this value <code>&quot;00000000 00000000 00000000 00000001&quot;</code> cannot be interpreted unless you know the type.</p>

<h5>*The <span class="font-code">typedef</span> Statement</h5>

<p>Typing &quot;<code>unsigned int</code>&quot; many time  can get annoying. The <code>typedef</code> statement can be used to create a new name for an existing type. For example, you can create a new type called &quot;<code>uint</code>&quot; for &quot;<code>unsigned int</code>&quot; as follow. You should place the <code>typedef</code> immediately after <code>#include</code>. Use <code>typedef</code> with care because it makes the program hard to read and understand.<br />
</p>

<pre class="color-example">
typedef unsigned int uint;</pre>

<p>Many C/C++ compilers define a type called <code>size_t</code>, which is a <code>typedef</code> of <code>unsigned int</code>.</p>
<pre class="color-example">
typedef unsigned int size_t;</pre>


<h4>Literals for Fundamental Types and String</h4>

<p>A <em>literal</em> is a <em>specific constant value</em>, such as <code>123</code>, <code>-456</code>, <code>3.14</code>, <code>'a'</code>, <code>&quot;Hello&quot;</code>, that can be assigned directly to a variable; or used  as part of an expression. They are called <em>literals</em> because they literally and explicitly identify their values.</p>

<h5>Integer Literals</h5>

<p>A whole number, such as <code>123</code> and <code>-456</code>, is treated as an <code>int</code>, by default. For example,</p>

<pre class="color-example">
int number = -123;
int sum = 4567;
<span class="color-error">int bigSum = 8234567890;</span>  <span class="color-comment">// ERROR: this value is outside the range of int</span></pre>
<p>An <code>int</code> literal may precede with a plus (<code>+</code>) or minus (<code>-</code>) sign, followed by digits. No commas or special symbols (e.g., <code>$</code> or space) is allowed (e.g., <code>1,234</code> and <code>$123</code> are invalid). No preceding <code>0</code> is allowed too (e.g., <code>007</code> is invalid).</p>
<p>Besides the default base 10 integers, you can use a prefix <code>'0'</code> (zero) to denote a value in octal, prefix <code>'0x'</code> for a value in hexadecimal, and prefix '<code>0b</code>' for binary value (in some compilers), e.g.,</p>

<pre class="color-example">
int number1 = 1234;       <span class="color-comment">// Decimal</span>
int number2 = 01234;      <span class="color-comment">// Octal 1234, Decimal 2322</span>
int number3 = 0x1abc;     <span class="color-comment">// hexadecimal 1ABC, decimal 15274</span>
int number4 = 0b10001001; <span class="color-comment">// binary (may not work in some compilers)</span></pre>

<p>A <code>long</code> literal is identified by a suffix <code>'L'</code> or <code>'l'</code> (avoid lowercase, which can be confused with the number one). A <code>long long int</code> is identified by a suffix <code>'LL'</code>. You can also use suffix <code>'U'</code> for <code>unsigned int</code>, <code>'UL'</code> for <code>unsigned long</code>, and <code>'ULL'</code> for <code>unsigned long long int</code>. For example,</p>

<pre class="color-example">
long number = 12345678L;     <span class="color-comment">// Suffix 'L' for long</span>
long sum = 123;              <span class="color-comment">// int 123 auto-casts to long 123L</span>
long long bigNumber = 987654321LL;  <span class="color-comment">// Need suffix 'LL' for long long int</span></pre>

<p>No suffix is needed for <code>short</code> literals. But you can only use integer values in the permitted range. For example,</p>

<pre class="color-example">
<span class="color-error">short smallNumber = 1234567890;</span>   <span class="color-comment">// ERROR: this value is outside the range of short.</span>
short midSizeNumber = -12345;</pre>

<h5>Floating-point Literals</h5>

<p>A number with a decimal point, such as <code>55.66</code> and <code>-33.44</code>, is treated as a <code>double</code>, by default. You can also express them in scientific notation, e.g., <code>1.2e3</code>, <code>-5.5E-6</code>, where <code>e</code> or <code>E</code> denotes the exponent in power of 10. You could precede the fractional part or exponent with a plus (<code>+</code>) or minus (<code>-</code>) sign. Exponent shall be an integer. There should be no space or other characters (e.g., space) in the number.</p>

<p>You MUST use a suffix of <code>'f'</code> or <code>'F'</code> for <code>float</code> literals, e.g., <code>-1.2345F</code>. For example,</p>

<pre class="color-example">
<span class="color-error">float average = 55.66;</span>      <span class="color-comment">// Error! RHS is a double. Need suffix 'f' for float.</span>
float average = 55.66f;</pre>

<p>Use suffix <code>'L'</code> (or <code>'l'</code>) for <code>long double</code>.</p>

<h5>Character Literals and Escape Sequences</h5>

<p>A printable <code>char</code> literal is written by enclosing the character with a pair of <em>single quotes</em>, e.g., <code>'z'</code>, <code>'$'</code>, and <code>'9'</code>. In C++, characters are represented using 8-bit ASCII code, and can be treated as a 8-bit <em>signed integer</em>s in arithmetic operations. In other words, <code>char</code> and 8-bit signed integer are interchangeable. You can also assign an integer in the range of <code>[-128, 127]</code> to a <code>char</code> variable; and <code>[0, 255]</code> to an <code>unsigned char</code>.</p>

<p>You can find the <a href="../java/DataRepresentation.html#ASCII">ASCII code table HERE</a>.</p>

<p>For example,</p>

<pre class="color-example">
char letter = 'a';             <span class="color-comment">// Same as 97</span>
char anotherLetter = 98;       <span class="color-comment">// Same as the letter 'b'</span>
cout &lt;&lt; letter &lt;&lt; endl;        <span class="color-comment">// 'a' printed</span>
cout &lt;&lt; anotherLetter &lt;&lt; endl; <span class="color-comment">// 'b' printed instead of the number</span>
anotherLetter += 2;            <span class="color-comment">// 100 or 'd'</span>
cout &lt;&lt; anotherLetter &lt;&lt; endl; <span class="color-comment">// 'd' printed</span>
cout &lt;&lt; (int)anotherLetter &lt;&lt; endl;  <span class="color-comment">// 100 printed</span></pre>

<p>Non-printable and control characters can be represented by a so-called <em>escape sequence</em>, which begins with a back-slash (<code>\</code>). The commonly-used escape sequences are:</p>

<table class="table-zebra" style="width:60%">
  <thead>
  <tr>
    <th>Escape Sequence</th>
    <th>Description</th>
    <th>Hex (Decimal)</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr>
    <td>\n</td>
    <td class="font-normal">New-line (or Line-feed)</td>
    <td>0AH (10D)</td>
  </tr>
  <tr class="tr-alt">
    <td>\r</td>
    <td class="font-normal">Carriage-return</td>
    <td>0DH (13D)</td>
  </tr>
  <tr>
    <td>\t</td>
    <td class="font-normal">Tab</td>
    <td>09H (9D)</td>
  </tr>
  <tr class="tr-alt">
    <td>\&quot;</td>
    <td class="font-normal">Double-quote (needed to include &quot; in double-quoted string)</td>
    <td>22H (34D)</td>
  </tr>
  <tr>
    <td>\'</td>
    <td class="font-normal">Single-quote</td>
    <td>27H (39D)</td>
  </tr>
  <tr class="tr-alt">
    <td>\\</td>
    <td class="font-normal">Back-slash (to resolve ambiguity)</td>
    <td>5CH (92D)</td>
  </tr>
  </tbody>
</table>

<p>Notes:</p>
<ul>
<li>New-line (<code>0AH</code>) and carriage return (<code>0dH</code>), represented by <code>\n</code>, and <code>\r</code> respectively, are used as <em>line delimiter</em> (or <em>end-of-line</em>, or <em>EOL</em>). However, take note that Unixes/Mac use <code>\n</code> as EOL, Windows use <code>\r\n</code>.</li>

<li>Horizontal Tab (<code>09H</code>) is represented as <code>\t</code>.</li>

<li>To resolve ambiguity, characters back-slash (<code>\</code>), single-quote (<code>'</code>) and double-quote (<code>&quot;</code>) are represented using escape sequences <code>\\</code>, <code>\'</code> and <code>\&quot;</code>, respectively. This is because a single back-slash begins an escape sequence, while single-quotes and double-quotes are used to enclose character and string.</li>
<li>Other less commonly-used escape sequences are: <code>\?</code> or <code>?</code>, <code>\a</code> for alert or bell, <code>\b</code> for backspace, <code>\f</code> for form-feed, <code>\v</code> for vertical tab. These may not be supported in some consoles.</li>
</ul>

<h5>The <span class="font-code">&lt;cctype&gt;</span> Header</h5>

<p>The <code>cctype</code> header (ported from C's <code>ctype.h</code>) provides functions such as <code>isalpha()</code>, <code>isdigit()</code>, <code>isspace()</code>, <code>ispunct()</code>, <code>isalnum()</code>, <code>isupper()</code>, <code>islower()</code> to determine the type of character; and <code>toupper()</code>, <code>tolower()</code> for case conversion.</p>

<h5>String Literals</h5>

<p>A <code>String</code> literal is composed of zero of more characters surrounded by a pair of <em>double quotes</em>, e.g., <code>&quot;Hello, world!&quot;</code>, <code>&quot;The sum is &quot;</code>, <code>&quot;&quot;</code>. For example,</p>
<pre class="color-example">
String directionMsg = &quot;Turn Right&quot;;
String greetingMsg = &quot;Hello&quot;;
String statusMsg = &quot;&quot;;             <span class="color-comment">// empty string</span></pre>
<p>String literals may contains escape sequences. Inside a <code>String</code>, you need to use <code>\&quot;</code> for double-quote to distinguish it from the ending double-quote, e.g. <code>&quot;\&quot;quoted\&quot;&quot;</code>. Single quote inside a <code>String</code> does not require escape sequence. For example,</p>
<pre class="color-example">
cout &lt;&lt; &quot;Use \\\&quot; to place\n a \&quot; within\ta\tstring&quot; &lt;&lt; endl;</pre>
<pre class="output">
Use \&quot; to place
 a &quot; within	a	string</pre>
 
<p><span class="line-heading">TRY:</span> Write a program to print the following picture. Take note that you need to use escape sequences to print special characters.</p>
<pre class="output">
          '__'
          (oo)
  +========\/
 / || %%% ||
*  ||-----||
   &quot;&quot;     &quot;&quot;</pre>

<h5><span class="font-code">bool</span> Literals</h5>

<p>There are only two <code>bool</code> literals, i.e., <code>true</code> and <code>false</code>. For example,</p>

<pre class="color-example">
bool done = true;
bool gameOver = false;
int i;
if (i == 9) {   <span class="color-comment">// returns either true or false</span>
   ......
}</pre>

<p>In an expression, <code>bool</code> values and literals are converted to <code>int</code> 0 for <code>false</code> and 1 (or a non-zero value) for <code>true</code>.</p>

<h5>Example (Literals)</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing Primitive Types (TestLiteral.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   char gender = 'm';             <span class="color-comment">// char is single-quoted</span>
   bool isMarried = true;         <span class="color-comment">// true(non-zero) or false(0)</span>
   unsigned short numChildren = 8; <span class="color-comment">// [0, 255]</span>
   short yearOfBirth = 1945;      <span class="color-comment">// [-32767, 32768]</span>
   unsigned int salary = 88000;   <span class="color-comment">// [0, 4294967295]</span>
   double weight = 88.88;       <span class="color-comment">// With fractional part</span>
   float gpa = 3.88f;           <span class="color-comment">// Need suffix 'f' for float</span>
 
   <span class="color-comment">// &quot;cout &lt;&lt;&quot; can be used to print value of any type</span>
   cout &lt;&lt; &quot;Gender is &quot; &lt;&lt; gender &lt;&lt; endl;
   cout &lt;&lt; &quot;Is married is &quot; &lt;&lt; isMarried &lt;&lt; endl;
   cout &lt;&lt; &quot;Number of children is &quot; &lt;&lt; numChildren &lt;&lt; endl;
   cout &lt;&lt; &quot;Year of birth is &quot; &lt;&lt; yearOfBirth &lt;&lt; endl;
   cout &lt;&lt; &quot;Salary is &quot; &lt;&lt; salary &lt;&lt; endl;
   cout &lt;&lt; &quot;Weight is &quot; &lt;&lt; weight &lt;&lt; endl;
   cout &lt;&lt; &quot;GPA is &quot; &lt;&lt; gpa &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Gender is m
Is married is 1    <span class="color-comment">// true</span>
Number of children is 8
Year of birth is 1945
Salary is 88000
Weight is 88.88
GPA is 3.88</pre>

<h3>Operations</h3>

<h4>Arithmetic Operators</h4>

<p>C++ supports the following arithmetic operators for numbers: <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, <code>char</code> (treated as 8-bit signed integer), <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>, <code>unsigned char</code>, <code>float</code>, <code>double</code> and  <code>long double</code>.</p>

<table class="table-zebra" style="width:80%">
  <thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
    <th>Examples</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr class="tr-alt">
    <td>*</td>
    <td class="font-normal">Multiplication</td>
    <td><em>expr1</em> * <em>expr2</em></td>
    <td>2 * 3 &rarr; 6;  3.3 * 1.0 &rarr; 3.3</td>
  </tr>
  <tr>
    <td>/</td>
    <td class="font-normal">Division</td>
    <td><em>expr1</em> / <em>expr2</em></td>
    <td>1 / 2 &rarr; 0;  1.0 / 2.0 &rarr; 0.5</td>
  </tr>
  <tr class="tr-alt">
    <td>%</td>
    <td class="font-normal">Remainder (Modulus)</td>
    <td><em>expr1</em> % <em>expr2</em></td>
    <td>5 % 2 &rarr; 1;  -5 % 2 &rarr; -1</td>
  </tr>
  <tr>
    <td>+</td>
    <td class="font-normal">Addition</td>
    <td><em>expr1</em> + <em>expr2</em></td>
    <td>1 + 2 &rarr; 3;  1.1 + 2.2 &rarr; 3.3</td>
  </tr>
  <tr class="tr-alt">
    <td>-</td>
    <td class="font-normal">Subtraction</td>
    <td><em>expr1</em> - <em>expr2</em></td>
    <td>1 - 2 &rarr; -1;  1.1 - 2.2 &rarr; -1.1</td>
  </tr>
  </tbody>
</table>

<p>All the above operators are <em>binary</em> operators, i.e., they take two operands. The multiplication, division and remainder take <em>precedence</em> over addition and subtraction. Within the same precedence level (e.g., addition and subtraction), the expression is evaluated from left to right. For example, <code>1+2+3-4</code> is evaluated as <code>((1+2)+3)-4</code>.</p>

<p>It is important to take note that <code>int/int</code> produces an <code>int</code>, with the result <em>truncated</em>, e.g.,<code> 1/2 &rarr; 0 </code>(instead of <code>0.5</code>).</p>

<p>Take note that C/C++ does not have an exponent (power) operator (<code>'^'</code> is exclusive-or, not exponent).</p>

<h4>Arithmetic Expressions</h4>
<p>In programming, the following arithmetic expression:</p>
<img src="../java/images/JavaBasics_ArithmeticExpression.png" alt="" class="image-left" />
<p>must be written as <code>(1+2*a)/3 + (4*(b+c)*(5-d-e))/f - 6*(7/g+h)</code>. You cannot omit the multiplication symbol <code>'*'</code> (as in Mathematics).</p>
<p>Like Mathematics, the multiplication <code>'*'</code> and division <code>'/'</code> take precedence over addition <code>'+'</code> and subtraction <code>'-'</code>. Parentheses <code>()</code> have higher precedence. The operators <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, and <code>'/'</code> are <em>left-associative</em>. That is, <code>1 + 2 + 3 + 4</code> is treated as <code>(((1+2) + 3) + 4)</code>.</p>

<h4>Mixed-Type Operations</h4>

<p>If both the operands of an arithmetic operation belong to the <em>same type</em>, the operation is carried out in that type, and the result belongs to that type. For example, <code>int/int &rarr; int; double/double &rarr; double</code>.</p>

<p>However, if the two operands belong to <em>different types</em>, the compiler promotes the value of the <em>smaller</em> type to the <em>larger</em> type (known as <em>implicit type-casting</em>). The operation is then carried out in the <em>larger</em> type. For example, <code>int/double &rarr; double/double &rarr; double</code>. Hence, <code>1/2 &rarr; 0, 1.0/2.0 &rarr; 0.5, 1.0/2 &rarr; 0.5, 1/2.0 &rarr; 0.5</code>.</p>

<p>For example,</p>

<table class="table-zebra" style="width:80%">
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Operation</th>
</tr>
</thead>
<tbody class="font-code">
<tr>
<td>int</td>
<td>2 + 3</td>
<td>int 2 + int 3 &rarr; int 5</td>
</tr>

<tr class="tr-alt">
<td>double</td>
<td>2.2 + 3.3</td>
<td>double 2.2 + double 3.3 &rarr; double 5.5</td>
</tr>

<tr>
<td>mix</td>
<td>2 + 3.3</td>
<td>int 2 + double 3.3 &rarr; double 2.0 + double 3.3 &rarr; double 5.3</td>
</tr>

<tr class="tr-alt">
<td>int</td>
<td>1 / 2</td>
<td>int 1 / int 2 &rarr; int 0</td>
</tr>

<tr>
<td>double</td>
<td>1.0 / 2.0</td>
<td>double 1.0 / double 2.0 &rarr; double 0.5</td>
</tr>

<tr class="tr-alt">
<td>mix</td>
<td>1 / 2.0</td>
<td>int 1 / double 2.0 &rarr; double 1.0 + double 2.0 &rarr; double 0.5</td>
</tr>

</tbody>
</table>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing mix-type arithmetic operations (TestMixTypeOp.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;   <span class="color-comment">// needed for formatting floating-point numbers</span>
using namespace std;
 
int main() {
   int i1 = 2, i2 = 4;
   double d1 = 2.5, d2 = 5.0;
 
   <span class="color-comment">// Print floating-points in fixed format with 1 decimal place</span>
   cout &lt;&lt; fixed &lt;&lt; setprecision(1);  <span class="color-comment">// need &lt;iomanip&gt;</span>
 
   cout &lt;&lt; i1 &lt;&lt; &quot; + &quot; &lt;&lt; i2 &lt;&lt; &quot; = &quot; &lt;&lt; i1+i2 &lt;&lt; endl;  <span class="color-comment">// 6</span>
   cout &lt;&lt; d1 &lt;&lt; &quot; + &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; d1+d2 &lt;&lt; endl;  <span class="color-comment">// 7.5</span>
   cout &lt;&lt; i1 &lt;&lt; &quot; + &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; i1+d2 &lt;&lt; endl;  <span class="color-comment">// 7.0  &lt;==</span>
 
   cout &lt;&lt; i1 &lt;&lt; &quot; - &quot; &lt;&lt; i2 &lt;&lt; &quot; = &quot; &lt;&lt; i1-i2 &lt;&lt; endl;  <span class="color-comment">// -2</span>
   cout &lt;&lt; d1 &lt;&lt; &quot; - &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; d1-d2 &lt;&lt; endl;  <span class="color-comment">// -2.5</span>
   cout &lt;&lt; i1 &lt;&lt; &quot; - &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; i1-d2 &lt;&lt; endl;  <span class="color-comment">// -3.0 &lt;==</span>
 
   cout &lt;&lt; i1 &lt;&lt; &quot; * &quot; &lt;&lt; i2 &lt;&lt; &quot; = &quot; &lt;&lt; i1*i2 &lt;&lt; endl;  <span class="color-comment">// 8</span>
   cout &lt;&lt; d1 &lt;&lt; &quot; * &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; d1*d2 &lt;&lt; endl;  <span class="color-comment">// 12.5</span>
   cout &lt;&lt; i1 &lt;&lt; &quot; * &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; i1*d2 &lt;&lt; endl;  <span class="color-comment">// 10.0 &lt;==</span>
 
   cout &lt;&lt; i1 &lt;&lt; &quot; / &quot; &lt;&lt; i2 &lt;&lt; &quot; = &quot; &lt;&lt; i1/i2 &lt;&lt; endl;  <span class="color-comment">// 0    &lt;==</span>
   cout &lt;&lt; d1 &lt;&lt; &quot; / &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; d1/d2 &lt;&lt; endl;  <span class="color-comment">// 0.5</span>
   cout &lt;&lt; i1 &lt;&lt; &quot; / &quot; &lt;&lt; d2 &lt;&lt; &quot; = &quot; &lt;&lt; i1/d2 &lt;&lt; endl;  <span class="color-comment">// 0.4  &lt;==</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Overflow/UnderFlow</h4>
<p>Study the output of the following program:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Arithmetic Overflow/Underflow (TestOverflow.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   <span class="color-comment">// Range of int is [-2147483648, 2147483647]</span>
   int i1 = 2147483647;      <span class="color-comment">// max int</span>
   cout &lt;&lt; i1 + 1 &lt;&lt; endl;   <span class="color-comment">// -2147483648 (overflow)</span>
   cout &lt;&lt; i1 + 2 &lt;&lt; endl;   <span class="color-comment">// -2147483647</span>
   cout &lt;&lt; i1 * i1 &lt;&lt; endl;  <span class="color-comment">// 1</span>
 
   int i2 = -2147483648;     <span class="color-comment">// min int</span>
   cout &lt;&lt; i2 - 1 &lt;&lt; endl;   <span class="color-comment">// 2147483647 (underflow)</span>
   cout &lt;&lt; i2 - 2 &lt;&lt; endl;   <span class="color-comment">// 2147483646</span>
   cout &lt;&lt; i2 * i2 &lt;&lt; endl;  <span class="color-comment">// 0</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In arithmetic operations, the resultant value <em>wraps around</em> if it exceeds its range (i.e., overflow or underflow). C++ runtime does not issue an error/warning message but produces <em>incorrect</em> result.</p>

<p>It is important to take note that <em>checking of overflow/underflow is the programmer's responsibility</em>, i.e., your job!</p>

<p>This feature is an legacy design, where processors were slow. Checking for overflow/underflow consumes computation power and reduces performance.</p>

<p>To check for arithmetic overflow (known as <em>secure coding</em>) is tedious. Google for &quot;INT32-C. Ensure that operations on signed integers do not result in overflow&quot; @ www.securecoding.cert.org.</p>

<h4>Compound Assignment Operators</h4>

<p>Besides the usual simple assignment operator <code>'='</code> described earlier, C++ also provides the so-called <em>compound assignment operator</em>s as listed:</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Usage</th>
    <th>Description</th>
    <th>Example</th>
  </tr>
  </thead>
  <tbody class="font-code">
    <tr>
      <td>=</td>
      <td><em>var</em> = <em>expr</em></td>
      <td class="font-normal">Assign the value of the LHS to the variable at the RHS</td>
      <td>x = 5;</td>
    </tr>
    <tr class="tr-alt">
      <td>+=</td>
      <td><em>var</em> += <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> + <em>expr</em></td>
      <td>x += 5; same as x = x + 5</td>
    </tr>
    <tr>
      <td>-=</td>
      <td><em>var</em> -= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> - <em>expr</em></td>
      <td>x -= 5; same as x = x - 5</td>
    </tr>
    <tr class="tr-alt">
      <td>*=</td>
      <td><em>var</em> *= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> * <em>expr</em></td>
      <td>x *= 5; same as x = x * 5</td>
    </tr>
    <tr>
      <td>/=</td>
      <td><em>var</em> /= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> / <em>expr</em></td>
      <td>x /= 5; same as x = x / 5</td>
    </tr>
    <tr class="tr-alt">
      <td>%=</td>
      <td><em>var</em> %= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> % <em>expr</em></td>
      <td>x %= 5; same as x = x % 5</td>
    </tr>
  </tbody>
</table>

<h4>Increment/Decrement Operators</h4>

<p>C++ supports these <em>unary</em> arithmetic operators: increment <code>'++'</code> and decrement <code>'--'</code>.</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Example</th>
    <th>Result</th>
  </tr>
  </thead>
  <tbody class="font-code">
    <tr>
      <td>++</td>
      <td>x++; ++x</td>
      <td class="font-normal">Increment by 1, same as x += 1</td>
    </tr>
    <tr class="tr-alt">
      <td>--</td>
      <td>x--; --x</td>
      <td class="font-normal">Decrement by 1, same as x -= 1</td>
    </tr>
  </tbody>
</table>

<p>For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test on increment (++) and decrement (--) Operator (TestIncDec.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int mark = 76;        <span class="color-comment">// declare &amp; assign</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 76</span>
 
   mark++;               <span class="color-comment">// increase by 1 (post-increment)</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 77</span>
 
   ++mark;               <span class="color-comment">// increase by 1 (pre-increment)</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 78</span>
 
   mark = mark + 1;      <span class="color-comment">// also increase by 1 (or mark += 1)</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 79</span>
 
   mark--;               <span class="color-comment">// decrease by 1 (post-decrement)</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 78</span>
 
   --mark;               <span class="color-comment">// decrease by 1 (pre-decrement)</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 77</span>
 
   mark = mark - 1;      <span class="color-comment">// also decrease by 1 (or mark -= 1)</span>
   cout &lt;&lt; mark &lt;&lt; endl; <span class="color-comment">// 76</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The increment/decrement unary operator can be placed before the operand (prefix operator), or after the operands (postfix operator). They takes on different meaning in operations.</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Example</th>
    <th>Result</th>
  </tr>
  </thead>
  <tbody class="font-code">
    <tr>
      <td>++var</td>
      <td class="font-normal">Pre-Increment<br />
        Increment <em>var</em>, then use the new value of <em>var</em></td>
      <td>y = ++x;</td>
      <td>same as x=x+1; y=x;</td>
    </tr>
    <tr class="tr-alt">
      <td>var++</td>
      <td class="font-code">Post-Increment<br />
        Use the old value of <em>var</em>, then increment <em>var</em></td>
      <td>y = x++;</td>
      <td>same as oldX=x; x=x+1; y=oldX;</td>
    </tr>
    <tr>
      <td>--var</td>
      <td class="font-code">Pre-Decrement</td>
      <td>y = --x;</td>
      <td>same as x=x-1; y=x;</td>
    </tr>
    <tr class="tr-alt">
      <td>var--</td>
      <td class="font-code">Post-Decrement</td>
      <td>y = x--;</td>
      <td>same as oldX=x; x=x-1; y=oldX;</td>
    </tr>
  </tbody>
</table>

<p>If '++' or '--' involves another operation, then pre- or post-order is important to specify the order of the two operations. For examples,</p>

<pre class="color-example">
x = 5;
cout &lt;&lt; x++ &lt;&lt; endl;  <span class="color-comment">// Save x (5); Increment x (=6); Print old x (5).</span>
x = 5;
cout &lt;&lt; ++x &lt;&lt; endl;  <span class="color-comment">// Increment x (=6); Print x (6).</span>
<span class="color-comment">// This is confusing! Try to avoid! What is i=++i? What is i=i++?</span>
</pre>

<p>Prefix operator (e.g, <code>++i</code>) could be more efficient than postfix operator (e.g., <code>i++</code>) in some situations.</p>

<h4>Implicit Type-Conversion vs. Explicit Type-Casting</h4>

<p>Converting a value from one type to another type is called <em>type casting</em> (or <em>type conversion</em>). There are two kinds of type casting:</p>

<ol>
<li>Implicit type-conversion performed by the compiler automatically, and</li>

<li>Explicit type-casting via an unary <em>type-casting operator</em> in the form of <code>(<em>new-type</em>)<em>operand</em></code> or  <code><em>new-type</em>(<em>operand</em>)</code>.</li>
</ol>

<h5>Implicit (Automatic) Type Conversion</h5>

<p>When you assign a value of a fundamental (built-in) type to a variable of another fundamental type, C++ automatically converts the value to the receiving type, if the two types are compatible. For examples,</p>

<ul>
<li>If you assign an <code>int</code> value to a <code>double</code> variable, the compiler automatically casts the <code>int</code> value to a <code>double</code> double (e.g., from 1 to 1.0) and assigns it to the <code>double</code> variable.</li>
<li>if you assign a <code>double</code> value of to an <code>int</code> variable, the compiler automatically casts the <code>double</code> value to an <code>int</code> value (e.g., from 1.2 to 1) and assigns it to the <code>int</code> variable. The fractional part would be truncated and lost. Some compilers issue a warning/error &quot;possible loss in precision&quot;; others do not.</li>
</ul>

<table class="table-program">
  <col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td>
<td>
<pre>
<span class="color-comment">/*
 * Test implicit type casting (TestImplicitTypeCast.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
 
int main() {
   int i;
   double d;
 
   <span class="color-comment">// print floating point number in fixed format with 1 decimal place</span>
   cout &lt;&lt; fixed &lt;&lt; setprecision(1);
 
   i = 3;
   d = i;    <span class="color-comment">// Assign an int value to double</span>
   cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;  <span class="color-comment">// 3.0</span>
 
   d = 5.5;
   i = d;    <span class="color-comment">// Assign a double value to int</span>
   cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;  <span class="color-comment">// 5 (truncated, no warning!)</span>
 
   i = 6.6;  <span class="color-comment">// Assign a double literal to int</span>
   cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;  <span class="color-comment">// 6 (truncated, no warning!)</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>C++ will not perform automatic type conversion, if the two types are not compatible.</p>

<h5>Explicit Type-Casting</h5>

<p>You can explicitly perform type-casting via the so-called unary <em>type-casting operator</em> in the form of <code>(<em>new-type</em>)<em>operand</em></code> or <code><em>new-type</em>(<em>operand</em>)</code>. The type-casting operator takes one operand in the particular type, and returns an equivalent value in the new type. Take note that it is an operation that yields a resultant value, similar to an addition operation although addition involves two operands. For example,</p>

<pre class="color-example">
<span class="color-comment">// Print floating-point number in fixed format with 1 decimal point (need &lt;iomanip&gt;)</span>
cout &lt;&lt; fixed &lt;&lt; setprecision(1);
 
cout &lt;&lt; (double)5 &lt;&lt; endl;  <span class="color-comment">// int 5 &rarr; double 5.0</span>
cout &lt;&lt; (int)5.5 &lt;&lt; endl;   <span class="color-comment">// double 5.5 &rarr; int 5</span>
 
double aDouble = 5.6;
int anInt = (int)aDouble; <span class="color-comment">// return 5 and assign to anInt. aDouble does not change!</span>
 
<span class="color-comment">// C++ also supports function-style type cast.</span>
cout &lt;&lt; double(5) &lt;&lt; endl;     <span class="color-comment">// 5.0</span>
cout &lt;&lt; int(5.5) &lt;&lt; endl;      <span class="color-comment">// 5</span>
cout &lt;&lt; int(aDouble) &lt;&lt; endl;  <span class="color-comment">// 5</span>
</pre>

<p><span class="line-heading">Example:</span> Suppose that you want to find the average (in <code>double</code>) of the integers between <code>1</code> and <code>100</code>. Study the following codes:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Testing Explicit Type Cast (Average1to100.cpp).
 */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
 
int main() {
   int sum = 0;
   double average;
   for (int number = 1; number &lt;= 100; ++number) {
      sum += number;      <span class="color-comment">// Final sum is int 5050</span>
   }
   average = sum / 100;   <span class="color-comment">// Won't work (average = 50.0 instead of 50.5)</span>
   cout &lt;&lt; fixed &lt;&lt; setprecision(1);
   cout &lt;&lt; &quot;Average is &quot; &lt;&lt; average &lt;&lt; endl;  <span class="color-comment">// Average is 50.0</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>You don't get the fractional part although the <code>average</code> is a <code>double</code>. This is because both the <code>sum</code> and <code>100</code> are <code>int</code>. The result of division is an <code>int</code>, which is then implicitly casted to <code>double</code> and assign to the <code>double</code> variable <code>average</code>.  To get the correct answer, you can do either:</p>

<pre class="color-example" >
average = (double)sum / 100;     <span class="color-comment">// Cast sum from int to double before division</span>
average = sum / (double)100;     <span class="color-comment">// Cast 100 from int to double before division</span>
average = sum / 100.0;
average = (double)(sum / 100);   <span class="color-comment">// Won't work. why?</span>
 
<span class="color-comment">// C++ also support function-style type casting in the form of <em>new-type</em>(<em>operand</em>)</span>
average = double(sum) / 100;     <span class="color-comment">// Same as (double)sum / 100</span></pre>

<p><span class="line-heading">Example</span>:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Type Casting (TestTypeCast.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
 
int main() {
   <span class="color-comment">// Print floating-point number in fixed format with 1 decimal place</span>
   cout &lt;&lt; fixed &lt;&lt; setprecision(1);
 
   <span class="color-comment">// Test explicit type casting</span>
   int i1 = 4, i2 = 8;
   cout &lt;&lt; i1 / i2 &lt;&lt; endl;           <span class="color-comment">// 0</span>
   cout &lt;&lt; (double)i1 / i2 &lt;&lt; endl;   <span class="color-comment">// 0.5</span>
   cout &lt;&lt; i1 / (double)i2 &lt;&lt; endl;   <span class="color-comment">// 0.5</span>
   cout &lt;&lt; (double)(i1 / i2) &lt;&lt; endl; <span class="color-comment">// 0.0</span>
 
   double d1 = 5.5, d2 = 6.6;
   cout &lt;&lt; (int)d1 / i2 &lt;&lt; endl;      <span class="color-comment">// 0</span>
   cout &lt;&lt; (int)(d1 / i2) &lt;&lt; endl;    <span class="color-comment">// 0</span>
 
   <span class="color-comment">// Test implict type casting</span>
   d1 = i1;             <span class="color-comment">// int implicitly casts to double</span>
   cout &lt;&lt; d1 &lt;&lt; endl;  <span class="color-comment">// 4.0</span>
   i2 = d2;             <span class="color-comment">// double truncates to int! (Warning?)</span>
   cout &lt;&lt; i2 &lt;&lt; endl;  <span class="color-comment">// 6</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading">Example:</span></p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Converting between Celsius and Fahrenheit (ConvertTemperature.cpp)
 *   Celsius = (5/9)(Fahrenheit–32)
 *   Fahrenheit = (9/5)Celsius+32
 */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;   <span class="color-comment">// needed for formatting floating-point numbers</span>
using namespace std;
 
int main() {
   double celsius, fahrenheit;
 
   <span class="color-comment">// Format floating-points in fixed with 2 decimal places</span>
   cout &lt;&lt; fixed &lt;&lt; setprecision(2);
 
   cout &lt;&lt; &quot;Enter the temperature in celsius: &quot;;
   cin &gt;&gt; celsius;
   fahrenheit = celsius*9/5 + 32;
   <span class="color-comment">// 9/5*celsius + 32 gives wrong answer! Why?</span>
   cout &lt;&lt; celsius &lt;&lt; &quot;C is &quot; &lt;&lt; fahrenheit &lt;&lt; &quot;F&quot; &lt;&lt; endl;
 
   cout &lt;&lt; &quot;Enter the temperature in fahrenheit: &quot;;
   cin &gt;&gt; fahrenheit;
   celsius =  (fahrenheit - 32)*5/9;
   <span class="color-comment">// 5/9*(fahrenheit - 32) gives wrong answer! Why?</span>
   cout &lt;&lt; fahrenheit &lt;&lt; &quot;F is &quot; &lt;&lt; celsius &lt;&lt; &quot;C&quot; &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>*Operator <span class="font-code">static-cast&lt;<em>type</em>&gt;</span></h5>

<p>C++ introduces a new operator called <code>static_cast&lt;<em>type</em>&gt;</code> to perform type conversion (because the regular cast mentioned earlier is too lax and could produce expected results). <code>static_cast</code> signal an error if conversion fails. For example,</p>

<pre class="color-example">
double d = 5.5;
int i = static_cast&lt;int&gt;(d);
float f = static_cast&lt;float&gt;(i);
long l = static_cast&lt;logn&gt;(d);</pre>

<h4>Relational and Logical Operators</h4>

<p>Very often, you need to compare two values before deciding on the action to be taken, e.g., if mark is more than or equal to 50, print &quot;PASS&quot;.</p>
<p>C++ provides six <em>comparison operators</em> (or <em>relational operators</em>):</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
    <th>Example (x=5, y=8)</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr>
    <td>==</td>
    <td class="font-normal">Equal to</td>
    <td><em>expr1</em> == <em>expr2</em></td>
    <td>(x == y) &rarr; false</td>
  </tr>
  <tr class="tr-alt">
    <td>!=</td>
    <td class="font-normal">Not Equal to</td>
    <td><em>expr1</em> != <em>expr2</em></td>
    <td>(x != y) &rarr; true</td>
  </tr>
  <tr>
    <td>&gt;</td>
    <td class="font-normal">Greater than</td>
    <td><em>expr1</em> &gt; <em>expr2</em></td>
    <td>(x &gt; y) &rarr; false</td>
  </tr>
  <tr class="tr-alt">
    <td>&gt;=</td>
    <td class="font-normal">Greater than or equal to</td>
    <td><em>expr1</em> &gt;= <em>expr2</em></td>
    <td>(x &gt;= 5) &rarr; true</td>
  </tr>
  <tr>
    <td>&lt;</td>
    <td class="font-normal">Less than</td>
    <td><em>expr1</em> &lt; <em>expr2</em></td>
    <td>(y &lt; 8) &rarr; false</td>
  </tr>
  <tr>
    <td>&lt;=</td>
    <td class="font-normal">Less than or equal to</td>
    <td><em>expr1</em> &gt;= <em>expr2</em></td>
    <td>(y &lt;= 8) &rarr; true</td>
  </tr>
  </tbody>
</table>

<p>In C++, these comparison operations returns a <code>bool</code> value of either <code>false</code> (0) or <code>true</code> (1 or a non-zero value).</p>

<p>Each comparison operation involves two operands, e.g., <code>x &lt;= 100</code>. It is invalid to write <code>1 &lt; x &lt; 100</code> in programming. Instead, you need to break out the two comparison operations <code>x &gt; 1</code>, <code>x &lt; 100</code>, and join with with a logical AND operator, i.e., <code>(x &gt; 1) &amp;&amp; (x &lt; 100)</code>, where <code>&amp;&amp;</code> denotes AND operator.</p>

<p>C++ provides four logical operators (which operate on <code>boolean</code> operands only):</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr>
    <td>&amp;&amp;</td>
    <td class="font-normal">Logical AND</td>
    <td><em>expr1</em> &amp;&amp; <em>expr2</em></td>
  </tr>
  <tr class="tr-alt">
    <td>||</td>
    <td class="font-normal">Logical OR</td>
    <td><em>expr1</em> || <em>expr2</em></td>
  </tr>
  <tr>
    <td>!</td>
    <td class="font-normal">Logical NOT</td>
    <td>!<em>expr</em></td>
  </tr>
  <tr class="tr-alt">
    <td>^</td>
    <td class="font-normal">Logical XOR</td>
    <td><em>expr1</em> ^ <em>expr2</em></td>
  </tr>
  </tbody>
</table>

<p> The truth tables are as follows:</p>
<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>AND (&amp;&amp;)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>true</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
  <tr>
    <td>false</td>
    <td><span class="color-comment">false</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
</table>

<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>OR (||)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>true</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">true</span></td>
  </tr>
  <tr>
    <td>false</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
</table>
<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>NOT (!)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td></td>
    <td><span class="color-comment">false</span></td>
    <td><span class="color-comment">true</span></td>
  </tr>
</table>

<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>XOR (^)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>true</td>
    <td><span class="color-comment">false</span></td>
    <td><span class="color-comment">true</span></td>
  </tr>
  <tr>
    <td>false</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
</table>

<p><span class="line-heading">Example:</span></p>
<pre class="color-example">
<span class="color-comment">// Return true if x is between 0 and 100 (inclusive)</span>
(x &gt;= 0) &amp;&amp; (x &lt;= 100)
<span class="color-comment">// wrong to use 0 &lt;= x &lt;= 100</span>
&nbsp; 
<span class="color-comment">// Return true if x is outside 0 and 100 (inclusive)</span>
(x &lt; 0) || (x &gt; 100)   <span class="color-comment">//or</span>
!((x &gt;= 0) &amp;&amp; (x &lt;= 100))
&nbsp;
<span class="color-comment">// Return true if year is a leap year</span>
<span class="color-comment">// A year is a leap year if it is divisible by 4 but not by 100, or it is divisible by 400.</span>
((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)</pre>

<p><span class="line-heading">Exercise:</span> Given the year, month (1-12), and day (1-31), write a boolean expression which returns true for dates before October 15, 1582 (Gregorian calendar cut over date).</p>
<p>Ans: <code>(year &lt; 1582) || (year == 1582 &amp;&amp; month &lt; 10) || (year == 1582 &amp;&amp; month == 10 &amp;&amp; day &lt; 15)</code></p>


<h3>Flow Control</h3>

<p>There are three basic flow control constructs - <em>sequential</em>, <em>conditional</em> (or <em>decision</em>), and <em>loop</em> (or <em>iteration</em>), as illustrated below.</p>
<img class="image-center" src="../java/images/Flowchart_FlowControl.png" alt="structure constructs" />

<h4>Sequential Flow Control</h4>

<p>A program is a sequence of instructions. <em>Sequential</em> flow is the most common and straight-forward, where programming statements are executed in the order that they are written - from top to bottom in a sequential manner.</p>

<h4>Conditional (Decision) Flow Control</h4>

<p>There are a few types of conditionals, <em>if-then</em>, <em>if-then-else</em>, <em>nested-if</em> (<em>if-elseif-elseif-...-else</em>), <em>switch-case</em>, and <em>conditional expression</em>.</p>

<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    <th>Flowchart</th>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// if-then</span>
<strong>if (</strong> <em>booleanExpression</em><em></em> <strong>) {</strong>
   <em>true-block</em> <strong>;</strong>
<strong>}</strong>
 
 
 
 
 
 </pre></td>
    <td><pre class="color-explanation">if (mark &gt;= 50) {
   cout &lt;&lt; &quot;Congratulation!&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Keep it up!&quot; &lt;&lt; endl;
}
 
 
 
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_IfThen.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// if-then-else</span>
<strong>if (</strong> <em>booleanExpression</em><em></em> <strong>) {</strong>
   <em>true-block</em> <strong>;</strong>
<strong>} else {</strong>
   <em>false-block</em> <strong>;</strong>
<strong>}</strong>
 
 
 
 </pre></td>
    <td><pre class="color-explanation">if (mark &gt;= 50) {
   cout &lt;&lt; &quot;Congratulation!&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Keep it up!&quot; &lt;&lt; endl;
} else {
   cout &lt;&lt; &quot;Try Harder!&quot; &lt;&lt; endl;
}
 
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_IfElse.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// nested-if</span>
<strong>if (</strong> <em>booleanExpr-1</em> <strong>) {</strong>
   <em>block-1</em> <strong>;
} else if (</strong> <em>booleanExpr-2</em> <strong>) {</strong>
   <em>block-2</em> <strong>;
} else if (</strong> <em>booleanExpr-3</em> <strong>) {</strong>
   <em>block-3</em> <strong>;
} else if (</strong> <em>booleanExpr-4</em> <strong>) {</strong>
   ......<strong>
} else {</strong>
   <em>elseBlock</em> <strong>;
}</strong></pre></td>
    <td><pre class="color-explanation">if (mark &gt;= 80) {
   cout &lt;&lt; &quot;A&quot; &lt;&lt; endl;
} else if (mark &gt;= 70) {
   cout &lt;&lt; &quot;B&quot; &lt;&lt; endl;
} else if (mark &gt;= 60) {
   cout &lt;&lt; &quot;C&quot; &lt;&lt; endl;
} else if (mark &gt;= 50) {
   cout &lt;&lt; &quot;D&quot; &lt;&lt; endl;
} else {
   cout &lt;&lt; &quot;F&quot; &lt;&lt; endl;
}
   </pre></td>
    <td><img src="../java/images/Flowchart_NestedIf.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// switch-case</span>
<strong>switch (</strong> <em>selector</em><em></em> <strong>) {
   case</strong> <em>value-1</em><strong>:</strong>
      <em>block-1</em><strong>; break;
   case</strong> <em>value-2</em><strong>:</strong>
      <em>block-2</em><strong>; break;
   case</strong> <em>value-3</em><strong>:</strong>
      <em>block-3</em><strong>; break;</strong>
   ......
<strong>   case</strong> <em>value-n</em><strong>:</strong>
      <em>block-n</em><strong>; break;</strong>
<strong>   default:</strong>
      <em>default-block</em><strong>;
}</strong></pre></td>
    <td><pre class="color-explanation">char oper; int num1, num2, result;
......
switch (oper) {
   case '+': 
      result = num1 + num2; break;
   case '-': 
      result = num1 - num2; break;
   case '*': 
      result = num1 * num2; break;
   case '/': 
      result = num1 / num2; break;
   default:
      cout &lt;&lt; &quot;Unknown operator&quot; &lt;&lt; endl;
}</pre></td>
    <td><img src="../java/images/Flowchart_SwitchCase.png" alt="" /></td>
  </tr>
</table>

<p>&quot;switch-case&quot; is an alternative to the &quot;nested-if&quot;. In a <em>switch-case</em> statement, a <code>break</code> statement is needed for each of the cases. If <code>break</code> is missing, execution will flow through the following case.  You can use either an <code>int</code> or <code>char</code> variable as the case-<em>selector</em>.</p>

<p><span class="line-heading">Conditional Operator:</span> A conditional operator is a ternary (3-operand) operator, in the form of <code><em>booleanExpr</em> ? <em>trueExpr</em> : <em>falseExpr</em></code>. Depending on the <code><em>booleanExpr</em></code>, it evaluates and returns the value of <em><code>trueExpr</code></em> or <code><em>falseExpr</em></code>.</p>
<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment"></span><em>booleanExpr</em> <strong>?</strong> <em>trueExpr</em> <strong>:</strong> <em>falseExpr</em>
 
 
 </pre></td>
    <td><pre class="color-explanation">cout &lt;&lt; (mark &gt;= 50) ? &quot;PASS&quot; : &quot;FAIL&quot; &lt;&lt; endl;
   <span class="color-comment">// return either &quot;PASS&quot; or &quot;FAIL&quot;, and put to cout</span>
max = (a &gt; b) ? a : b;   <span class="color-comment">// RHS returns a or b</span>
abs = (a &gt; 0) ? a : -a;  <span class="color-comment">// RHS returns a or -a</span>   </pre></td>
    </tr>
</table>
<p><span class="line-heading">Braces:</span> You could omit the braces <code>{ }</code>, if there is only one statement inside the block. For example,</p>
<pre class="color-example">
if (mark &gt;= 50) 
   cout &lt;&lt; &quot;PASS&quot; &lt;&lt; endl;   <span class="color-comment">// Only one statement, can omit { } but not recommended</span>
else {                           <span class="color-comment">// more than one statements, need { }</span>
   cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;
   cout &lt;&lt; &quot;Try Harder!&quot; &lt;&lt; endl;
}</pre>

<p>However, I recommend that you keep the braces, even though there is only one statement in the block, to improve the readability of your program.</p>

<h5>Exercises</h5>
<p>[TODO]</p>

<h4>Loop Flow Control</h4>
<p>Again, there are a few types of loops: <em>for-loop</em>, <em>while-do</em>, and <em>do-while</em>.</p>

<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    <th>Flowchart</th>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// for-loop</span>
<strong>for (</strong><em>init</em><strong>;</strong> <em>test</em><strong>;</strong> <em>post-proc</em><strong>) {</strong>
   <em>body</em> <strong>;</strong>
<strong>}</strong>
 
 
 
 
 </pre></td>
    <td><pre class="color-explanation">
<span class="color-comment">// Sum from 1 to 1000</span>
int sum = 0;
for (int number = 1; number &lt;= 1000; ++number) {
   sum += number;
}
 
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_For.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// while-do</span>
<strong>while (</strong> <em>condition</em> <strong>) {</strong>
   <em>body</em> <strong>;
}</strong>
 
 
&nbsp;</pre></td>
    <td><pre class="color-explanation">int sum = 0, number = 1;
while (number &lt;= 1000) {
   sum += number;
   ++number;
}
 
 </pre></td>
    <td><img src="../java/images/Flowchart_While.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// do-while</span>
<strong>do {</strong>
   <em>body</em> <strong>;
}
while (</strong> <em>condition</em> <strong>) ;</strong>
 
 
 </pre></td>
    <td><pre class="color-explanation">int sum = 0, number = 1;
do {
   sum += number;
   ++number;
} while (number &lt;= 1000);
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_DoWhile.png" alt="" /></td>
  </tr>
</table>

<p>The difference between <em>while-do</em> and <em>do-while</em> lies in the order of the <em>body</em> and <em>condition</em>. In <em>while-do</em>, the <em>condition</em> is tested first. The body will be executed if the <em>condition</em> is true and the process repeats.  In <em>do-while</em>, the <em>body</em> is executed and then the <em>condition</em> is tested. Take note that the <em>body</em> of <em>do-while</em> will be executed at least once (vs. possibly zero for <em>while-do</em>).</p>

<p>Suppose that your program prompts user for a number between <code>1</code> to <code>10</code>, and checks for valid input, do-while with a boolean flag could be more appropriate.</p>

<pre class="color-example">
<span class="color-comment">// Input with validity check</span>
bool valid = false;
int number;
do {
  <span class="color-comment">// prompt user to enter an int between 1 and 10</span>
  ......
  <span class="color-comment">// if the number entered is valid, set done to exit the loop</span>
  if (number &gt;=1 &amp;&amp; number &lt;= 10) {
     valid = true;
  }
} while (!valid);   <span class="color-comment">// Need a semi-colon to terminate do-while</span></pre>

<p>Below is an example of using while-do:</p>

<pre class="color-example">
<span class="color-comment">// Game loop</span>
bool gameOver = false;
while (!gameOver) {
   <span class="color-comment">// play the game</span>
   ......
   <span class="color-comment">// Update the game state 
   // Set gameOver to true if appropriate to exit the game loop</span>
   ......
}</pre>

<p><span class="line-heading">Example (Counter-Controlled Loop):</span> Prompt user for an upperbound. Sum the integers from 1 to a given upperbound and compute its average.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Sum from 1 to a given upperbound and compute their average (SumNumbers.cpp)
 */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int sum = 0;     <span class="color-comment">// Store the accumulated sum</span>
   int upperbound;
   cout &lt;&lt; &quot;Enter the upperbound: &quot;;
   cin &gt;&gt; upperbound;
 
   <span class="color-comment">// Sum from 1 to the upperbound</span>
   for (int number = 1; number &lt;= upperbound; ++number) {
      sum += number;
   }
   cout &lt;&lt; &quot;Sum is &quot; &lt;&lt; sum &lt;&lt; endl;
   cout &lt;&lt; &quot;Average is &quot; &lt;&lt; (double)sum / upperbound &lt;&lt; endl;
 
   <span class="color-comment">// Sum only the odd numbers</span>
   int count = 0;     <span class="color-comment">// counts of odd numbers</span>
   sum = 0;           <span class="color-comment">// reset sum</span>
   for (int number=1; number &lt;= upperbound; number=number+2) {
      ++count;
      sum += number;
   }
   cout &lt;&lt; &quot;Sum of odd numbers is &quot; &lt;&lt; sum &lt;&lt; endl;
   cout &lt;&lt; &quot;Average is &quot; &lt;&lt; (double)sum / count &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading">Example (Sentinel-Controlled Loop):</span> Prompt user for positive integers, and display the count, maximum, minimum and average. Terminate when user enters -1.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Prompt user for positive integers and display the count, maximum,
   minimum and average. Terminate the input with -1 (StatNumbers.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;climits&gt; <span class="color-comment"> // for INT_MAX</span>
#include &lt;iomanip&gt; <span class="color-comment"> // for setprecision(n)</span>
using namespace std;
 
int main() {
   int numberIn;     <span class="color-comment"> // input number (positive integer)</span>
   int count = 0;    <span class="color-comment"> // count of inputs, init to 0</span>
   int sum = 0;      <span class="color-comment"> // sum of inputs, init to 0</span>
   int max = 0;      <span class="color-comment"> // max of inputs, init to minimum</span>
   int min = INT_MAX;<span class="color-comment"> // min of inputs, init to maximum (need &lt;climits&gt;)</span>
   int sentinel = -1;<span class="color-comment"> // Input terminating value</span>
 
  <span class="color-comment"> // Read Inputs until sentinel encountered</span>
   cout &lt;&lt; &quot;Enter a positive integer or &quot; &lt;&lt; sentinel &lt;&lt; &quot; to exit: &quot;;
   while (cin &gt;&gt; numberIn &amp;&amp; numberIn != sentinel) {
     <span class="color-comment"> // Check input for positive integer</span>
      if (numberIn &gt; 0) {
         ++count;
         sum += numberIn;
         if (max &lt; numberIn) max = numberIn;
         if (min &gt; numberIn) min = numberIn;
      } else {
         cout &lt;&lt; &quot;error: input must be positive! try again...&quot; &lt;&lt; endl;
      }
      cout &lt;&lt; &quot;Enter a positive integer or &quot; &lt;&lt; sentinel &lt;&lt; &quot; to exit: &quot;;
   }
 
  <span class="color-comment"> // Print result</span>
   cout &lt;&lt; endl;
   cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; endl;
   if (count &gt; 0) {
      cout &lt;&lt; &quot;Maximum is &quot; &lt;&lt; max &lt;&lt; endl;
      cout &lt;&lt; &quot;Minimum is &quot; &lt;&lt; min &lt;&lt; endl;
      cout &lt;&lt; fixed &lt;&lt; setprecision(2);
      <span class="color-comment"> // print floating point to 2 decimal places (need &lt;iomanip&gt;)</span>
      cout &lt;&lt; &quot;Average is &quot; &lt;&lt; (double)sum / count &lt;&lt; endl;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes</p>

<ul>
<li>In computing, a <em>sentinel value</em> is a special value that indicates the end of data (e.g., a negative value to end a sequence of positive value, end-of-file, null character in the null-terminated string). In this example, we use -1 as the sentinel value to indicate the end of inputs, which is a sequence of positive integers. Instead of hardcoding the value of -1, we use a variable called <code>sentinel</code> for flexibility and ease-of-maintenance.</li>
<li>Take note of the <em>while-loop pattern</em> in reading the inputs.  In this pattern, you need to <em>repeat</em> the prompting statement.</li>
<li>To control the precision of floating point numbers, use:
  <pre class="color-example-light">
cout &lt;&lt; fixed &lt;&lt; setprecision(n);</pre>
where n is the number of decimal places (after the decimal point). You need to include <code>&lt;iomanip&gt;</code> header. The <code>setprecision()</code> is <em>sticky</em>. That is, it will remain in effect until another value is set.</li>
</ul>

<h5>Exercises</h5>
<p>[TODO]</p>

<h4>Interrupting Loop Flow - &quot;<span class="font-code">break</span>&quot; and &quot;<span class="font-code">continue</span>&quot;</h4>
<p>The <code>break</code> statement breaks out and exits the current (innermost) loop.</p>
<p>The <code>continue</code> statement aborts the current iteration and continue to the next iteration of the current (innermost) loop.</p>
<p><code>break</code> and <code>continue</code> are poor structures as they are hard to read and hard to follow.  Use them only if absolutely necessary.  You can always write the same program without using <code>break</code> and <code>continue</code>.</p>

<p><span class="line-heading">Example (<span class="font-code">break</span>):</span> The following program lists the non-prime numbers between 2 and an upperbound.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  List non-prime from 1 to an upperbound (NonPrimeList.cpp).
 */</span>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
 
int main() {
   int upperbound;
   cout &lt;&lt; &quot;Enter the upperbound: &quot;;
   cin &gt;&gt; upperbound;
   for (int number = 2; number &lt;= upperbound; ++number) {
      <span class="color-comment">// Not a prime, if there is a factor between 2 and sqrt(number)</span>
      int maxFactor = (int)sqrt(number);
      for (int factor = 2; factor &lt;= maxFactor; ++factor) {
         if (number % factor == 0) {   <span class="color-comment">// Factor?</span>
            cout &lt;&lt; number &lt;&lt; &quot; &quot;;
            break;   <span class="color-comment">// A factor found, no need to search for more factors</span>
         }
      }
   }
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Let's rewrite the above program to list all the primes instead. A <code>boolean</code> flag called <code>isPrime</code> is used to indicate whether the current <code>number</code> is a prime. It is then used to control the printing.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  List primes from 1 to an upperbound (PrimeListWithBreak.cpp).
 */</span>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
 
int main() {
   int upperbound;
   cout &lt;&lt; &quot;Enter the upperbound: &quot;;
   cin &gt;&gt; upperbound;
   for (int number = 2; number &lt;= upperbound; ++number) {
      <span class="color-comment">// Not a prime, if there is a factor between 2 and sqrt(number)</span>
      int maxFactor = (int)sqrt(number);
      bool isPrime = true;  <span class="color-comment">// boolean flag to indicate whether number is a prime</span>
      for (int factor = 2; factor &lt;= maxFactor; ++factor) {
         if (number % factor == 0) {   <span class="color-comment">// Factor?</span>
            isPrime = false;   <span class="color-comment">// number is not a prime</span>
            break;   <span class="color-comment">// A factor found, no need to search for more factors</span>
         }
      }
      if (isPrime) cout &lt;&lt; number &lt;&lt; &quot; &quot;;
   }
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Let's rewrite the above program without using <code>break</code> statement. A <code>while</code> loop is used (which is controlled by the <code>boolean</code> flag) instead of <code>for</code> loop with <code>break</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  List primes from 1 to an upperbound (PrimeList.cpp).
 */</span>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
 
int main() {
   int upperbound;
   cout &lt;&lt; &quot;Enter the upperbound: &quot;;
   cin &gt;&gt; upperbound;
 
   for (int number = 2; number &lt;= upperbound; ++number) {
      <span class="color-comment">// Not prime, if there is a factor between 2 and sqrt of number</span>
      int maxFactor = (int)sqrt(number);
      bool isPrime = true;
      int factor = 2;
      while (isPrime &amp;&amp; factor &lt;= maxFactor) {
         if (number % factor == 0) {   <span class="color-comment">// Factor of number?</span>
             isPrime = false;
         }
         ++factor;
      }
      if (isPrime) cout &lt;&lt; number &lt;&lt; &quot; &quot;;
   }
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading">Example (<span class="font-code">continue</span>):</span></p>

<pre class="color-example">
<span class="color-comment">// Sum 1 to upperbound, exclude 11, 22, 33,...</span>
int upperbound = 100;
int sum = 0;
for (int number = 1; number &lt;= upperbound; ++number) {
   if (number % 11 == 0) continue;  <span class="color-comment">// Skip the rest of the loop body, continue to the next iteration
</span>   sum += number;
}
<span class="color-comment">// It is better to re-write the loop as:</span>
for (int number = 1; number &lt;= upperbound; ++number) {
   if (number % 11 != 0) sum += number;
}</pre>

<p><span class="line-heading">Example (<span class="font-code">break</span> and <span class="font-code">continue</span>):</span> Study the following program.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/* A mystery series (Mystery.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int number = 1;
   while (true) {
      ++number;
      if ((number % 3) == 0) continue;
      if (number == 133) break;
      if ((number % 2) == 0) {
         number += 3;
      } else {
         number -= 3;
      }
      cout &lt;&lt; number &lt;&lt; &quot; &quot;;
   }
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Terminating Program</h4>

<p>There are a few ways that you can terminate your program, before reaching the end of the programming statements.</p>

<p><span class="line-heading"><span class="font-code">exit()</span>:</span> You could invoke the function <code>exit(int exitCode)</code>, in <code>&lt;cstdlib&gt;</code> (ported from C's &quot;<code>stdlib.h</code>&quot;), to terminate the program and return the control to the Operating System.  By convention, return code of zero indicates normal termination; while a non-zero  <code>exitCode</code> (-1) indicates <em>abnormal termination</em>. For example,</p>

<p><span class="line-heading"><span class="font-code">abort()</span>:</span> The header <code>&lt;cstdlib&gt;</code> also provide a function called <code>abort()</code>, which can be used to terminate the program <em>abnormally</em>.</p>

<pre class="color-example">
if (errorCount &gt; 10) {
   cout &lt;&lt; &quot;too many errors&quot; &lt;&lt; endl;
   exit(-1);  <span class="color-comment">// Terminate the program
              // OR abort();</span>
}</pre>


<p><span class="line-heading">The &quot;<span class="font-code">return</span>&quot; Statement:</span> You could also use a &quot;<code>return <em>returnValue</em></code>&quot; statement in the <code>main()</code> function to terminate the program and return control back to the Operating System.
  For example,</p>
<pre class="color-example">
int <strong>main</strong>() {
   ...
   if (errorCount &gt; 10) {
      cout &lt;&lt; &quot;too many errors&quot; &lt;&lt; endl;
      return -1;  <span class="color-comment">// Terminate and return control to OS from main()</span>
   }
   ...
}</pre>

<h4>Nested Loops</h4>

<p>The following diagram illustrates a nested for-loop, i.e., an inner for-loop within an outer for-loop.</p>

<img class="image-center" src="images/NestedForLoop.png" alt="NestedForLoop.png" />

<p>Try out the following program, which prints a 8-by-8 checker box pattern using <em>nested loops</em>, as follows:</p>

<pre class="output">
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #</pre>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  Print square pattern (PrintSquarePattern.cpp).
 */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int size = 8;
   for (int row = 1; row &lt;= size; ++row) {     <span class="color-comment">// Outer loop to print all the rows</span>
      for (int col = 1; col &lt;= size; ++col) {  <span class="color-comment">// Inner loop to print all the columns of each row</span>
         cout &lt;&lt; &quot;# &quot;;
      }
      cout &lt;&lt; endl;   <span class="color-comment">// A row ended, bring the cursor to the next line</span>
   }
 
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This program contains two <em>nested</em> for-loops. The inner loop is used to print a row of eight &quot;<code># </code>&quot;, which is followed by printing a newline. The outer loop repeats the inner loop to print all the rows.</p>

<p>Suppose that you want to print this pattern  instead (in program called <code>PrintCheckerPattern.cpp</code>):</p>

<pre class="output">
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #</pre>
<p>You need to print an additional space for even-number rows.  You could do so by adding the following statement before Line 8.</p>
<pre  class="color-example">
if ((row % 2) == 0) {   <span class="color-comment">// print a leading space for even-numbered rows</span>
   cout &lt;&lt; &quot; &quot;;
}</pre>

<h5>Exercises</h5>

<ol>
<li>Print these patterns using nested loop (in a program called <code>PrintPattern1x</code>). Use a variable called <code>size</code> for the size of the pattern and try out various sizes. You should use as few printing statements as possible.
  <pre class="output">
 # * # * # * # *    # # # # # # # #    # # # # # # # #    1                                1
# * # * # * # *     # # # # # # #        # # # # # # #    2 1                            1 2
 # * # * # * # *    # # # # # #            # # # # # #    3 2 1                        1 2 3
# * # * # * # *     # # # # #                # # # # #    4 3 2 1                    1 2 3 4
 # * # * # * # *    # # # #                    # # # #    5 4 3 2 1                1 2 3 4 5
# * # * # * # *     # # #                        # # #    6 5 4 3 2 1            1 2 3 4 5 6
 # * # * # * # *    # #                            # #    7 6 5 4 3 2 1        1 2 3 4 5 6 7
# * # * # * # *     #                                #    8 7 6 5 4 3 2 1    1 2 3 4 5 6 7 8
     (a)                  (b)                (c)                (d)                (e)</pre>
    <em>Hints</em>:<br />
    The equations for major and opposite diagonals are row = col and row + col = size + 1. Decide on what to print above and below the diagonal.</li>

<li>Print the timetable of 1 to 9, as follows, using nested loop. (Hints: you need to use an <em>if-else</em> statement to check whether the product is single-digit or double-digit, and print an additional space if needed.)
<pre class="output">
 1  2  3  4  5  6  7  8  9
 2  4  6  8 10 12 14 16 18
 ...... </pre></li>
 
<li>Print these patterns using nested loop.
<pre class="output">
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
#           #        #                          #          #       #        # #       # #
#           #          #                      #              #   #          #   #   #   #
#           #            #                  #                  #            #     #     #
#           #              #              #                  #   #          #   #   #   #
#           #                #          #                  #       #        # #       # #
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
     (a)                 (b)               (c)                (d)                (e)</pre></li>
</ol>

<h4>Some Issues in Flow Control</h4>

<p><span class="line-heading">Dangling <span class="font-code">else</span>:</span> The &quot;dangling else&quot; problem can be illustrated as follows:</p>
<pre class="color-example">
if (i == 0)
   if (j == 0)
      cout &lt;&lt; &quot;i and j are zero&quot; &lt;&lt; endl;
else cout &lt;&lt; &quot;i is not zero&quot; &lt;&lt; endl;   <span class="color-comment">// intend for the outer-if</span></pre>

<p>The <code>else</code> clause in the above codes is syntactically applicable to both the outer-if and the inner-if.  The C++ compiler always associate the <code>else</code> clause with the innermost if (i.e., the nearest if).  Dangling else can be resolved by applying explicit parentheses. The above codes are logically incorrect and require explicit parentheses as shown below.</p>

<pre class="color-example">
if ( i == 0) {
   if (j == 0) cout &lt;&lt; &quot;i and j are zero&quot; &lt;&lt; endl;
} else {
   cout &lt;&lt; &quot;i is not zero&quot; &lt;&lt; endl;   <span class="color-comment">// non-ambiguous for outer-if</span>
}</pre>

<p><span class="line-heading">Endless Loop:</span> The following constructs:</p>

<pre class="color-example">
while (true) { ...... }</pre>

<p>is commonly used.  It seems to be an endless loop (or infinite loop), but it is usually terminated via a <code>break</code> or <code>return</code> statement inside the loop body. This kind of code is hard to read - avoid if possible by re-writing the condition.</p>

<h4>Exercises</h4>
<p>[TODO]</p>

<h3>Writing Correct and Good Programs</h3>

<p>It is important to write programs that produce the correct results.  It is also important to write programs that others (and you yourself three days later) can understand, so that the programs can be maintained - I call these programs good programs.</p>

<p>Here are the suggestions:</p>

<ul>
<li>Follow established convention so that everyone has the same basis of understanding.</li>

<li>Format and layout of the source code with appropriate indents, white spaces and white lines. Use 3 or 4 spaces for indent, and blank lines to separate sections of codes.</li>

<li>Choose good names that are self-descriptive and meaningful, e.g., <code>row</code>, <code>col</code>, <code>size</code>, <code>xMax</code>, <code>numStudents</code>. Do not use meaningless names, such as <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>. Avoid single-alphabet names (easier to type but often meaningless), except common names likes x, <code>y</code>, <code>z</code> for co-ordinates and <code>i</code> for index.</li>

<li>Provide comments to explain the important as well as salient concepts. Comment your codes liberally.</li>

<li>Write your program documentation while writing your programs.</li>

<li>Avoid <em>un-structured</em> constructs, such as <code>break</code> and <code>continue</code>, which are hard to follow.</li>

<li> Use &quot;mono-space&quot; fonts (such as Consola, Courier New, Courier) for writing/displaying your program.</li>
</ul>

<h5>Programming Errors</h5>

<p>There are generally three classes of programming errors:</p>

<ol>
<li><em>Compilation Error</em> (or <em>Syntax Error</em>): can be fixed easily.</li>

<li><em>Runtime Error</em>: program halts pre-maturely without producing the results - can also be fixed easily.</li>

<li><em>Logical Error</em>: program completes but produces incorrect results. It is easy to detect if the program always produces wrong result. It is extremely hard to fix if the program produces the correct result most of the times, but incorrect result sometimes. For example,

<pre class="color-example">
<span class="color-comment">// Can compile and execute, but give wrong result – sometimes!</span>
if (mark &gt; 50) {
   cout &lt;&lt; &quot;PASS&quot; &lt;&lt; endl;
} else {
   cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;
}</pre>
This kind of errors is very serious if it is not caught before production. Writing good programs helps in minimizing and detecting these errors. A good <em>testing strategy</em> is needed to ascertain the correctness of the program. <em>Software testing</em> is an advanced topics which is beyond our current scope.</li>
</ol>

<h5>Debugging Programs</h5>

<p>Here are the common debugging techniques:</p>

<ol>
<li>Stare at the screen! Unfortunately, errors usually won't pop-up even if you stare at it extremely hard.</li>

<li>Study the error messages! Do not close the console when error occurs and pretending that everything is fine. This helps most of the times.</li>

<li>Insert print statements at appropriate locations to display the intermediate results. It works for simple toy program, but it is neither effective nor efficient for complex program.</li>

<li>Use a graphic debugger. This is the most effective means. Trace program execution step-by-step and watch the value of variables and outputs.</li>

<li>Advanced tools such as profiler (needed for checking memory leak and function usage).</li>

<li>Proper program testing to wipe out the logical errors.</li>
</ol>

<h5>Testing Your Program for Correctness</h5>

<p>How to ensure that your program always produces correct result, 100% of the times? It is impossible to try out all the possible outcomes, even for a simple program. Program testing usually involves a set of representative test cases, which are designed to catch the major classes of errors.  Program testing is beyond the scope of this writing.</p>

<h3>Strings</h3>

<p>C++ supports two types of strings:</p>

<ol>
<li>the original C-style string: A string is a <code>char</code> array, terminated with a <code>NULL</code> character <code>'\0'</code> (Hex <code>0</code>). It is also called Character-String or C-style string. C-string will be discussed <a href="#cstring">later</a>.</li>

<li>the new <code>string</code> class introduced in C++98.</li>
</ol>

<p>The &quot;high-level&quot; <code>string</code> class is recommended, because it is much easier to use and understood. However, many legacy programs used C-strings; many programmers also use &quot;low-level&quot; C-strings for full control and efficiency; furthermore, in some situation such as command-line arguments, only C-strings are supported. Hence, you may have to understand both sets of strings. However, avoid C-string unless it is absolutely necessary.</p>

<p>We shall describe <code>string</code> class here, and C-string later.</p>

<h4>String Declaration and Initialization</h4>

<p>To use the <code>string</code> class, include the <code>&lt;string&gt;</code> header and &quot;<code>using namespace std</code>&quot;.</p>
<p>You can declare and (a) initialize a string with a string literal, (b) initialize to an empty string, or (c) initialize with another string object. For example,</p>

<pre class="color-example">
#include &lt;string&gt;
using namespace std;
 
string str1(&quot;Hello&quot;);  <span class="color-comment">// Initialize with a string literal (Implicit initialization)</span>
string str2 = &quot;world&quot;; <span class="color-comment">// Initialize with a string literal (Explicit initialization via assignment operator)</span>
string str3;           <span class="color-comment">// Initialize to an empty string</span>
string str4(str1);     <span class="color-comment">// Initialize by copying from an existing string object</span></pre>

<h4>String Input/Output</h4>

<p>For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing string class input and output (TestStringIO.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;string&gt;    <span class="color-comment"> // Need this header to use string class</span>
#include &lt;limits&gt;
using namespace std; <span class="color-comment"> // Also needed for &lt;string&gt;</span>
 
int main() {
   string message(&quot;Hello&quot;);
   cout &lt;&lt; message &lt;&lt; endl;
 
  <span class="color-comment"> // Input a word (delimited by space) into a string</span>
   cout &lt;&lt; &quot;Enter a message (no space): &quot;;
   cin &gt;&gt; message;
   cout &lt;&lt; message &lt;&lt; endl;
 
   cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
      <span class="color-comment">// flush cin up to newline (need &lt;limits&gt; header)</span>
 
  <span class="color-comment"> // Input a line into a string</span>
   cout &lt;&lt; &quot;Enter a message (with spaces): &quot;;
   getline(cin, message); <span class="color-comment"> // Read input from cin into message</span>
   cout &lt;&lt; message &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>NOTES:</p>

<ul>
<li>We need to &quot;<code>#include &lt;string&gt;</code>&quot; to use the <code>string</code> class, and &quot;<code>using namespace std</code>&quot; as <code>string</code> is defined under <code>std</code> namespace.</li>

<li>&quot;<code>cin &gt;&gt; <em>aStr</em></code>&quot; reads a word (delimited by space) from <code>cin</code> (keyboard), and assigns to <code>string</code> variable <code><em>aStr</em></code>.</li>

<li><code>getline(cin, <em>aStr</em>)</code> reads the entire line (up to <code>'\n'</code>) from <code>cin</code>, and assigns to <code><em>aStr</em></code>. The <code>'\n'</code> character is discarded.</li>

<li>To flush <code>cin</code>, you could use <code>ignore(numeric_limits&lt;streamsize&gt;::max(), '\n')</code> function to discard all the characters up to <code>'\n'</code>. <code>numeric_limits</code> is in the <code>&lt;limits&gt;</code> header.</li>
</ul>

<h4>String Operations</h4>


<ul>
<li>Checking the length of a string:
<pre class="color-syntax">
<strong>int length();</strong>
<strong>int size();</strong>
   both of them return the length of the string</pre>
<pre class="color-example">
#include &lt;string&gt;
string str(&quot;Hello, world&quot;);
cout &lt;&lt; str.length() &lt;&lt; endl;  <span class="color-comment">// 12</span>
cout &lt;&lt; str.size()   &lt;&lt; endl;  <span class="color-comment">// 12</span></pre>
</li>

<li>Check for empty string:
  <pre class="color-syntax">
<strong>bool empty();</strong>
   Check if the string is empty.</pre>
<pre class="color-example">
string str1(&quot;Hello, world&quot;);
string str2;                   <span class="color-comment">// Empty string</span>
cout &lt;&lt; str1.empty() &lt;&lt; endl;  <span class="color-comment">// 0 (false)</span>
cout &lt;&lt; str2.empty() &lt;&lt; endl;  <span class="color-comment">// 1 (true)</span></pre>
</li>

<li>Copying from another string: Simply use the assignment (<code>=</code>) operator.
  <pre class="color-example">string str1(&quot;Hello, world&quot;), str2;
str2 = str1;
cout &lt;&lt; str2 &lt;&lt; endl;   <span class="color-comment">// Hello, world</span></pre>
</li>

<li>Concatenated with another string: Use the plus (+) operator, or compound plus (<code>+=</code>) operator.
  <pre class="color-example">
string str1(&quot;Hello,&quot;);
string str2(&quot; world&quot;);
cout &lt;&lt; str1 + str2 &lt;&lt; endl;  <span class="color-comment">// &quot;Hello, world&quot;</span>
cout &lt;&lt; str1 &lt;&lt; endl;         <span class="color-comment">// &quot;Hello,&quot;</span>
cout &lt;&lt; str2 &lt;&lt; endl;         <span class="color-comment">// &quot; world&quot;</span>
str1 += str2;
cout &lt;&lt; str1 &lt;&lt; endl;  <span class="color-comment">// &quot;Hello, world&quot;</span>
cout &lt;&lt; str2 &lt;&lt; endl;  <span class="color-comment">// &quot; world&quot;</span>
string str3 = str1 + str2;
cout &lt;&lt; str3 &lt;&lt; endl;  <span class="color-comment">// &quot;Hello, world world&quot;</span>
str3 += &quot;again&quot;;
cout &lt;&lt; str3 &lt;&lt; endl;  <span class="color-comment">// &quot;Hello, world worldagain&quot;</span>
</pre>
</li>

<li>Read/Write individual character of a string:
<pre class="color-syntax">
<strong>char&amp; at(int <em>index</em>);</strong>
   Return the char at index, index begin at 0. Perform index bound check.
<strong>
[]
   </strong>indexing (subscript) operator, no index bound check</pre>
<pre class="color-example">
string str(&quot;Hello, world&quot;);
cout &lt;&lt; str.at(0) &lt;&lt; endl;  <span class="color-comment">// 'H'</span>
cout &lt;&lt; str[1] &lt;&lt; endl;     <span class="color-comment">// 'e'</span>
cout &lt;&lt; str.at(str.length() - 1) &lt;&lt; endl;  <span class="color-comment">// 'd'</span>

str.at(1) = 'a';  <span class="color-comment">// Write to index 1</span>
cout &lt;&lt; str &lt;&lt; endl;  <span class="color-comment">// &quot;Hallo, world&quot;</span>

str[0] = 'h';
cout &lt;&lt; str &lt;&lt; endl;  <span class="color-comment">// &quot;hallo, world&quot;</span>
</pre>
</li>

<li>Extracting sub-string:
<pre class="color-syntax">
<strong>string substr(int <em>beginIndex</em>, int <em>size</em>);
   </strong>Return the sub-string starting at <em>beginIndex</em>, of <em>size</em></pre>
<pre class="color-example">
string str(&quot;Hello, world&quot;);
cout &lt;&lt; str.substr(2, 6) &lt;&lt; endl;  <span class="color-comment">// &quot;llo, w&quot;</span></pre>
</li>

<li>Comparing with another string:
<pre class="color-syntax"><strong>int compare(string another)</strong>;
   Compare the content of this string with the given another. 
   Return 0 if equals; a negative value if this string is less than another; positive value otherwise.

<strong>==</strong> and <strong>!=</strong> Operators
   Compare the contents of two strings</pre>
   
<pre class="color-example">
string str1(&quot;Hello&quot;), str2(&quot;Hallo&quot;), str3(&quot;hello&quot;), str4(&quot;Hello&quot;);
cout &lt;&lt; str1.compare(str2) &lt;&lt; endl;   <span class="color-comment">// 1   'e' &gt; 'a'</span>
cout &lt;&lt; str1.compare(str3) &lt;&lt; endl;   <span class="color-comment">// -1  'h' &lt; 'H'</span>
cout &lt;&lt; str1.compare(str4) &lt;&lt; endl;   <span class="color-comment">// 0</span>
 
<span class="color-comment">// You can also use the operator == or !=</span>
if (str1 == str2) cout &lt;&lt; &quot;Same&quot; &lt;&lt; endl;
if (str3 != str4) cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;
cout &lt;&lt; boolalpha;  // print bool as true/false
cout &lt;&lt; (str1 != str2) &lt;&lt; endl;
cout &lt;&lt; (str1 == str4) &lt;&lt; endl;</pre></li>

<li>Search/Replacing characters: You can use the functions available in the <code>&lt;algorithm&gt;</code> such as <code>replace()</code>. For example,
<pre class="color-example">
#include &lt;algorithm&gt;
......
string str(&quot;Hello, world&quot;);
replace(str.begin(), str.end(), 'l', '_');
cout &lt;&lt; str &lt;&lt; endl;      <span class="color-comment">// &quot;He__o, wor_d&quot;</span>
</pre></li>

<li>Many others.</li>
</ul>

<h5>Example 1:</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Example on C++ string function (TestStringOp.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;string&gt;   <span class="color-comment"> // use string class</span>
using namespace std;
 
int main() {
   string msg = &quot;hello, world!&quot;;
   cout &lt;&lt; msg &lt;&lt; endl;
   cout &lt;&lt; msg.length() &lt;&lt; endl; <span class="color-comment"> // length of string</span>
   cout &lt;&lt; msg.at(1) &lt;&lt; endl;    <span class="color-comment"> // char at index 1</span>
   cout &lt;&lt; msg[1] &lt;&lt; endl;       <span class="color-comment"> // same as above</span>
   cout &lt;&lt; msg.empty() &lt;&lt; endl;  <span class="color-comment"> // test for empty string</span>
   cout &lt;&lt; msg.substr(3, 3) &lt;&lt; endl;<span class="color-comment"> // sub-string begins at</span>
                                    <span class="color-comment"> // pos 3 of size 3</span>
   cout &lt;&lt; msg.replace(3, 3, &quot;why&quot;) &lt;&lt; endl;<span class="color-comment"> // replace sub-string</span>
   cout &lt;&lt; msg.append(&quot;end&quot;) &lt;&lt; endl;       <span class="color-comment"> // append behind</span>
   cout &lt;&lt; msg + &quot;end&quot; &lt;&lt; endl;             <span class="color-comment"> // same as above</span>
   cout &lt;&lt; msg.insert(3, &quot;insert&quot;) &lt;&lt; endl; <span class="color-comment"> // insert after pos 3</span>
 
   string msg1;
   msg1 = msg;  <span class="color-comment"> // copy</span>
   cout &lt;&lt; msg1 &lt;&lt; endl;
 
   cout &lt;&lt; &quot;Enter a line: &quot;;
   getline(cin, msg);  <span class="color-comment"> // read a line of input</span>
   cout &lt;&lt; msg &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Example 2:</h5>

<p>[TODO]</p>

<h4>Exercises</h4>

<p>[TODO]</p>

<h3>Formatting Input/Output using IO Manipulators (Header <span class="font-code">&lt;iomanip&gt;</span>)</h3>

<p>The <code>&lt;iomanip&gt;</code> header provides so-called I/O manipulators for formatting input and output:</p>

<ul>
<li><code>setw(int <em>field-widht</em>)</code>: set the <em>field width</em> for the <em>next</em> IO operation. <code>setw()</code> is <em>non-sticky</em> and must be issued prior to each IO operation. The field width is reset to the default after each operation (with just enough width to accommodate the field).<br />
</li>

<li><code>setfill(char <em>fill-char</em>)</code>: set the filled character for padding to the <em>field width</em>.</li>
<li><code>left|right|internal</code>: set the alignment</li>

<li><code>fixed/scientific</code> (for floating-point numbers): use fixed-point notation (e.g, 12.34) or scientific notation (e.g., 1.23e+006).</li>

<li><code>setprecision(int <em>numDecimalDigits</em>)</code> (for floating-point numbers): specify the number of digits after the decimal point.</li>

<li><code>boolalpha</code>/<code>noboolalpha</code> (for <code>bool</code>): display <code>bool</code> values as alphabetic string (true/false) or 1/0.</li>
</ul>

<h4>Output Formatting</h4>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Formatting Output (TestFormattedOutput.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;    <span class="color-comment">// Needed to do formatted I/O</span>
using namespace std;
 
int main() {
   <span class="color-comment">// Floating point numbers</span>
   double pi = 3.14159265;
   cout &lt;&lt; fixed &lt;&lt; setprecision(4); <span class="color-comment">// fixed format with 4 decimal places</span>
   cout &lt;&lt; pi &lt;&lt; endl;
   cout &lt;&lt; &quot;|&quot; &lt;&lt; setw(8) &lt;&lt; pi &lt;&lt; &quot;|&quot; &lt;&lt; setw(10) &lt;&lt; pi &lt;&lt; &quot;|&quot; &lt;&lt; endl;
      <span class="color-comment">// setw() is not sticky, only apply to the next operation.</span>
   cout &lt;&lt; setfill('-');
   cout &lt;&lt; &quot;|&quot; &lt;&lt; setw(8) &lt;&lt; pi &lt;&lt; &quot;|&quot; &lt;&lt; setw(10) &lt;&lt; pi &lt;&lt; &quot;|&quot; &lt;&lt; endl;
   cout &lt;&lt; scientific;  <span class="color-comment">// in scientific format with exponent</span>
   cout &lt;&lt; pi &lt;&lt; endl;
 
   <span class="color-comment">// booleans</span>
   bool done = false;
   cout &lt;&lt; done &lt;&lt; endl;  <span class="color-comment">// print 0 (for false) or 1 (for true)</span>
   cout &lt;&lt; boolalpha;     <span class="color-comment">// print true or false</span>
   cout &lt;&lt; done &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Input Formatting</h4>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Formatting Input (TestFormattedInput.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using namespace std;
 
int main() {
   string areaCode, phoneCode;
   string inStr;
 
   cout &lt;&lt; &quot;Enter your phone number in this format (xxx)xxx-xxxx : &quot;;
   cin.ignore();   <span class="color-comment">// skip '('</span>
   cin &gt;&gt; setw(3) &gt;&gt; areaCode;
   cin.ignore();   <span class="color-comment">// skip ')'</span>
   cin &gt;&gt; setw(3) &gt;&gt; phoneCode;
   cin.ignore();   <span class="color-comment">// skip '-'</span>
   cin &gt;&gt; setw(4) &gt;&gt; inStr;
   phoneCode += inStr;
 
   cout &lt;&lt; &quot;Phone number is (&quot; &lt;&lt; areaCode &lt;&lt; &quot;)&quot;
        &lt;&lt; phoneCode.substr(0, 3) &lt;&lt; &quot;-&quot;
        &lt;&lt; phoneCode.substr(3, 4) &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Exercises</h4>

<p>[TODO]</p>

<h3>Arrays</h3>

<h4>Array Declaration and Usage</h4>

<p>Suppose that you want to find the average of the marks for a class of 30 students, you certainly do not want to create 30 variables: <code>mark1</code>, <code>mark2</code>, ..., <code>mark30</code>. Instead, You could use a single variable, called an <em>array</em>, with 30 elements.</p>

<p>An array is <em>a list of elements of the same type</em>, identified by a pair of square brackets <code>[ ]</code>.  To use an array, you need to <em>declare</em> the array with 3 things: a <em>name,</em> a <em>type</em> and a <em>dimension</em> (or <em>size</em>, or <em>length</em>). The syntax is:</p>

<pre class="color-syntax">
<em>type</em> <em>arrayName</em>[<em>arraylength</em>];  <span class="color-comment">// arraylength can be a literal or a variable</span></pre>

<p> I recommend using a plural name for array, e.g., <code>marks</code>, <code>rows</code>, <code>numbers</code>. For example,</p>

<pre class="color-example">
int marks[5];        <span class="color-comment">// Declare an int array called marks with 5 elements</span>
double numbers[10]; <span class="color-comment"> // Declare an double array of 10 elements</span>
const int SIZE = 9;
float temps[SIZE];   <span class="color-comment">// Use const int as array length</span>
<span class="color-comment">
// Some compilers support an variable as array length, e.g.,
</span><span class="color-comment"></span>int size;
cout &lt;&lt; &quot;Enter the length of the array: &quot;;
cin &gt;&gt; size;
float values[size];</pre>

<p>Take note that, in C++, the value of the elements are undefined after declaration.</p>

<p>You can also initialize the array during declaration with a comma-separated list of values, as follows:</p>

<pre class="color-example">
<span class="color-comment">// Declare and initialize an int array of 3 elements</span>
int numbers[3] = {11, 33, 44};
<span class="color-comment">// If length is omitted, the compiler counts the elements</span>
<span class="color-comment"></span>int numbers[] = {11, 33, 44};
<span class="color-comment">// Number of elements in the initialization shall be equal to or less than length</span>
int numbers[5] = {11, 33, 44};  <span class="color-comment">// Remaining elements are zero. Confusing! Don't do this</span>
int numbers[2] = {11, 33, 44};  <span class="color-comment">// ERROR: too many initializers</span>
<span class="color-comment">
// Use {0} or {} to initialize all elements to 0</span>
<strong>int numbers[5] = {0};</strong>  <span class="color-comment">// First element to 0, the rest also to zero</span>
<strong>int numbers[5] = {};</strong>   <span class="color-comment">// All element to 0 too</span></pre>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test local array initialization (TestArrayInit.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int const SIZE = 5;
 
   int a1[SIZE];  <span class="color-comment"> // Uninitialized</span>
   for (int i = 0; i &lt; SIZE; ++i) cout &lt;&lt; a1[i] &lt;&lt; &quot; &quot;;
   cout &lt;&lt; endl;  <span class="color-comment"> // ? ? ? ? ?</span>
 
   int a2[SIZE] = {21, 22, 23, 24, 25};<span class="color-comment"> // All elements initialized</span>
   for (int i = 0; i &lt; SIZE; ++i) cout &lt;&lt; a2[i] &lt;&lt; &quot; &quot;;
   cout &lt;&lt; endl;  <span class="color-comment"> // 21 22 23 24 25</span>
 
   int a3[] = {31, 32, 33, 34, 35};  <span class="color-comment"> // Size deduced from init values</span>
   int a3Size = sizeof(a3)/sizeof(int);
   cout &lt;&lt; &quot;Size is &quot; &lt;&lt; a3Size &lt;&lt; endl;  <span class="color-comment"> // 5</span>
   for (int i = 0; i &lt; a3Size; ++i) cout &lt;&lt; a3[i] &lt;&lt; &quot; &quot;;
   cout &lt;&lt; endl;  <span class="color-comment"> // 31 32 33 34 35</span>
 
   int a4[SIZE] = {41, 42}; <span class="color-comment"> // Leading elements initialized, the rests to 0</span>
   for (int i = 0; i &lt; SIZE; ++i) cout &lt;&lt; a4[i] &lt;&lt; &quot; &quot;;
   cout &lt;&lt; endl;  <span class="color-comment"> // 41 42 0 0 0</span>
 
   int a5[SIZE] = {0}; <span class="color-comment"> // First elements to 0, the rests to 0 too</span>
   for (int i = 0; i &lt; SIZE; ++i) cout &lt;&lt; a5[i] &lt;&lt; &quot; &quot;;
   cout &lt;&lt; endl;  <span class="color-comment"> // 0 0 0 0 0</span>
 
   int a6[SIZE] = {};  <span class="color-comment"> // All elements to 0 too</span>
   for (int i = 0; i &lt; SIZE; ++i) cout &lt;&lt; a6[i] &lt;&lt; &quot; &quot;;
   cout &lt;&lt; endl;  <span class="color-comment"> // 0 0 0 0 0</span>
}</pre>
</td>
</tr>
</tbody>
</table>


<p>You can refer to an element of an array via an index (or subscript) enclosed within the square bracket <code>[ ]</code>.  C++'s array index begins with zero. For example, suppose that <code>marks</code> is an <code>int</code> array of 5 elements, then the 5 elements are: <code>marks[0]</code>, <code>marks[1]</code>, <code>marks[2]</code>, <code>marks[3]</code>, and <code>marks[4]</code>.</p>

<pre class="color-example">
<span class="color-comment">// Declare &amp; allocate a 5-element int array</span>
int marks[5];
<span class="color-comment">// Assign values to the elements</span>
marks[0] = 95;
marks[1] = 85;
marks[2] = 77;
marks[3] = 69;
marks[4] = 66;
cout &lt;&lt; marks[0] &lt;&lt; endl;
cout &lt;&lt; marks[3] + marks[4] &lt;&lt; endl;</pre>

<img class="image-center" src="images/Array.png" alt="Array.png" />

<p>To create an array, you need to known the length (or size) of the array in advance, and allocate accordingly.  Once an array is created, its length is fixed and cannot be changed. At times, it is hard to ascertain the length of an array (e.g., how many students in a class?). Nonetheless, you need to estimate the length and allocate an upper bound. This  is probably the major drawback of using an array. C++ has a <code>vector</code> template class (and C++11 added an <code>array</code> template class), which supports dynamic resizable array.</p>

<p>You can find the array length using expression <code>sizeof(<em>arrayName</em>)/sizeof(<em>arrayName</em>[0])</code>, where <code>sizeof(<em>arrayName</em>)</code> returns the total bytes of the array and <code>sizeof(<em>arrayName</em>[0])</code> returns the bytes of first element.</p>
<p>C/C++ does not perform array <em>index-bound check</em>.  In other words, if the index is beyond the array's bounds, it does not issue a warning/error. For example,</p>

<pre class="color-example">
const int size = 5;
int numbers[size];  <span class="color-comment">// array index from 0 to 4</span>
 
<span class="color-comment">// Index out of bound!
// Can compiled and run, but could pose very serious side effect!</span>
<span class="color-error">numbers[88]</span> = 999;
cout &lt;&lt; <span class="color-error">numbers[77]</span> &lt;&lt; endl;
</pre>

<p> This is another pitfall of C/C++. Checking the index bound consumes computation power and depicts the performance. However, it is better to be safe than fast. Newer programming languages such as Java/C# performs array index bound check.</p>

<h4>Array and Loop</h4>

<p>Arrays works hand-in-hand with loops. You can process all the elements of an array via a loop, for example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  Find the mean and standard deviation of numbers kept in an array (MeanStdArray.cpp).
 */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cmath&gt;
#define SIZE 7
using namespace std;
 
int main() {
   int marks[] = {74, 43, 58, 60, 90, 64, 70};
   int sum = 0;
   int sumSq = 0;
   double mean, stdDev;
   for (int i = 0; i &lt; SIZE; ++i) {
      sum += marks[i];
      sumSq += marks[i]*marks[i];
   }
   mean = (double)sum/SIZE;
   cout &lt;&lt; fixed &lt;&lt; &quot;Mean is &quot; &lt;&lt; setprecision(2) &lt;&lt; mean &lt;&lt; endl;
 
   stdDev = sqrt((double)sumSq/SIZE - mean*mean);
   cout &lt;&lt; fixed &lt;&lt; &quot;Std dev is &quot; &lt;&lt; setprecision(2) &lt;&lt; stdDev &lt;&lt; endl;
 
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Exercises</h5>
<p>[TODO]</p>

<h4>Range-based for loop (C++11)</h4>

<p>C++11 introduces a range-based for loop (or for-each loop) to iterate thru an array, as illustrated in the following example:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing For-each loop (TestForEach.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   int numbers[] = {11, 22, 33, 44, 55};

   <span class="color-comment">// For each member called number of array numbers - read only</span> 
   for (int number : numbers) {
      cout &lt;&lt; number &lt;&lt; endl;
   }
 
   <span class="color-comment">// To modify members, need to use reference (&amp;)
</span>   for (int &amp;number : numbers) {
      number = 99;
   }
 
   for (int number : numbers) {
      cout &lt;&lt; number &lt;&lt; endl;
   }
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>To compile the program under GNU GCC (g++), you may need to specify option <code>-std=c++0x</code> or <code>-std=c++11</code>:</p>
<pre class="color-command">
g++ <strong>-std=c++0x</strong> -o TestForEach.exe TestForEach.cpp
<span class="color-comment">// or</span>
g++ <strong>-std=c++11</strong> -o TestForEach.exe TestForEach.cpp</pre>

<h4>Multi-Dimensional Array</h4>
<p>For example,</p>
<pre class="color-example">int[2][3] = { {11, 22, 33}, {44, 55, 66} };</pre>

<img class="image-center" src="images/Array2D.png" alt="Array2D.png" />

<p>For 2D array (table), the first index is the row number, second index is the column number. The elements are stored in a so-called <em>row-major</em> manner, where the column index runs out first.</p>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Multi-dimensional Array (Test2DArray.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
void printArray(const int[][3], int);
 
int main() {
   int myArray[][3] = {{8, 2, 4}, {7, 5, 2}}; <span class="color-comment">// 2x3 initialized</span>
                 <span class="color-comment">// Only the first index can be omitted and implied</span>
   printArray(myArray, 2);
   return 0;
}
 
<span class="color-comment">// Print the contents of rows-by-3 array (columns is fixed)</span>
void printArray(const int array[][3], int rows) {
   for (int i = 0; i &lt; rows; ++i) {
      for (int j = 0; j &lt; 3; ++j) {
         cout &lt;&lt; array[i][j] &lt;&lt; &quot; &quot;;
      }
      cout &lt;&lt; endl;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4 id="cstring">Array of Characters - C-String</h4>

<p>In C, a string is a <code>char</code> array terminated by a NULL character <code>'\0'</code> (ASCII code of Hex <code>0</code>). C++ provides a new <code>string</code> class under header <code>&lt;string&gt;</code>. The original string in C is known as C-String (or C-style String or Character String). You could allocate a C-string via:</p>
<pre class="color-example">
char message[256];     <span class="color-comment">// Declare a char array 
                       // Can hold a C-String of up to 255 characters terminated by '\0'</span>
char str1[] = &quot;Hello&quot;; <span class="color-comment">// Declare and initialize with a &quot;string literal&quot;.
                       // The length of array is number of characters + 1 (for '\0').</span>
char str1char[] = {'H', 'e', 'l', 'l', 'o', '\0'};  <span class="color-comment">// Same as above</span>
char str2[256] = &quot;Hello&quot;;  <span class="color-comment">// Length of array is 256, keeping a smaller string.</span></pre>

<p>For novices, avoid C-string. Use C++ <code>string</code> (in header <code>&lt;string&gt;</code>) discussed earlier.</p>

<h5>Example</h5>
<p>You can use <code>cin</code> and <code>cout</code> to handle C-strings.</p>

<ul>
<li><code>cin &lt;&lt;</code> reads a string delimited by whitespace;</li>

<li><code>cin.getline(<em>var</em>, <em>size</em>)</code> reads a string of into <em>var</em> till newline of length up to <code>size-1</code>, discarding the newline (replaced by <code>'\0'</code>). The <code><em>size</em></code> typically corresponds to the length of the C-string array.</li>

<li><code>cin.get(<em>var</em>, <em>size</em>)</code> reads a string till newline, but leaves the newline in the input buffer.</li>

<li><code>cin.get()</code>, without argument, reads the next character.</li>
</ul>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td>
<td>
<pre>
<span class="color-comment">/* Test C-string (TestCString.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   char msg[256]; <span class="color-comment">// Hold a string of up to 255 characters (terminated by '\0')</span>
 
   cout &lt;&lt; &quot;Enter a message (with space)&quot; &lt;&lt; endl;
   cin.getline(msg, 256);  <span class="color-comment">// Read up to 255 characters into msg</span>
   cout &lt;&lt; msg &lt;&lt; endl;
 
   <span class="color-comment">// Access via null-terminated character array</span>
   for (int i = 0; msg[i] != '\0'; ++i) {
      cout &lt;&lt; msg[i];
   }
   cout &lt;&lt; endl;
 
   cout &lt;&lt; &quot;Enter a word (without space)&quot; &lt;&lt; endl;
   cin &gt;&gt; msg;
   cout &lt;&lt; msg &lt;&lt; endl;
 
   <span class="color-comment">// Access via null-terminated character array</span>
   for (int i = 0; msg[i] != '\0'; ++i) {
      cout &lt;&lt; msg[i];
   }
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Exercises</h4>

<p>[TODO]</p>

<h3>Functions</h3>

<h4>Why Functions?</h4>

<p>At times, a certain portion of codes has to be used many times. Instead of re-writing the codes many times, it is better to put them into a &quot;subroutine&quot;, and &quot;call&quot; this &quot;subroutine&quot; many time - for ease of maintenance and understanding. Subroutine is  called method (in Java) or function (in C/C++).</p>

<p>The benefits of using functions are:</p>

<ol>
<li><em>Divide and conquer</em>: construct the program from simple, small pieces or components.  Modularize the program into self-contained tasks.</li>

<li><em>Avoid repeating codes</em>: It is easy to copy and paste, but hard to maintain and synchronize all the copies.</li>

<li><em>Software Reuse</em>: you can reuse the functions in other programs, by packaging them into library codes.</li>
</ol>

<p>Two parties are involved in using a function: a <em>caller</em> who calls the function, and the <em>function</em> called. The caller passes <em>argument(s)</em> to the function.  The function receives these argument(s), performs the programmed operations within the function's body, and returns a piece of result back to the caller.</p>

<h4>Using Functions</h4>

<h5>Get Started with an Example</h5>

<p>Suppose that we need to evaluate the area of a circle many times, it is better to write a function called <code>getArea()</code>, and re-use it when needed.</p>

<img class="image-center" src="images/Function.png" alt="Function.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Function (TestFunction.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
const int PI = 3.14159265;
 
<span class="color-comment">// Function Prototype (Function Declaration)</span>
<span class="color-new">double getArea(double radius);</span>
 
int main() {
   double radius1 = 1.1, area1, area2;
  <span class="color-comment"> // call function getArea()</span>
   area1 = <span class="color-new">getArea(radius1)</span>;
   cout &lt;&lt; &quot;area 1 is &quot; &lt;&lt; area1 &lt;&lt; endl;
  <span class="color-comment"> // call function getArea()</span>
   area2 = <span class="color-new">getArea(2.2)</span>;
   cout &lt;&lt; &quot;area 2 is &quot; &lt;&lt; area2 &lt;&lt; endl;
  <span class="color-comment"> // call function getArea()</span>
   cout &lt;&lt; &quot;area 3 is &quot; &lt;&lt; <span class="color-new">getArea(3.3)</span> &lt;&lt; endl;
}
 
<span class="color-comment">// Function Definition</span>
<span class="color-comment">// Return the area of a circle given its radius</span>
<span class="color-new">double getArea(double radius) {
   return radius * radius * PI;
}</span></pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
area 1 is 3.63
area 2 is 14.52
area 3 is 32.67</pre>

<p>In the above example, a reusable function called <code>getArea()</code> is defined, which receives a parameter (in <code>double</code>) from the caller, performs the calculation, and return a piece of result (in <code>double</code>) to the caller.  In the <code>main()</code>, we invoke <code>getArea()</code> functions thrice, each time with a different parameter.</p>

<p>In C++, you need to declare a <em>function </em><em>prototype</em> (before the function is used), and provide a <em>function definition</em>, with a body containing the programmed operations.</p>

<h5>Function Definition</h5>

<p>The syntax for function definition is as follows:</p>

<pre class="color-syntax">
<em>returnValueTyp</em>e <em>functionName </em><strong>(</strong> <em>parameterList</em> <strong>) {</strong>
   <em>functionBody</em> <strong>;
}</strong></pre>

<ul>
<li>The <em>parameterList</em> consists of comma-separated <em>parameter-type</em> and <em>parameter-name</em>, i.e., <code><em>param-1-type param-1-name</em>, <em>param-2-type param-2-name</em>,...</code></li>
<li>The <em>returnValueType</em> specifies the type of the return value, such as <code>int</code> or <code>double</code>. An special return type called <code>void</code> can be used to denote that the function returns no value. In C++, a function is allowed to return one value or no value (<code>void</code>). It cannot return multiple values. [C++ does not allow you to return an array!]</li>

</ul>

<h5>The &quot;<span class="font-code">return</span>&quot; Statement</h5>

<p>Inside the function's body, you could use a <code>return</code> statement to return a value (of the <code><em>returnValueType</em></code> declared in the function's header) and pass the control back to the caller. The syntax is:</p>

<pre class="color-syntax">
<strong>return</strong> <em>expression</em>;   <span class="color-comment">// Evaluated to a value of <em>returnValueType</em> declared in function's signature</span>
<strong>return</strong>;              <span class="color-comment">// For function with return type of void</span></pre>

<p>Take note that invoking a function (by the caller) transfers the control to the function. The <code>return</code> statement in the function transfers the control back to the caller.</p>

<h5>Function Naming Convention</h5>

<p>A function's name shall be a verb or verb phrase (action), comprising one or more words. The first word is in lowercase, while the rest are initial-capitalized (known as <em>camel-case</em>).  For example, <code>getArea()</code>, <code>setRadius()</code>, <code>moveDown()</code>, <code>isPrime()</code>, etc.</p>

<h5>Function Prototype</h5>

<p>In C++, a function must be declared before it can be called. It can be achieved by either placing the <em>function definition</em> before it is being used, or declare a so-called <em>function prototype</em>.</p>
<p>A function prototype tells the compiler the function's interface, i.e., the return-type, function name, and the parameter type list (the number and type of parameters).  The function can now be defined anywhere in the file. For example,</p>

<pre class="color-example">
<span class="color-comment">// Function prototype - placed before the function is used.</span>
double getArea(double);  <span class="color-comment">// without the parameter name</span>
int max(int, int);</pre>
<p>You could optionally include the parameter names in the function prototype. The names will be ignored by the compiler, but serve as documentation. For example,</p>

<pre class="color-example">
<span class="color-comment">// Function Prototype</span>
double getArea(double radius);  <span class="color-comment">// parameter names are ignored, but serve as documentation</span>
int max(int number1, int number2);</pre>

<p>Function prototypes are usually grouped together and placed in a so-called <em>header file</em>. The header file can be included in many programs. We will discuss header file later.</p>

<h5>Another Example</h5>

<p>We have a function called <code>max(int, int)</code>, which takes two <code>int</code> and return their maximum. We invoke the <code>max()</code> function from the <code>main()</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing max function (TestMaxFunction.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-new">int maximum(int, int);</span><span class="color-comment"> // Function prototype (declaration)</span>
 
int main() {
   cout &lt;&lt; <span class="color-new">maximum(5, 8)</span> &lt;&lt; endl;<span class="color-comment"> // Call maximum() with literals</span>
 
   int a = 6, b = 9, c;
   c = <span class="color-new">maximum(a, b)</span>;            <span class="color-comment"> // Call maximum() with variables</span>
   cout &lt;&lt; c &lt;&lt; endl;
 
   cout &lt;&lt; <span class="color-new">maximum(c, 99)</span> &lt;&lt; endl;<span class="color-comment"> // Call maximum()</span>
}
 
<span class="color-comment">// Function definition</span>
<span class="color-comment">// A function that returns the maximum of two given int</span>
<span class="color-new">int maximum(int num1, int num2) {
   return (num1 &gt; num2) ? num1 : num2;
}</span></pre>
</td>
</tr>
</tbody>
</table>

<h5>The &quot;<span class="font-code">void</span>&quot; Return Type</h5>

<p>Suppose that you need a function to perform certain actions (e.g., printing) without a need to return a value to the caller, you can declare its return-value type as <code>void</code>. In the function's body, you could use a &quot;<code>return;</code>&quot; statement without a return value to return control to the caller. In this case, the <code>return</code> statement is optional. If there is no <code>return</code> statement, the entire body will be executed, and control returns to the caller at the end of the body.</p>

<h5>Actual Parameters vs. Formal Parameters</h5>

<p>Recall that a function receives <em>arguments</em> from its caller, performs the actions defined in the function's body, and return a value (or nothing) to the caller.</p>

<p>In the above example, the variable <code>(double radius)</code> declared in the signature of <code>getArea(double radius)</code> is known as <em>formal parameter</em>. Its scope is within the function's body. When the function is invoked by a caller, the caller must supply so-called <em>actual parameter</em>s (or <em>arguments</em>), whose value is then used for the actual computation. For example, when the function is invoked via &quot;<code>area1 = getArea(radius1)</code>&quot;, <code>radius1</code> is the actual parameter, with a value of <code>1.1</code>.</p>

<h5>Scope of Function's Local Variables and Parameters</h5>

<p>All variables, including function's parameters, declared inside a function are available only to the function. They are created when the function is called, and freed (destroyed) after the function returns. They are called <em>local variables</em> because they are local to the function and not available outside the function. They are also called <em>automatic variables</em>, because they are created and destroyed automatically - no programmer's explicit action needed to allocate and deallocate them.</p>

<h5>Boolean Functions</h5>

<p>A boolean function returns a <code>bool</code> value (of either <code>true</code> or <code>false</code>) to the caller.</p>

<p>Suppose that we wish to write a function called <code>isOdd()</code> to check if a given number is odd.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Test Boolean function (BooleanfunctionTest.cpp).
 */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Function Prototype</span>
<span class="color-new">bool isOdd(int);</span>
 
int main() {
   cout &lt;&lt; boolalpha;  <span class="color-comment"> // print bool as true or false</span>
   cout &lt;&lt; <span class="color-new">isOdd(5)</span> &lt;&lt; endl; <span class="color-comment"> // true</span>
   cout &lt;&lt; <span class="color-new">isOdd(6)</span> &lt;&lt; endl; <span class="color-comment"> // false</span>
   cout &lt;&lt; <span class="color-new">isOdd(-5)</span> &lt;&lt; endl;<span class="color-comment"> // false</span>
}
 
<span class="color-new">bool isOdd(int number) {
   if (number % 2 == 1) {
      return true;
   } else {
      return false;
   }
}</span></pre>
</td>
</tr>
</tbody>
</table>

<p>This seemingly correct codes produces <code>false</code> for <code>-5</code>, because <code>-5%2</code> is <code>-1</code> instead of <code>1</code>.  You may rewrite the condition:</p>
<pre class="color-example">
bool isOdd(int number) {
   if (number % 2 == 0) {
      return false;
   } else {
      return true;
   }
}</pre>
<p>The above code produces the correct answer, but is poor.  For boolean function, you should simply return the resultant <code>bool</code> value of the comparison, instead of using a conditional statement, as follow:</p>
<pre class="color-example">
bool isEven(int number) {
   return (number % 2 == 0);
}
 
bool isOdd(int number) {
  return !(number % 2 == 0);  <span class="color-comment">// OR return !isEven(number);</span>
}
 
int main() {
   int number = -9;
   if (isEven(number)) {      <span class="color-comment">// Don't write (isEven(number) == true)</span>
      cout &lt;&lt; &quot;Even&quot; &lt;&lt; endl;
   }
}</pre>

<h4>Default Arguments</h4>

<p>C++ introduces so-called <em>default arguments</em> for functions. These default values would be used if the caller omits the corresponding actual argument in calling the function. Default arguments are specified in the function prototype, and cannot be repeated in the function definition. The default arguments are resolved based on their positions. Hence, they can only be used to substitute the <em>trailing</em> arguments to avoid ambiguity. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Function default arguments (functionDefaultArgument.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Function prototype - Specify the default arguments here</span>
int fun1(int <span class="color-new">= 1</span>, int <span class="color-new">= 2</span>, int <span class="color-new">= 3</span>);
int fun2(int, int, int <span class="color-new">= 3</span>);
 
int main() {
   cout &lt;&lt; fun1(4, 5, 6) &lt;&lt; endl; <span class="color-comment">// No default</span>
   cout &lt;&lt; fun1(4, 5) &lt;&lt; endl;    <span class="color-comment">// 4, 5, 3(default)</span>
   cout &lt;&lt; fun1(4) &lt;&lt; endl;       <span class="color-comment">// 4, 2(default), 3(default)</span>
   cout &lt;&lt; fun1() &lt;&lt; endl;        <span class="color-comment">// 1(default), 2(default), 3(default)</span>
 
   cout &lt;&lt; fun2(4, 5, 6) &lt;&lt; endl; <span class="color-comment">// No default</span>
   cout &lt;&lt; fun2(4, 5) &lt;&lt; endl;    <span class="color-comment">// 4, 5, 3(default)</span>
<span class="color-error">//</span> cout &lt;&lt; fun2(4) &lt;&lt; endl;
     <span class="color-error"> // error: too few arguments to function 'int fun2(int, int, int)'</span>
}
 
int fun1(int n1, int n2, int n3) {
      <span class="color-comment">// cannot repeat default arguments in function definition</span>
   return n1 + n2 + n3;
}
 
int fun2(int n1, int n2, int n3) {
   return n1 + n2 + n3;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>You should specify the default arguments in the function prototype (declaration). They can only be defined once (one-definition rule), and cannot be repeated in the function definition.</p>
<p>Default argument is not absolutely necessary. The codes could be hard to maintain.</p>

<h4>Function Overloading</h4>

<p>C++ introduces <em>function overloading</em> (or <em>function polymorphism</em>, which means <em>many forms</em>), which allows you to have multiple versions of the same function name, differentiated by the parameter list (number, type or order of parameters). The version matches the caller's argument list will be selected for execution. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></td>
<td>
<pre>
<span class="color-comment">/* Test Function Overloading (FunctionOverloading.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
void fun(int, int, int);  <span class="color-comment">// Version 1</span>
void fun(double, int);          <span class="color-comment">// Version 2</span>
void fun(int, double);          <span class="color-comment">// Version 3</span>
 
int main() {
   fun(1, 2, 3);  <span class="color-comment"> // version 1</span>
   fun(1.0, 2);   <span class="color-comment"> // version 2</span>
   fun(1, 2.0);   <span class="color-comment"> // version 3</span>
   fun(1.1, 2, 3);<span class="color-comment"> // version 1 - double 1.1 casted to int 1 (without warning)</span>
 
   <span class="color-comment">//</span> <span class="color-new">fun(1, 2, 3, 4);</span>
     <span class="color-comment"> // error: no matching function for call to 'fun(int, int, int, int)'</span>
   <span class="color-comment">//</span> <span class="color-new">fun(1, 2);</span>
      <span class="color-comment">// error: call of overloaded 'fun(int, int)' is ambiguous
      // note: candidates are:
      //    void fun(double, int)
      //    void fun(int, double)</span>
   <span class="color-comment">//</span> <span class="color-new">fun(1.0, 2.0);</span>
      <span class="color-comment">// error: call of overloaded 'fun(double, double)' is ambiguous</span>
}
 
void fun(int n1, int n2, int n3) { <span class="color-comment"> // version 1</span>
   cout &lt;&lt; &quot;version 1&quot; &lt;&lt; endl;
}
 
void fun(double n1, int n2) {<span class="color-comment"> // version 2</span>
   cout &lt;&lt; &quot;version 2&quot; &lt;&lt; endl;
}
 
void fun(int n1, double n2) {<span class="color-comment"> // version 3</span>
   cout &lt;&lt; &quot;version 3&quot; &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Overloaded functions cannot be differentiated by the return-type (compilation error).</p>

<h5 id="name_mangling">*Name Mangling</h5>

<p>To differentiate between different versions of an overloaded function, many compilers (such as GNU GCC) adopt a <em>name mangling</em> or <em>name decoration</em> scheme for naming functions.</p>

<pre class="color-command">
<span class="color-comment">// Compile source into object code FunctionOverloading.o</span>
&gt; <strong>g++ -c FunctionOverloading.cpp</strong>
 
<span class="color-comment">// List the symbol table</span>
&gt; <strong>nm FunctionOverloading.o</strong>
......
000000b5 T <span class="color-new">__Z3fundi</span>
000000ed T <span class="color-new">__Z3funid</span>
00000089 T <span class="color-new">__Z3funiii</span>
......</pre>

<p>Each of the function is identified via a prefix <code>__Z</code>, followed by an integer containing the number of characters of the function name (3 in this case for &quot;<code>fun</code>&quot;), followed by the parameter type list (where <code>i</code> for <code>int</code> and <code>d</code> for <code>double</code>). For example, <code>di</code> means a <code>double</code> followed by an <code>int</code>; <code>id</code> for an <code>int</code> followed by a <code>double</code>; <code>iii</code> for 3 <code>ints</code>.</p>

<p>You can choose to use the C's naming protocol by appending the keyword <code>extern &quot;C&quot;</code> to the function prototype. C does not support function overloading. Thus, it does not need name mangling. It simply append an underscore in front of the function name. For example,</p>

<pre class="color-example">
extern &quot;C&quot; void fun(int, int, int, int);   <span class="color-comment">// Compiled as _fun</span></pre>

<h4>Functions and Arrays</h4>

<p>You can also pass arrays into function. However, you also need to pass the size of the array into the function. This is because there is no way to tell the size of the array from the array argument inside the called function.</p>

<p>For example,</p>

<h5>Example: Computing the Sum of an Array and Print Array's Contents</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Function to compute the sum of an array (SumArray.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Function prototype</span>
int sum(int array[], int size);   <span class="color-comment"> // Need to pass the array size too</span>
void print(int array[], int size);
 
<span class="color-comment">// Test Driver</span>
int main() {
   int a1[] = {8, 4, 5, 3, 2};
   print(a1, 5);  <span class="color-comment"> // {8,4,5,3,2}</span>
   cout &lt;&lt; &quot;sum is &quot; &lt;&lt; sum(a1, 5) &lt;&lt; endl; <span class="color-comment"> // sum is 22</span>
}
 
<span class="color-comment">// Function definition</span>
<span class="color-comment">// Return the sum of the given array</span>
int sum(int array[], int size) {
   int sum = 0;
   for (int i = 0; i &lt; size; ++i) {
      sum += array[i];
   }
   return sum;
}
 
<span class="color-comment">// Print the contents of the given array</span>
void print(int array[], int size) {
   cout &lt;&lt; &quot;{&quot;;
   for (int i = 0; i &lt; size; ++i) {
      cout &lt;&lt; array[i];
      if (i &lt; size - 1) {
         cout &lt;&lt; &quot;,&quot;;
      }
   }
   cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Pass-by-Value vs. Pass-by-Reference</h4>

<p>There are two ways that a parameter can be passed into a function: <em>pass by value</em> vs. <em>pass by reference</em>.</p>

<h5>Pass-by-Value</h5>

<p>In pass-by-value, a &quot;copy&quot; of argument is created and passed into the function. The invoked function works on the &quot;clone&quot;, and cannot modify the original copy. In C/C++, fundamental types (such as <code>int</code> and <code>double</code>) are passed by value. That is, you cannot modify caller's value inside the function - there is no <em>side effect</em>.</p>

<h5>Example (Fundamental Types are Passed by Value)</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Fundamental types are passed by value into Function (TestPassByValue.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Function prototypes</span>
int inc(int number);
 
<span class="color-comment">// Test Driver</span>
int main() {
   int n = 8;
   cout &lt;&lt; &quot;Before calling function, n is &quot; &lt;&lt; n &lt;&lt; endl;<span class="color-comment"> // 8</span>
   int result = inc(n);
   cout &lt;&lt; &quot;After calling function, n is &quot; &lt;&lt; n &lt;&lt; endl; <span class="color-comment"> // 8</span>
   cout &lt;&lt; &quot;result is &quot; &lt;&lt; result &lt;&lt; endl;               <span class="color-comment"> // 9</span>
}
 
<span class="color-comment">// Function definitions</span>
<span class="color-comment">// Return number+1</span>
int inc(int number) {
   ++number; <span class="color-comment"> // Modify parameter, no effect to caller</span>
   return number;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Pass-by-Reference</h5>

<p>On the other hand, in pass-by-reference, a <em>reference</em> of the caller's variable is passed into the function. In other words, the invoked function works on the same data. If the invoked function modifies the parameter, the same caller's copy will be modified as well.</p>
<p>In C/C++, arrays are passed by reference. That is, you can modify the contents of the caller's array inside the invoked function - there could be <em>side effect</em> in passing arrays into function.</p>
<p>C/C++ does not allow functions to return an array. Hence, if you wish to write a function that modifies the contents of an array (e.g., sorting the elements of an array), you need to rely on pass-by-reference to work on the same copy inside and outside the function. Recall that in pass-by-value, the invoked function works on a <em>clone</em> copy and has no way to modify the original copy.</p>

<h5>Example (Array is passed by Reference): Increment Each Element of an Array</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Function to increment each element of an array (IncrementArray.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Function prototypes</span>
void inc(int array[], int size);
void print(int array[], int size);
 
<span class="color-comment">// Test Driver</span>
int main() {
   int a1[] = {8, 4, 5, 3, 2};
 
  <span class="color-comment"> // Before increment</span>
   print(a1, 5);  <span class="color-comment"> // {8,4,5,3,2}</span>
  <span class="color-comment"> // Do increment</span>
   inc(a1, 5);    <span class="color-comment"> // Array is passed by reference (having side effect)</span>
  <span class="color-comment"> // After increment</span>
   print(a1, 5);  <span class="color-comment"> // {9,5,6,4,3}</span>
}
 
<span class="color-comment">// Function definitions</span>
 
<span class="color-comment">// Increment each element of the given array</span>
void inc(int array[], int size) {  <span class="color-comment">// array[] is not const</span>
   for (int i = 0; i &lt; size; ++i) {
      array[i]++;  <span class="color-comment">// side-effect</span>
   }
}
 
<span class="color-comment">// Print the contents of the given array</span>
void print(int array[], int size) {
   cout &lt;&lt; &quot;{&quot;;
   for (int i = 0; i &lt; size; ++i) {
      cout &lt;&lt; array[i];
      if (i &lt; size - 1) {
         cout &lt;&lt; &quot;,&quot;;
      }
   }
   cout &lt;&lt; &quot;}&quot; &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Array is passed into function by reference. That is, the invoked function works on the same copy of the array as the caller. Hence, changes of array inside the function is reflected outside the function (i.e., side effect).</p>

<h5>Why Arrays are Pass-by-Reference?</h5>

<p>Array is designed to be passed by reference, instead of by value using a cloned copy. This is because passing huge array by value is inefficient - the huge array needs to be cloned.</p>

<h4><span class="font-code">const</span> Function Parameters</h4>
<p>Pass-by-reference risks corrupting the original data. If you do not have the intention of modifying the arrays inside the function, you could use the <code>const</code> keyword in the function parameter. A <code>const</code> function argument cannot be modified inside the function.</p>

<p>Use <code>const</code> whenever possible for passing references as it prevent you from inadvertently modifying the parameters and protects you against many programming errors.</p>

<h5 id="LinearSearch">Example: Search an Array using Linear Search</h5>

<p>In a linear search, the search key is compared with each element of the array linearly. If there is a match, it returns the index of the array between [0, size-1]; otherwise, it returns -1 or the size of of the array (some implementations deal with only positive indexes). Linear search has complexity of O(n).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Search an array for the given key using Linear Search (LinearSearch.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int linearSearch(const int a[], int size, int key);
 
int main() {
   const int SIZE = 8;
   int a1[SIZE] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   cout &lt;&lt; linearSearch(a1, SIZE, 8) &lt;&lt; endl; <span class="color-comment"> // 0</span>
   cout &lt;&lt; linearSearch(a1, SIZE, 4) &lt;&lt; endl; <span class="color-comment"> // 1</span>
   cout &lt;&lt; linearSearch(a1, SIZE, 99) &lt;&lt; endl;<span class="color-comment"> // 8 (not found)</span>
}
 
<span class="color-comment">// Search the array for the given key</span>
<span class="color-comment">// If found, return array index [0, size-1]; otherwise, return size</span>
int linearSearch(const int a[], int size, int key) {
   for (int i = 0; i &lt; size; ++i) {
      if (a[i] == key) return i;
   }
   return size;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5 id="BubbleSort">Example: Sorting an Array using Bubble Sort</h5>

<p>Wiki &quot;<a href="en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a>&quot; for the <code></code>detailed algorithm and illustration. In brief, we pass thru the list, compare two adjacent items and swap them if they are in the wrong order. Repeat the pass until no swaps are needed. For example,</p>

<pre class="color-example">
{8,4,5,3,2,9,4,1}
PASS 1 ...
{8,4,5,3,2,9,4,1} =&gt; {4,8,5,3,2,9,4,1}
{4,8,5,3,2,9,4,1} =&gt; {4,5,8,3,2,9,4,1}
{4,5,8,3,2,9,4,1} =&gt; {4,5,3,8,2,9,4,1}
{4,5,3,8,2,9,4,1} =&gt; {4,5,3,2,8,9,4,1}
{4,5,3,2,8,9,4,1} =&gt; {4,5,3,2,8,4,9,1}
{4,5,3,2,8,4,9,1} =&gt; {4,5,3,2,8,4,1,9}
PASS 2 ...
{4,5,3,2,8,4,1,9} =&gt; {4,3,5,2,8,4,1,9}
{4,3,5,2,8,4,1,9} =&gt; {4,3,2,5,8,4,1,9}
{4,3,2,5,8,4,1,9} =&gt; {4,3,2,5,4,8,1,9}
{4,3,2,5,4,8,1,9} =&gt; {4,3,2,5,4,1,8,9}
PASS 3 ...
{4,3,2,5,4,1,8,9} =&gt; {3,4,2,5,4,1,8,9}
{3,4,2,5,4,1,8,9} =&gt; {3,2,4,5,4,1,8,9}
{3,2,4,5,4,1,8,9} =&gt; {3,2,4,4,5,1,8,9}
{3,2,4,4,5,1,8,9} =&gt; {3,2,4,4,1,5,8,9}
PASS 4 ...
{3,2,4,4,1,5,8,9} =&gt; {2,3,4,4,1,5,8,9}
{2,3,4,4,1,5,8,9} =&gt; {2,3,4,1,4,5,8,9}
PASS 5 ...
{2,3,4,1,4,5,8,9} =&gt; {2,3,1,4,4,5,8,9}
PASS 6 ...
{2,3,1,4,4,5,8,9} =&gt; {2,1,3,4,4,5,8,9}
PASS 7 ...
{2,1,3,4,4,5,8,9} =&gt; {1,2,3,4,4,5,8,9}
PASS 8 ...
{1,2,3,4,4,5,8,9}</pre>

<p>Bubble sort is not efficient, with complexity of O(n<sup>2</sup>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Sorting an array using Bubble Sort (BubbleSort.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
void bubbleSort(int a[], int size);
void print(const int a[], int size);
 
int main() {
   const int SIZE = 8;
   int a[] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   print(a, SIZE);
   cout &lt;&lt; endl;
   bubbleSort(a, SIZE);
   print(a, SIZE);
   cout &lt;&lt; endl;
}
 
<span class="color-comment">// Sort the given array of size</span>
void bubbleSort(int a[], int size) {
   bool done = false;<span class="color-comment"> // terminate if no more swap thru a pass</span>
   int pass = 0;     <span class="color-comment"> // pass number, for tracing</span>
   int temp;         <span class="color-comment"> // use for swapping</span>
 
   while (!done) {
      cout &lt;&lt; &quot;PASS &quot; &lt;&lt; ++pass &lt;&lt; &quot; ...&quot; &lt;&lt; endl;  <span class="color-comment"> // for tracing</span>
      done = true;
     <span class="color-comment"> // Pass thru the list, compare adjacent items and swap</span>
     <span class="color-comment"> // them if they are in wrong order</span>
      for (int i = 0; i &lt; size - 1; ++i) {
         if (a[i] &gt; a[i+1]) {
            print(a, size);<span class="color-comment"> // for tracing</span>
            temp = a[i];
            a[i] = a[i+1];
            a[i+1] = temp;
            done = false;  <span class="color-comment"> // swap detected, one more pass</span>
            cout &lt;&lt; &quot;=&gt; &quot;; <span class="color-comment"> // for tracing</span>
            print(a, size);
            cout &lt;&lt; endl;
         }
      }
   }
}
 
<span class="color-comment">// Print the contents of the given array of size</span>
void print(const int a[], int size) {
   cout &lt;&lt; &quot;{&quot;;
   for (int i = 0; i &lt; size; ++i) {
      cout &lt;&lt; a[i];
      if (i &lt; size - 1) cout &lt;&lt; &quot;,&quot;;
   }
   cout &lt;&lt; &quot;} &quot;;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5 id="InsertionSort">Example: Sorting an Array using Insertion Sort</h5>

<p>Wiki &quot;<a href="http://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a>&quot; for the algorithm and illustration. In brief, pass thru the list. For each element, compare with all previous elements and insert it at the correct position by shifting the other elements. For example,</p>

<pre class="color-example">
{8,4,5,3,2,9,4,1}
{8} {4,5,3,2,9,4,1}
{4,8} {5,3,2,9,4,1}
{4,5,8} {3,2,9,4,1}
{3,4,5,8} {2,9,4,1}
{2,3,4,5,8} {9,4,1}
{2,3,4,5,8,9} {4,1}
{2,3,4,4,5,8,9} {1}
{1,2,3,4,4,5,8,9}</pre>

<p>Insertion sort is also not efficient, with complexity of O(n<sup>2</sup>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Sorting an array using Insertion Sort (InsertionSort.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
void insertionSort(int a[], int size);
void print(const int a[], int iMin, int iMax);
 
int main() {
   const int SIZE = 8;
   int a[SIZE] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   print(a, 0, SIZE - 1);
   cout &lt;&lt; endl;
   insertionSort(a, SIZE);
   print(a, 0, SIZE - 1);
   cout &lt;&lt; endl;
}
 
<span class="color-comment">// Sort the given array of size using insertion sort</span>
void insertionSort(int a[], int size) {
   int temp;  <span class="color-comment"> // for shifting elements</span>
   for (int i = 1; i &lt; size; ++i) {
     <span class="color-comment"> // for tracing</span>
      print(a, 0, i - 1);   <span class="color-comment"> // already sorted</span>
      print(a, i, size - 1);<span class="color-comment"> // to be sorted</span>
      cout &lt;&lt; endl;
 
     <span class="color-comment"> // For element at i, insert into proper position in [0, i-1]</span>
     <span class="color-comment"> //  which is already sorted.</span>
     <span class="color-comment"> // Shift down the other elements</span>
      for (int prev = 0; prev &lt; i; ++prev) {
         if (a[i] &lt; a[prev]) {
           <span class="color-comment"> // insert a[i] at prev, shift the elements down</span>
            temp = a[i];
            for (int shift = i; shift &gt; prev; --shift) {
               a[shift] = a[shift-1];
            }
            a[prev] = temp;
            break;
         }
      }
   }
}
 
<span class="color-comment">// Print the contents of the array in [iMin, iMax]</span>
void print(const int a[], int iMin, int iMax) {
   cout &lt;&lt; &quot;{&quot;;
   for (int i = iMin; i &lt;= iMax; ++i) {
      cout &lt;&lt; a[i];
      if (i &lt; iMax) cout &lt;&lt; &quot;,&quot;;
   }
   cout &lt;&lt; &quot;} &quot;;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5 id="SelectionSort">Example: Sorting an Array using Selection Sort</h5>

<p>Wiki &quot;<a href="http://en.wikipedia.org/wiki/Selection_sort">Selection Sort</a>&quot; for the algorithm and illustration. In brief, Pass thru the list. Select the smallest element and swap with the head of the list. For example,</p>

<pre class="color-example">
{8,4,5,3,2,9,4,1}
{} {8,4,5,3,2,9,4,1} =&gt; {} {1,4,5,3,2,9,4,8}
{1} {4,5,3,2,9,4,8} =&gt; {1} {2,5,3,4,9,4,8}
{1,2} {5,3,4,9,4,8} =&gt; {1,2} {3,5,4,9,4,8}
{1,2,3} {5,4,9,4,8} =&gt; {1,2,3} {4,5,9,4,8}
{1,2,3,4} {5,9,4,8} =&gt; {1,2,3,4} {4,9,5,8}
{1,2,3,4,4} {9,5,8} =&gt; {1,2,3,4,4} {5,9,8}
{1,2,3,4,4,5} {9,8} =&gt; {1,2,3,4,4,5} {8,9}
{1,2,3,4,4,5,8,9}</pre>

<p>Selection sort is also not efficient, with complexity of O(n<sup>2</sup>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Sorting an array using Selection Sort (SelectionSort.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
void selectionSort(int a[], int size);
void print(const int a[], int iMin, int iMax);
 
int main() {
   const int SIZE = 8;
   int a[SIZE] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   print(a, 0, SIZE - 1);
   cout &lt;&lt; endl;
   selectionSort(a, SIZE);
   print(a, 0, SIZE - 1);
   cout &lt;&lt; endl;
}
 
<span class="color-comment">// Sort the given array of size using selection sort</span>
void selectionSort(int a[], int size) {
   int temp;<span class="color-comment"> // for swaping</span>
   for (int i = 0; i &lt; size - 1; ++i) {
     <span class="color-comment"> // for tracing</span>
      print(a, 0, i - 1);
      print(a, i, size - 1);
 
     <span class="color-comment"> // [0, i-1] already sort</span>
     <span class="color-comment"> // Search for the smallest element in [i, size-1]</span>
     <span class="color-comment"> //  and swap with a[i]</span>
      int minIndex = i; <span class="color-comment"> // assume fist element is the smallest</span>
      for (int j = i + 1; j &lt; size; ++j) {
         if (a[j] &lt; a[minIndex]) minIndex = j;
      }
      if (minIndex != i) { <span class="color-comment"> // swap</span>
         temp = a[i];
         a[i] = a[minIndex];
         a[minIndex] = temp;
      }
 
     <span class="color-comment"> // for tracing</span>
      cout &lt;&lt; &quot;=&gt; &quot;;
      print(a, 0, i - 1);
      print(a, i, size - 1);
      cout &lt;&lt; endl;
   }
}
 
<span class="color-comment">// Print the contents of the array in [iMin, iMax]</span>
void print(const int a[], int iMin, int iMax) {
   cout &lt;&lt; &quot;{&quot;;
   for (int i = iMin; i &lt;= iMax; ++i) {
      cout &lt;&lt; a[i];
      if (i &lt; iMax) cout &lt;&lt; &quot;,&quot;;
   }
   cout &lt;&lt; &quot;} &quot;;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5>&quot;<span class="font-code">const</span>&quot; Fundamental-Type Function Parameters?</h5>

<p>You could also use <code>const</code> for fundamental-type function parameters (such as <code>int</code>, <code>double</code>) to prevent the parameters from being modified inside the function. However, as fundamental-type parameters are passed by value (with a cloned copy), there will never be side effect on the caller. We typically do not use the <code>const</code> keyword for fundamental types. In other words, <code>const</code> is used to indicate that there shall NOT be side-effect.</p>

<h4>Pass-by-Reference via &quot;Reference&quot; Parameters</h4>

<p>As mentioned, parameters of fundamental types (such as int, double) are passed-by-value. That is, a clone copy is used inside the function. Change to the cloned copy inside the function has no side-effect to the caller's copy.</p>

<p>Nonetheless, you can pass a fundamental type parameter by reference via the so-called <em>reference parameter</em> denoted by <code>&amp;</code>. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Pass-by-reference for fundamental-type parameter
   via reference declaration (TestPassByReference.cpp) */</span>
#include &lt;iostream&gt;
using namespace std;
 
int squareByValue (int number);       <span class="color-comment"> // Pass-by-value</span>
<span class="color-new">void squareByReference (int &amp; number);</span><span class="color-comment"> // Pass-by-reference</span>
 
int main() {
   int n1 = 8;
   cout &lt;&lt; &quot;Before call, value is &quot; &lt;&lt; n1 &lt;&lt; endl; <span class="color-comment"> // 8</span>
   cout &lt;&lt; squareByValue(n1) &lt;&lt; endl; <span class="color-comment"> // no side-effect</span>
   cout &lt;&lt; &quot;After call, value is &quot; &lt;&lt; n1 &lt;&lt; endl;  <span class="color-comment"> // 8</span>
 
   int n2 = 9;
   cout &lt;&lt; &quot;Before call, value is &quot; &lt;&lt; n2 &lt;&lt; endl; <span class="color-comment"> // 9</span>
   <span class="color-new">squareByReference(n2);</span> <span class="color-comment"> // side-effect</span>
   cout &lt;&lt; &quot;After call, value is &quot; &lt;&lt; n2 &lt;&lt; endl;  <span class="color-comment"> // 81</span>
}
 
<span class="color-comment">// Pass parameter by value - no side effect</span>
int squareByValue (int number) {
   return number * number;
}
 
<span class="color-comment">// Pass parameter by reference by declaring as reference (&amp;)</span>
<span class="color-comment">// - with side effect to the caller</span>
<span class="color-new">void squareByReference (int &amp; number) {
   number = number * number;
}</span></pre>
</td>
</tr>
</tbody>
</table>

<p>In function <code>squareByReference()</code>, we declare the parameter <code>number</code> is passed by reference by declaring its type as <code>int &amp;</code> (reference of <code>int</code>). In this way, the caller's copy is used inside the function (instead of a cloned copy in pass-by-value). Changes inside the function has side-effect.</p>

<p>Pass-by-reference is NOT commonly used for fundamental types (such as <code>int</code>, <code>double</code>) - the above example is purely meant for academic illustration. But it is used extensively for compound types (such as arrays and objects) to avoid cloning huge data for better performance. We shall revisit pass-by-reference in Object-Oriented Programming (OOP) chapters.</p>

<h4>Mathematical Functions (Header <span class="font-code">&lt;cmath&gt;</span>)</h4>

<p>C++ provides many common-used Mathematical functions in library <code>&lt;cmath&gt;</code> (ported over from C's &quot;<code>math.h</code>&quot;). The signatures of some of these functions are:</p>

<table class="table-program">
<tr>
<td>
<pre class="color-syntax">
<strong>sin(x), cos(x), tan(x), asin(x), acos(x), atan(x)</strong>:
   Take argument-type and return-type of float, double, long double.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>atan2(y, x)</strong>:
   Return arc-tan of y/x. Better than atan(x) for handling 90 degree.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>sinh(x), cosh(x), tanh(x)</strong>:
   hyper-trigonometric functions.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>pow(x, y), sqrt(x):</strong>
   power and square root.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>ceil(x), floor(x):</strong>
   returns the ceiling and floor integer of floating point number.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>fabs(x), fmod(x, y):</strong>
   floating-point absolute and modulus.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>exp(x), log(x), log10(x):</strong>
   exponent and logarithm functions.</pre>
</td>
</tr>

</table>

<h4>Generating Random Numbers</h4>

<p>The <code>cstdlib</code> header (ported from C's <code>stdlib.h</code>) provides a function <code>rand()</code>, which generates a pseudo-random integral number between 0 and <code>RAND_MAX</code> (inclusive). <code>RAND_MAX</code> is a constant defined in <code>cstdlib</code> (typically the maximum value of 16-/32-bit signed integer, such as 32767). You can generate a random number between <code>[0,n)</code> via <code>rand() % n</code>.</p>
<p><code>rand()</code> generates the same squence of pseudo-random numbers on different invocations. The <code>cstblib</code> also provides a <code>srand()</code> function to <em>seed</em> or initialize the random number generator. We typically seed it with the current time obtained via <code>time(0)</code> function (in <code>&lt;ctime&gt;</code> header), which returns the number of seconds since January 1st, 1970.</p>

<h5>Example 1: Test <span class="font-code">rand()</span> and <span class="font-code">srand(time(0))</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Random Number Generation (TestRand.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt; <span class="color-comment"> // for rand(), srand()</span>
#include &lt;ctime&gt;   <span class="color-comment"> // for time()</span>
using namespace std;
 
int main() {
  <span class="color-comment"> // rand() generate a random number in [0, RAND_MAX]</span>
   cout &lt;&lt; &quot;RAND_MAX is &quot; &lt;&lt; <span class="color-new">RAND_MAX</span> &lt;&lt; endl;  <span class="color-comment"> // 32767</span>
 
  <span class="color-comment"> // Generate 10 pseudo-random numbers between 0 and 99</span>
  <span class="color-comment"> //   without seeding the generator.</span>
  <span class="color-comment"> // You will get the same sequence, every time you run this program</span>
   for (int i = 0; i &lt; 10; ++i) {
      cout &lt;&lt; <span class="color-new">rand() % 100</span> &lt;&lt; &quot; &quot;;  <span class="color-comment"> // need &lt;cstdlib&gt; header</span>
   }
   cout &lt;&lt; endl;
 
  <span class="color-comment"> // Seed the random number generator with current time</span>
   <span class="color-new">srand(time(0));</span>  <span class="color-comment"> // need &lt;cstdlib&gt; and &lt;ctime&gt; header</span>
  <span class="color-comment"> // Generate 10 pseudo-random numbers</span>
  <span class="color-comment"> // You will get different sequence on different run,</span>
  <span class="color-comment"> //   because the current time is different</span>
   for (int i = 0; i &lt; 10; ++i) {
      cout &lt;&lt; <span class="color-new">rand() % 100</span> &lt;&lt; &quot; &quot;;  <span class="color-comment"> // need &lt;cstdlib&gt; header</span>
   }
   cout &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Example 2: Test <span class="font-code">rand()</span>'s Distribution</h5>

<p>We shall test the <code>rand()</code>'s distribution by repeatedly throwing a 6-sided die and count the occurrences.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td>
<td>
<pre>
<span class="color-comment">/* Test rand() distribution by throwing a die repeatedly (TestRandomDie.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdlib&gt; <span class="color-comment"> // for rand(), srand()</span>
#include &lt;ctime&gt;   <span class="color-comment"> // for time()</span>
using namespace std;
 
const int TOTAL_COUNT = 2000000;  <span class="color-comment">// Close to INT_MAX</span>
const int NUM_FACES = 6;
int frequencies[6] = {0};<span class="color-comment"> // frequencies of 0 to 5, init to zero</span>
 
int main() {
   <span class="color-comment"><span class="color-new">srand(time(0));</span> // seed random number generator with current time</span>
  <span class="color-comment"> // Throw the die and count the frequencies</span>
   for (int i = 0; i &lt; TOTAL_COUNT; ++i) {
      ++frequencies[<span class="color-new">rand() % 6</span>];
   }
 
  <span class="color-comment"> // Print statistics</span>
   cout &lt;&lt; fixed &lt;&lt; setprecision(2);
   for (int i = 0; i &lt; NUM_FACES; i++) {
      cout &lt;&lt; i+1 &lt;&lt; &quot;: &quot; &lt;&lt; frequencies[i]
           &lt;&lt; &quot; (&quot; &lt;&lt; 100.0 * frequencies[i] / TOTAL_COUNT &lt;&lt; &quot;%)&quot; &lt;&lt; endl;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
1: 333109 (16.66%)
2: 333113 (16.66%)
3: 333181 (16.66%)
4: 333562 (16.68%)
5: 333601 (16.68%)
6: 333434 (16.67%)</pre>

<p>As seen from the output, <code>rand()</code> is fairly <em>uniformly-distributed</em> over <code>[0, RAND_MAX]</code>.</p>

<h4>Exercises</h4>

<p>[TODO]</p>


<h3>File Input/Output (Header <span class="font-code">&lt;fstream&gt;</span>)</h3>

<p>The <code>&lt;fstream&gt;</code> header provides <code>ifstream</code> (input file stream) and <code>ofstream</code> (output file stream) for file input and output. The steps for file input/output are:</p>

<ol>
<li>Create a <code>ifstream</code> for input, or <code>ofstream</code> for output.</li>
<li>Connect the stream to an input or output file via <code>open(<em>filename</em>)</code>.</li>
<li>Perform formatted output via stream insertion operator <code>&lt;&lt;</code>, or input via stream extraction operator <code>&gt;&gt;</code>, similar to <code>cout &lt;&lt;</code> and <code>cin &gt;&gt;</code>.</li>
<li>Close the file and free the stream.</li>


</ol>

<h4>Example: File IO</h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test File I/O (TestFileIO.cpp)
   Read all the integers from an input file and
   write the average to an output file        */</span>
#include &lt;iostream&gt;
#include &lt;fstream&gt;  <span class="color-comment"> // file stream</span>
#include &lt;cstdlib&gt;
using namespace std;
 
int main() {
   ifstream fin;  <span class="color-comment"> // Input stream</span>
   ofstream fout; <span class="color-comment"> // Output stream</span>
 
  <span class="color-comment"> // Try opening the input file</span>
   fin.open(&quot;in.txt&quot;);
   if (!fin.is_open()) {
      cerr &lt;&lt; &quot;error: open input file failed&quot; &lt;&lt; endl;
      abort(); <span class="color-comment"> // Abnormally terminate the program (in &lt;cstdlib&gt;)</span>
   }
 
   int sum = 0, number, count = 0;
   while (!(fin.eof())) {
     <span class="color-comment"> // Use &gt;&gt; to read</span>
      fin &gt;&gt; number;
      sum += number;
      ++count;
   }
   double average = double(sum) / count;
   cout &lt;&lt; &quot;Count = &quot; &lt;&lt; count &lt;&lt; &quot; average = &quot; &lt;&lt; average &lt;&lt; endl;
   fin.close();
 
  <span class="color-comment"> // Try opening the output file</span>
   fout.open(&quot;out.txt&quot;);
   if (!fout.is_open()) {
      cerr &lt;&lt; &quot;error: open output file failed&quot; &lt;&lt; endl;
      abort();
   }
  <span class="color-comment"> // Write the average to the output file using &lt;&lt;</span>
   fout &lt;&lt; average;
   fout.close();
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Input File: <span class="font-code">in.txt</span></h5>

<pre class="color-example">
12 15 35 26 68
</pre>

<h5>Output File: <span class="font-code">out.txt</span></h5>
<pre class="color-example">
31.20</pre>

<p>Program Notes:</p>
<ul>
<li>Once the file is opened, you can use <code>&gt;&gt;</code> and <code>&lt;&lt;</code> for input and output, similar to <code>cin &gt;&gt;</code> and <code>cout &lt;&lt;</code>. (Advanced note: <code>ifstream</code> is a subclass of <code>istream</code>, where <code>cin</code> belongs. <code>ofstream</code> is a subclass <code>of ostream</code>, where <code>cout</code> belongs.)</li>
<li>Similarly, IO manipulators, such as <code>fixed</code>, <code>setprecision()</code> and <code>setw()</code>, work on the file streams.</li>
</ul>

<h4>Exercises</h4>

<p>[TODO]</p>

<h3>Namespace</h3>

<p>When you use different library modules, there is always a potential for name crashes, as different library may use the same name for different purposes. This problem can be resolved via the use of <em>namespace</em> in C++. A <em>namespace</em> is a collection for identifiers under the same naming scope. (It is known as <em>package</em> in UML and Java.) The entity name under a namespace is <em>qualified</em> by the namespace name, followed by <code>::</code> (known as scope resolution operator), in the form of <code><em>namespace</em>::<em>entityName</em></code>.</p>

<p>To place an entity under a namespace, use keyword <code>namespace</code> as follow:</p>
<pre class="color-example">
<span class="color-comment">// create a namespace called myNamespace for the enclosed entities</span>
namespace <strong>myNameSpace</strong> {  
   int foo;               <span class="color-comment">// variable</span>
   int f() { ...... };    <span class="color-comment">// function</span>
   class Bar { ...... };  <span class="color-comment">// compound type such as class and struct</span>
}
 
<span class="color-comment">// To reference the entities, use</span>
<strong>myNameSpace::</strong>foo
<strong>myNameSpace::</strong>f()
<strong>myNameSpace::</strong>Bar</pre>

<p>A namespace can contain variables, functions, arrays, and compound types such as classes and structures.</p>

<h5>Namespace Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td>
<td>
<pre>
#include &lt;iostream&gt;
 
namespace a {   <span class="color-comment">// contains variables</span>
   int i1 = 8;
   int i2 = 9;
}
 
namespace b {   <span class="color-comment">// contains function</span>
   int max(int n1, int n2) {
      return (n1 &gt; n2) ? n1 : n2;
   }
}
 
int main() {
   std::cout &lt;&lt; a::i1 &lt;&lt; std::endl;               <span class="color-comment"> // 8</span>
   std::cout &lt;&lt; b::max(a::i1, a::i2) &lt;&lt; std::endl;<span class="color-comment"> // 9</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Namespaces are opened. In other words, you can add more names into an existing namespace using additional <code>namespace</code> definition.</p>

<h5>Using Namespace</h5>

<p>For example, all the identifiers in the C++ standard libraries (such as <code>cout</code>, <code>endl</code> and <code>string</code>) are placed under the namespace called <code>std</code>. To reference an identifier under a namespace, you have three options:</p>

<ol>
<li>Use the fully qualified names, such as <code>std::cout</code>, <code>std::endl</code>, <code>std::setw()</code> and <code>std::string</code>. For example,
  <pre class="color-example">std::cout &lt;&lt; std::setw(6) &lt;&lt; 1234 &lt;&lt; std::endl;
</pre>
Missing the &quot;<code>std::</code>&quot; results in &quot;error: 'xxx' was not declared in this scope&quot;.</li>

<li>Use a <em>using declaration</em> to declare the particular identifiers. For example,
<pre class="color-example">using std::cout;
using std::endl;
......
cout &lt;&lt; std::setw(6) &lt;&lt; 1234 &lt;&lt; endl;
</pre>
You can omit the &quot;<code>std::</code>&quot; for <code>cout</code> and <code>endl</code>, but you still have to use &quot;<code>std::</code>&quot; for <code>setw</code>.</li>

<li>Use a <em>using namespace directive</em>. For example,
<pre class="color-example">using namespace std:
......
cout &lt;&lt; setw(6) &lt;&lt; 1234 &lt;&lt; endl;
</pre>

The <code>using namespace</code> directive effectively brings all the identifiers from the specified namespace to the global scope, as if they are available globally. You can reference them without the scope resolution operator. Take note that the <code>using namespace</code> directive may result in name crashes with identifier in the global scope.</li>

<li>For long namespace name, you could define a shorthand (or alias) to the namespace, as follows:
<pre class="color-syntax">
namespace <em>shorthand</em> = <em>namespace-name</em>;</pre>
You can now refer to your class as <code><em>shorthand</em>::<em>entityName</em></code>.</li>
</ol>

<p>As mentioned, all the standard C++ library components are packaged inside a namespace called <code>std</code>.  They include <code>cin</code>, <code>cout</code>, <code>endl</code>, <code>setw()</code>, <code>setprecision()</code>, and <code>string</code>. Hence, we always included a &quot;<code>using namespace std;</code>&quot; directive after the &quot;<code>#include &lt;iostream&gt;</code>&quot; and &quot;<code>#include &lt;string&gt;</code>&quot;. You could also use the qualified name such as <code>std::cin</code>, <code>std::cout</code>, <code>std::endl</code>, <code>std::string</code>, instead of the <code>using</code> directive. You could also use selective using such as &quot;<code>using std::cin;</code>&quot;, &quot;<code>using std::cout;</code>&quot;, &quot;<code>using std::endl;</code>&quot; and &quot;<code>using std::string;</code>&quot;.</p>

<p>Compare the following two code samples:</p>
<pre class="color-example">
#include &lt;iostream&gt;
using namespace std;  <span class="color-comment">// std namespace is available to ALL</span>

int main() { ....... }</pre>

<pre class="color-example">
#include &lt;iostream&gt;

int main() { 
   using namespace std; <span class="color-comment">// std namespace is available to main() only</span>
   .......
}</pre>

<p>Note: you could use the C-style header &quot;<code>iostream.h</code>&quot; which does not use namespace to replace the first two lines in the first sample.</p>


<h5>Global Namespace</h5>
<p>In C++, an entity (variable, function, or class) belongs to the <em>global namespace</em> (identified by <code>::</code> with no namespace name), if it is not enclose within a <code>namespace</code> declaration. For example, <code>main()</code> can be identified as <code>::main()</code>.</p>


<a class="references" href="../howto/References.html#cpp">Link to &quot;C++ References and Resources&quot;</a>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: Cygwin/MInGW GCC g++ 4.6.2<br />
Last modified: June, 2013</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
