<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>C Basics - C Programming Tutorial</title>

<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>C Programming Language</h1>
<h2>Basics</h2>
</div>

<div id="content-main">

<p>This chapter explains the features, technical details and syntaxes of the C programming language. I assume that you could write some simple programs. Otherwise, read &quot;<a href="c0_Introduction.html">Introduction to Programming in C for Novices and First-time Programmers</a>&quot;.</p>

<h3>Introduction to C</h3>

<h5>C Standards</h5>

<p>C is standardized as ISO/IEC 9899.</p>

<ol>
<li>K&amp;R C: Pre-standardized C, based on Brian Kernighan and Dennis Ritchie (K&amp;R) &quot;The C Programming Language&quot; 1978 book.</li>
<li>C90 (ISO/IEC 9899:1990 &quot;Programming Languages. C&quot;). Also known as ANSI C 89.</li>
<li>C99 (ISO/IEC 9899:1999 &quot;Programming Languages. C&quot;)</li>
<li>C11 (ISO/IEC 9899:2011 &quot;Programming Languages. C&quot;)</li>
</ol>

<h5>C Features</h5>
<p>[TODO]</p>

<h5>C Strength and Pitfall</h5>
<p>[TODO]</p>


<h3>Basic Syntaxes</h3>

<h4>Revision</h4>

<p>Below is a simple C program that illustrates the important programming constructs (<em>sequential flow</em>, <em>while-loop</em>, and <em>if-else</em>) and input/output. Read &quot;<a href="c0_Introduction.html">Introduction to Programming in C for Novices and First-time Programmers</a>&quot; if you need help in understanding this program.</p>



<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Sum the odd and even numbers, respectively, from 1 to a given upperbound.
 * Also compute the absolute difference.
 * (SumOddEven.c)
 */</span>
#include &lt;stdio.h&gt;  <span class="color-comment"> // Needed to use IO functions</span>
 
int main() {
   int sumOdd  = 0;<span class="color-comment"> // For accumulating odd numbers, init to 0</span>
   int sumEven = 0;<span class="color-comment"> // For accumulating even numbers, init to 0</span>
   int upperbound; <span class="color-comment"> // Sum from 1 to this upperbound</span>
   int absDiff;    <span class="color-comment"> // The absolute difference between the two sums</span>
 
  <span class="color-comment"> // Prompt user for an upperbound</span>
   printf(&quot;Enter the upperbound: &quot;);
   scanf(&quot;%d&quot;, &amp;upperbound);  <span class="color-comment"> // Use %d to read an int</span>
 
  <span class="color-comment"> // Use a while-loop to repeatedly add 1, 2, 3,..., to the upperbound</span>
   int number = 1;
   while (number &lt;= upperbound) {
      if (number % 2 == 0) { <span class="color-comment"> // Even number</span>
         sumEven += number;  <span class="color-comment"> // Add number into sumEven</span>
      } else {               <span class="color-comment"> // Odd number</span>
         sumOdd += number;   <span class="color-comment"> // Add number into sumOdd</span>
      }
      ++number;<span class="color-comment"> // increment number by 1</span>
   }
 
  <span class="color-comment"> // Compute the absolute difference between the two sums</span>
   if (sumOdd &gt; sumEven) {
      absDiff = sumOdd - sumEven;
   } else {
      absDiff = sumEven - sumOdd;
   }
 
  <span class="color-comment"> // Print the results</span>
   printf(&quot;The sum of odd numbers is %d.\n&quot;, sumOdd);
   printf(&quot;The sum of even numbers is %d.\n&quot;, sumEven);
   printf(&quot;The absolute difference is %d.\n&quot;, absDiff);
 
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Enter the upperbound: <strong>1000</strong>
The sum of odd numbers is 250000.
The sum of even numbers is 250500.
The absolute difference is 500.</pre>

<h4>Comments</h4>

<p>Comments are used to document and explain your codes and program logic.  Comments are not programming statements and are <em>ignored</em> by the compiler, but they VERY IMPORTANT for providing documentation and explanation for others to understand your program (and also for yourself three days later).</p>

<p>There are two kinds of comments in C:</p>

<ol>
<li><em>Multi-line Comment</em>: begins with a <code>/*</code> and ends with a <code>*/</code>, and can span several lines.</li>

<li><em>End-of-line Comment</em>: begins with <code>//</code> and lasts till the end of the current line.</li>
</ol>

<p>You should use comments <em>liberally</em> to explain and document your codes.  During program development, instead of deleting a chunk of statements permanently, you could <em>comment-out</em> these statements so that you could get them back later, if needed.</p>

<h4>Statements and Blocks</h4>

<p><span class="line-heading">Statement</span>: A programming <em>statement</em> is the smallest independent unit in a program, just like a sentence in the English language. It performs <em>a piece of programming action</em>. A programming statement must be terminated by a semi-colon (<code>;</code>), just like an English sentence ends with a period. (Why not ends with a period like an english sentence? This is because period crashes with decimal point - it is hard for the dumb computer to differentiate between period and decimal point!)</p>
<p>For examples,</p>

<pre class="color-example">
<span class="color-comment">// Each of the following lines is a programming statement, which ends with a semi-colon (;)</span>
int number1 = 10;
int number2, number3 = 99;
int product;
product = number1 * number2 * number3;
printf(&quot;Hello\n&quot;);</pre>

<p><span class="line-heading">Block</span>: A <em>block</em> (or a <em>compound statement</em>) is a group of  statements surrounded by braces <code>{ }</code>. All the statements inside the block is treated as one unit. Blocks are used as the <em>body</em> in constructs like function, if-else and loop, which may contain multiple statements but are treated as one unit. There is no need to put a semi-colon after the closing brace to end a complex statement. Empty block (without any statement) is permitted. For examples,</p>

<pre class="color-example">
<span class="color-comment">// Each of the followings is a &quot;complex&quot; statement comprising one or more blocks of statements.
// No terminating semi-colon needed after the closing brace to end the &quot;complex&quot; statement.
// Take note that a &quot;complex&quot; statement is usually written over a few lines for readability.</span>
if (mark &gt;= 50) {
   printf(&quot;PASS\n&quot;);
   printf(&quot;Well Done!\n&quot;);
   printf(&quot;Keep it Up!\n&quot;);
}
 
if (number == 88) {
   printf(&quot;Got it\n&quot;); 
} else { 
   printf(&quot;Try Again\n&quot;); 
}
 
i = 1;
while (i &lt; 8) {
   printf(&quot;%d\n&quot;, i);
   ++i; 
}
 
int main() {
   ...<em>statements...</em> 
}</pre>


<h4>White Spaces and Formatting Source Codes</h4>

<p><span class="line-heading">White Spaces</span>: <em>Blank</em>, <em>tab</em> and <em>new-line</em> are collectively called <em>white spaces</em>. C ignores <em>extra</em> white spaces.  That is, multiple contiguous white spaces are treated as a single white space. </p>

<p>You need to use a white space to separate two keywords or tokens, e.g.,</p>
<pre class="color-example">
int sum=0;          <span class="color-comment">// Need a white space between int and sum</span>
double average;     <span class="color-comment">// Need a white space between double and average</span>
average=sum/100.0;</pre>
<p>Additional white spaces and extra lines are, however, ignored, e.g.,</p>
<pre class="color-example">
<span class="color-comment">// same as above</span>
int  sum  
   =  0 ;

   double  average  ;
average = sum / 100.0;</pre>

<p><span class="line-heading">Formatting Source Codes</span>: As mentioned, extra white spaces are ignored and have no computational significance. However, proper indentation (with tabs and  blanks) and extra empty lines greatly improves the readability of the program, which is extremely important for others (and yourself three days later) to understand your programs. For example, the following hello-world works, but can you understand the program?</p>

<pre class="color-example">
<span class="color-comment"></span>#include &lt;stdio.h&gt;
int main(){printf(&quot;Hello, world!\n&quot;);return 0;}</pre>

<p><span class="line-heading">Braces</span>: Place the beginning brace at the end of the line, and align the ending brace with the start of the statement.</p>

<p><span class="line-heading">Indentation</span>: Indent the body of a block by an extra 3 (or 4 spaces), according to its <em>level</em>.</p>

<p>For example,</p>

<pre class="color-example">
<span class="color-comment">/*
 * Recommended Programming style.
 */</span>
#include &lt;stdio.h&gt;
                           <span class="color-comment">// blank line to separate sections of codes</span>
int main() <strong>{</strong>  <span class="color-comment">// Place the beginning brace at the end of the current line</span>
   <span class="color-comment">// Indent the body by an extra 3 or 4 spaces for each level</span>
   
   int mark = 70;
   if (mark &gt;= 50) <strong>{</strong>          <span class="color-comment">// in level-1 block, indent once</span>
      printf(&quot;You Pass!\n&quot;);  <span class="color-comment">// in level-2 block, indent twice</span>
   <strong>}</strong> else <strong>{</strong>
      printf(&quot;You Fail!\n&quot;);
   <strong>}</strong>
  
   return 0;
<strong>}</strong>   <span class="color-comment">// ending brace aligned with the start of the statement</span></pre>

<p>Most IDEs (such as CodeBlocks, Eclipse and NetBeans) have a command to <em>re-format</em> your source code automatically.</p>

<p>Note: Traditional C-style formatting places the beginning and ending braces on the same column. For example,</p>

<pre class="color-example">
<span class="color-comment">/*
 * Traditional C-style.
 */</span>
#include &lt;stdio.h&gt;
 
int main()
<strong>{</strong>
   int mark = 70;
   if (mark &gt;= 50)            <span class="color-comment">// in level-1 block, indent once</span>
   <strong>{</strong>
      printf(&quot;You Pass!\n&quot;);  <span class="color-comment">// in level-2 block, indent twice</span>
   <strong>}</strong>
   else
   <strong>{</strong>
      printf(&quot;You Fail!\n&quot;);
   <strong>}</strong>
 
   return 0;
<strong>}</strong></pre>

<h4>Preprocessor Directives</h4>

<p>C source code is <em>preprocessed</em> before it is <em>compiled</em> into object code (as illustrated).</p>

<img class="image-center" src="images/C_DevelopmentProcesses.png" alt="C_DevelopmentProcesses.png" />

<p>A <em>preprocessor directive</em>, which begins with a <code>#</code> sign (such as <code>#include</code>, <code>#define</code>), tells the preprocessor to perform a certain action (such as including a header file, or performing text replacement), before compiling the source code into object code. Preprocessor directives  are not programming statements, and therefore should NOT be terminated with a semi-colon. For example,</p>

<pre class="color-example">
#include &lt;stdio.h&gt;     <span class="color-comment">// To include the IO library header</span>
#include &lt;math.h&gt;      <span class="color-comment">// To include the Math library header</span>
#define PI 3.14159265  <span class="color-comment">// To substitute the term PI with 3.14159265 in this file</span>
   <span class="color-comment"></span><span class="color-new">// DO NOT terminate preprocessor directive with a semi-colon</span></pre>
   
<p>In almost all of the C programs, we use <code>#include &lt;stdio.h&gt;</code> to include the input/output stream library header into our program, so as to use the IO library function to carry out input/output operations (such as <code>printf()</code> and <code>scanf()</code>).</p>

<p>More on preprocessor directives later.</p>

<h3>Variables and Types</h3>

<h4>Variables</h4>

<p>Computer programs manipulate (or process) data. A <em>variable</em> is used to <em>store a piece of data</em> for processing. It is called <em>variable</em> because you can change the value stored.</p>

<p>More precisely, a <em>variable</em> is a <em>named</em> storage location, that stores a <em>value</em> of a particular data <em>type</em>. In other words, a <em>variable</em> has a <em>name</em>, a <em>type</em> and stores a <em>value</em>.</p>

<ul>
<li>A variable has a <em>name</em> (or <em>identifier</em>), e.g., <code>radius</code>, <code>area</code>, <code>age</code>, <code>height</code>. The name is needed to uniquely identify each variable, so as to assign a value to the variable (e.g., <code>radius=1.2</code>), and retrieve the value stored (e.g., <code>area = radius*radius*3.1416</code>).</li>

<li>A variable has a <em>type</em>. Examples of <em>type</em> are,

<ul>
<li><code>int</code>: for integers (whole numbers) such as <code>123</code> and <code>-456</code>;</li>

<li><code>double</code>: for floating-point or real numbers such as <code>3.1416</code>, <code>-55.66</code>, having a decimal point and fractional part.</li>
</ul></li>

<li>A variable can store a <em>value</em> of that particular <em>type</em>. It is important to take note that a variable in most programming languages is associated with a type, and can only store value of the particular type. For example, a <code>int</code> variable can store an integer value such as <code>123</code>, but NOT real number such as <code>12.34</code>, nor texts such as <code>&quot;Hello&quot;</code>.</li>

<li>The concept of <em>type</em> was introduced into the early programming languages to simplify interpretation of data made up of 0s and 1s. The type determines the size and layout of the data, the range of its values, and the set of operations that can be applied.</li>
</ul>

<p>The following diagram illustrates two types of variables: <code>int</code> and <code>double</code>. An <code>int</code> variable stores an integer (whole number). A <code>double</code> variable stores a real number.</p>
<img class="image-center" src="images/BasicsVariable.png" alt="variable" />

<h4>Identifiers</h4>

<p>An <em>identifier</em> is needed to <em>name</em> a variable (or any other entity such as a function or a class). C imposes the following <em>rules on identifiers</em>:</p>

<ul>
<li>An identifier is a sequence of characters, of up to a certain length (compiler-dependent, typically 255 characters), comprising uppercase and lowercase letters <code>(a-z, A-Z)</code>, digits <code>(0-9)</code>, and underscore <code>&quot;_&quot;</code>.</li>

<li>White space (blank, tab, new-line) and other special characters (such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,  <code>@</code>, <code>&amp;</code>, commas, etc.) are not allowed.</li>

<li>An identifier must begin with a letter or underscore. It cannot begin with a digit. Identifiers beginning with an underscore are typically reserved for system use.</li>

<li>An identifier cannot be a reserved keyword or a reserved literal (e.g.,<code>int</code>, <code>double</code>, <code>if</code>, <code>else</code>, <code>for</code>).</li>

<li>Identifiers are case-sensitive. A <code>rose</code> is NOT a <code>Rose</code>, and is NOT a <code>ROSE</code>.</li>
</ul>

<p><span class="line-heading color-error">Caution</span>: Programmers don't use <em>blank</em> character in names. It is either not supported, or will pose you more challenges.</p>

<h5>Variable Naming Convention</h5>

<p>A variable name is a noun, or a noun phrase made up of several  words. The first word is in lowercase, while the remaining words are initial-capitalized, with no spaces between words. For example, <code>thefontSize</code>, <code>roomNumber</code>, <code>xMax</code>, <code>yMin</code>,  <code>xTopLeft</code> and <code>thisIsAVeryLongVariableName</code>. This convention is also known as <em>camel-case</em>.</p>

<h5>Recommendations</h5>

<ol>
<li>It is important to choose a name that is <em>self-descriptive</em> and closely reflects the meaning of the variable, e.g., <code>numberOfStudents</code> or <code>numStudents</code>.</li>

<li>Do not use meaningless names like <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>i</code>, <code>j</code>, <code>k</code>, <code>i1</code>, <code>j99</code>.</li>

<li>Avoid single-alphabet names, which is easier to type but often meaningless, unless they are common names like <code>x</code>, <code>y</code>, <code>z</code> for coordinates, <code>i</code> for index.</li>

<li>It is perfectly okay to use long names of says 30 characters to make sure that the name accurately reflects its meaning!</li>

<li>Use singular and plural nouns  prudently to differentiate between singular and plural variables.  For example, you may use the variable <code>row</code> to refer to a single row number and the variable <code>rows</code>  to refer to many rows (such as an array of rows - to be discussed later).</li>
</ol>

<h4>Variable Declaration</h4>

<p>To use a variable in your program, you need to first &quot;introduce&quot; it by <em>declaring</em> its <em>name</em> and <em>type</em>, in one of the following syntaxes:</p>

<table class="table-program">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>
<tr>
<td><pre class="color-syntax"><span class="color-comment">// Declare a variable of a specified type</span>
<em>type identifier</em><strong>;</strong>
<span class="color-comment">// Declare multiple variables of the same type, separated by commas</span>
<em>type identifier-1</em><strong>,</strong> <em>identifier-2</em><strong>,</strong> ...<strong>,</strong> <em>identifier-n</em><strong>;</strong>
<span class="color-comment">// Declare a variable and assign an initial value</span>
<em>type identifier</em> <strong>=</strong> <em>value</em><strong>;</strong>
<span class="color-comment">// Declare multiple variables with initial values</span>
<em>type identifier-1</em> <strong>=</strong> <em>value-1</em><strong>,</strong> ...<strong>,</strong> <em>identifier-n</em> <strong>=</strong> <em>value-n</em><strong>;</strong></pre>
</td>

<td>
<pre class="color-example">&nbsp;
int option;
&nbsp;
double sum, difference, product, quotient;
&nbsp;
int magicNumber = 88;
&nbsp;
double sum = 0.0, product = 1.0;</pre>
</td>
</tr>
</table>

<p>Example,</p>

<pre class="color-example">
int mark1;           <span class="color-comment">// Declare an int variable called mark1</span>
mark1 = 76;          <span class="color-comment">// Use mark1</span>
int mark2;           <span class="color-comment">// Declare int variable mark2</span>
mark2 = mark1 + 10;  <span class="color-comment">// Use mark2 and mark1</span>
double average;      <span class="color-comment">// Declare double variable average</span>
average = (mark1 + mark2) / 2.0;   <span class="color-comment">// Use average, mark1 and mark2</span>
<span class="color-error">int mark1;</span>           <span class="color-comment">// Error: Declare twice</span>
<span class="color-error">mark2 = &quot;Hello&quot;;</span>     <span class="color-comment">// Error: Assign value of a different type</span></pre>

<p>Take note that:</p>

<ul>
<li>In C, you need to declare the name of a variable before it can be used.</li>

<li>C is a &quot;strongly-type&quot; language. A variable takes on a  type. Once the <em>type</em> of a variable is declared, it can only store a value belonging to this particular type. For example, an <code>int</code> variable can hold only integer such as <code>123</code>, and NOT floating-point number such as <code>-2.17</code> or text string such as <code>&quot;Hello&quot;</code>. The concept of <em>type</em> was introduced into the early programming languages to simplify interpretation of data made up of 0s and 1s. Knowing the <em>type</em> of a piece of data greatly simplifies its interpretation and processing.</li>

<li>Each variable can only be declared once.</li>

<li>In C, you can declare a variable anywhere inside the program, as long as it is declared before used. (In C prior to C99, all the variables must be declared at the beginning of functions.) It is recommended that your declare a variable just before it is first used.</li>

<li> The type of a variable cannot be changed inside the program.</li>
</ul>

<h5><span class="color-error">CAUTION</span>: Uninitialized Variables</h5>

<p>When a variable is declared, it contains garbage until you assign an initial value. It is important to take note that C does not issue any warning/error if you use a variable before initialize it - which certainly leads to some unexpected results. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8</pre>
</td>
<td>
<pre>
#include &lt;stdio.h&gt;
 
int main() {
   int number;          <span class="color-comment">    // Declared but not initialized</span>
   printf(&quot;%d\n&quot;, number); <span class="color-comment"> // Used before initialized
                            // No warning/error, BUT unexpected result</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Constants (<span class="font-code">const</span>)</h4>

<p>Constants are <em>non-modifiable</em> variables, declared with keyword <code>const</code>. Their values cannot be changed during program execution. Also, <code>const</code> must be initialized during declaration. For examples:</p>
<pre class="color-example">
<strong>const</strong> double PI = 3.1415926;  <span class="color-comment">// Need to initialize</span></pre>

<p><span class="line-heading">Constant Naming Convention:</span> Use uppercase words, joined with underscore. For example, <code>MIN_VALUE</code>, <code>MAX_SIZE</code>.</p>

<h4>Expressions</h4>

<p>An <em>expression</em> is a combination of <em>operators</em> (such as addition <code>'+'</code>, subtraction <code>'-'</code>, multiplication <code>'*'</code>, division <code>'/'</code>) and <em>operands</em> (variables or literal values), that can be <em>evaluated to yield a single value of a certain type</em>. For example,</p>

<pre class="color-example">
<span class="color-comment"></span>1 + 2 * 3           <span class="color-comment">// give int 7</span>
 
int sum, number;
sum + number        <span class="color-comment">// evaluated to an int value</span>
 
double principal, interestRate;
principal * (1 + interestRate)  <span class="color-comment">// evaluated to a double value</span></pre>

<h4>Assignment (<span class="font-code">=</span>)</h4>

<p>An <em>assignment statement</em>:</p>

<ol>
<li>assigns a literal value (of the RHS) to a variable (of the LHS); or</li>
<li>evaluates an expression (of the RHS) and assign the resultant value to a variable (of the LHS).</li>
</ol>

<p>The RHS shall be a value; and the LHS shall be a variable (or memory address).</p>

<p>The syntax for assignment statement is:</p>

<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
  </tr>
  <tr>
    <td><pre class="color-syntax"><span class="color-comment">// Assign the literal value (of the RHS) to the variable (of the LHS)</span>
<em>variable</em> <strong>=</strong> <em>literal-value</em><strong>;</strong>
<span class="color-comment">// Evaluate the expression (RHS) and assign the result to the variable (LHS)</span>
<em>variable</em> <strong>=</strong> <em>expression</em><strong>;</strong></pre></td>
    <td><pre class="color-example">&nbsp;
number = 88;
&nbsp;
sum = sum + number;</pre></td>
  </tr>
</table>
<p>The assignment statement should be interpreted this way: The <em>expression</em> on the right-hand-side (RHS) is first evaluated to produce a resultant value (called <em>rvalue</em> or right-value). The <em>rvalue</em> is then assigned to the variable on the left-hand-side (LHS) (or <em>lvalue</em>, which is a location that can hold a <em>rvalue</em>). Take note that you have to first evaluate the RHS, before assigning the resultant value to the LHS. For examples,</p>
<pre class="color-example">
number = 8;           <span class="color-comment">// Assign literal value of 8 to the variable number</span>
number = number + 1;  <span class="color-comment">// Evaluate the expression of number + 1,
                      //  and assign the resultant value back to the variable number</span></pre>
<p>The symbol &quot;<code>=</code>&quot; is known as the <em>assignment operator</em>. The meaning of &quot;<code>=</code>&quot; in programming is different from Mathematics. It denotes <em>assignment</em> instead of <em>equality</em>. The RHS is a literal value; or an expression that evaluates to a value; while the LHS must be a variable. Note that <code>x = x + 1</code> is valid (and often used) in programming. It evaluates <code>x + 1</code> and assign the resultant value to the variable <code>x</code>. <code>x = x + 1</code> illegal in Mathematics. While <code>x + y = 1</code> is allowed in Mathematics, it is invalid in programming (because the LHS of an assignment statement must be a variable). Some programming languages use symbol &quot;<code>:=</code>&quot;, &quot;&larr;&quot;, &quot;-&gt;&quot;, or &quot;&rarr;&quot; as the assignment operator to avoid confusion with equality.</p>

<h4>Fundamental Types</h4>

<p><span class="line-heading">Integers:</span> C supports these integer types: <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> (in C11) in a non-decreasing order of size. The actual size depends on the implementation. The integers (except <code>char</code>) are <em>signed</em> number (which can hold zero, positive and negative numbers). You could use the keyword <code>unsigned [char|short|int|long|long long]</code> to declare an <em>unsigned</em> integers (which can hold zero and positive numbers). There are a total 10 types of integers - <code>signed|unsigned</code> combined with <code>char|short|int|long|long long</code>.</p>

<p><span class="line-heading">Characters:</span> Characters (e.g., <code>'a'</code>, <code>'Z'</code>, <code>'0'</code>, <code>'9'</code>) are encoded in ASCII into integers, and kept in type <code>char</code>. For example, character <code>'0'</code> is <code>48</code> (decimal) or <code>30H</code> (hexadecimal); character <code>'A'</code> is <code>65</code> (decimal) or <code>41H</code> (hexadecimal); character <code>'a'</code> is <code>97</code> (decimal) or <code>61H</code> (hexadecimal). Take note that the type <code>char</code> can be interpreted as character in ASCII code, or an 8-bit integer. Unlike <code>int</code> or <code>long</code>, which is <code>signed</code>, <code>char</code> could be <code>signed</code> or <code>unsigned</code>, depending on the implementation. You can use <code>signed char</code> or <code>unsigned char</code> to explicitly declare <code>signed</code> or <code>unsigned char</code>.</p>

<p><span class="line-heading">Floating-point Numbers:</span> There are 3 floating point types: <code>float</code>, <code>double</code> and <code>long double</code>, for single, double and long double precision floating point numbers. <code>float</code> and <code>double</code> are represented as specified by IEEE 754 standard. A <code>float</code> can represent a number between <code>&plusmn;1.40239846&times;10^-45</code> and <code>&plusmn;3.40282347&times;10^38</code>, approximated. A <code>double</code> can represented a number between <code>&plusmn;4.94065645841246544&times;10^-324</code> and <code>&plusmn;1.79769313486231570&times;10^308</code>, approximated. Take note that not all real numbers can be represented by <code>float</code> and <code>double</code>, because there are infinite real numbers. Most of the values are approximated.</p>

<p>The table below shows the <em>typical</em> size, minimum, maximum for the primitive types. Again, take note that the sizes are implementation dependent.</p>

<table class="table-zebra">
  <thead>
  <tr>
    <th>Category</th>
    <th>Type</th>
    <th>Description</th>
    <th>Bytes<br />(Typical)</th>
    <th>Minimum<br />(Typical)</th>
    <th>Maximum<br />(Typical)</th>
  </tr>
  </thead>
  <tbody class="font-code"> 
  
  <tr>
    <td rowspan="11">Integers</td>
    <td>int<br />
      (or signed int)</td>
    <td class="font-normal">Signed integer (of at least 16 bits)</td>
    <td>4 (2)</td>
    <td>-2147483648</td>
    <td>2147483647</td>
  </tr>
  <tr class="tr-alt">
    <td>unsigned int</td>
    <td class="font-normal">Unsigned integer (of at least 16 bits)</td>
    <td>4 (2)</td>
    <td>0</td>
    <td>4294967295</td>
  </tr>
  <tr>
    <td>char</td>
    <td class="font-normal">Character <br />
      (can be either signed or unsigned depends on implementation)</td>
    <td>1</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr class="tr-alt">
    <td>signed char</td>
    <td class="font-normal">Character or signed tiny integer <br />
      (guarantee to be signed)</td>
    <td>1</td>
    <td>-128</td>
    <td>127</td>
  </tr>
  <tr>
    <td>unsigned char</td>
    <td class="font-normal">Character or unsigned tiny integer  <br />
      (guarantee to be unsigned)</td>
    <td>1</td>
    <td>0</td>
    <td>255</td>
  </tr>
  <tr class="tr-alt">
    <td>short <br />
      (or short int)<br />
      (or signed short)<br />
      (or signed short int)</td>
    <td class="font-normal">Short signed integer (of at least 16 bits)</td>
    <td>2</td>
    <td>-32768</td>
    <td>32767</td>
  </tr>
  <tr>
    <td>unsigned short<br />
      (or unsigned shot int)</td>
    <td class="font-normal">Unsigned short integer (of at least 16 bits)</td>
    <td>2</td>
    <td>0</td>
    <td>65535</td>
  </tr>
  <tr class="tr-alt">
    <td>long <br />
      (or long int)<br />
      (or signed long)<br />
      (or signed long int)</td>
    <td class="font-normal">Long signed integer (of at least 32 bits)</td>
    <td>4 (8)</td>
    <td>-2147483648</td>
    <td>2147483647</td>
  </tr>
  <tr>
    <td>unsigned long<br />
      (or unsigned long int)</td>
    <td class="font-normal">Unsigned long integer (of at least 32 bits)</td>
    <td>4 (8)</td>
    <td>0</td>
    <td class="font-normal">same as above</td>
  </tr>
  <tr class="tr-alt">
    <td>long long <br />
      (or long long int)<br />
      (or signed long long)<br />
      (or signed long long int)</td>
    <td class="font-normal">Very long signed integer (of at least 64 bits)</td>
    <td>8</td>
    <td>-2<sup>63</sup></td>
    <td>2<sup>63</sup>-1</td>
  </tr>
  <tr>
    <td>unsigned long long<br />
      (or unsigned long long int)</td>
    <td class="font-normal">Unsigned very long integer (of at least 64 bits)</td>
    <td>8</td>
    <td>0</td>
    <td>2<sup>64</sup>-1</td>
  </tr>
  <tr class="tr-alt">
    <td rowspan="3">Real Numbers</td>
    <td>float</td>
    <td class="font-normal">Floating-point number, &asymp;7 digits<br />
    (IEEE 754 single-precision floating point format)</td>
    <td>4</td>
    <td>3.4e38</td>
    <td>3.4e-38</td>
  </tr>
  <tr>
    <td>double</td>
    <td class="font-normal">Double precision floating-point number, &asymp;15 digits<br />
    (IEEE 754 double-precision floating point format)</td>
    <td>8</td>
    <td>1.7e308</td>
    <td>1.7e-308</td>
  </tr>
  <tr class="tr-alt">
    <td>long double</td>
    <td class="font-normal">Long double precision floating-point number, &asymp;19 digits<br />
    (IEEE 754 quadruple-precision floating point format)</td>
    <td>12 (8)</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>Wide <br />
      Characters</td>
    <td>wchar_t</td>
    <td class="font-normal">Wide (double-byte) character</td>
    <td>2 (4)</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  </tbody>
</table>

<p>In addition, many C library functions use a type called <code>size_t</code>, which is equivalent (<code>typedef</code>) to a <code>unsigned int</code>, meant for counting, size or length, with 0 and positive integers.</p>

<h5>*The <span class="font-code">sizeof</span> Operator</h5>

<p>C provides an unary <code>sizeof</code> operator to get the size of the operand (in bytes). The following program uses <code>sizeof</code> operator to print the size of the fundamental types.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Print Size of Fundamental Types (SizeofTypes.cpp).
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   printf(&quot;sizeof(char) is %d bytes.\n&quot;, sizeof(char));
   printf(&quot;sizeof(short) is %d bytes.\n&quot;, sizeof(short));
   printf(&quot;sizeof(int) is %d bytes.\n&quot;, sizeof(int));
   printf(&quot;sizeof(long) is %d bytes.\n&quot;, sizeof(long));
   printf(&quot;sizeof(long long) is %d bytes.\n&quot;, sizeof(long long));
   printf(&quot;sizeof(float) is %d bytes.\n&quot;, sizeof(float));
   printf(&quot;sizeof(double) is %d bytes.\n&quot;, sizeof(double));
   printf(&quot;sizeof(long double) is %d bytes.\n&quot;, sizeof(long double));
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
sizeof(char) is 1 bytes.
sizeof(short) is 2 bytes.
sizeof(int) is 4 bytes.
sizeof(long) is 4 bytes.
sizeof(long long) is 8 bytes.
sizeof(float) is 4 bytes.
sizeof(double) is 8 bytes.
sizeof(long double) is 12 bytes.</pre>

<p>The results may vary among different systems.</p>

<h5>*Header <span class="font-code">&lt;limits.h&gt;</span></h5>

<p>The <code>limits.h</code> header contains information about limits of integer type. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test integer limits in &lt;limits.h&gt; header */</span>
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;  <span class="color-comment"> // integer limits</span>
 
int main() {
   printf(&quot;int max = %d\n&quot;, INT_MAX);
   printf(&quot;int min = %d\n&quot;, INT_MIN);
   printf(&quot;unsigned int max = %u\n&quot;, UINT_MAX);
 
   printf(&quot;long max = %ld\n&quot;, LONG_MAX);
   printf(&quot;long min = %ld\n&quot;, LONG_MIN);
   printf(&quot;unsigned long max = %lu\n&quot;, ULONG_MAX);
 
   printf(&quot;long long max = %lld\n&quot;, LLONG_MAX);
   printf(&quot;long long min = %lld\n&quot;, LLONG_MIN);
   printf(&quot;unsigned long long max = %llu\n&quot;, ULLONG_MAX);
 
   printf(&quot;Bits in char = %d\n&quot;, CHAR_BIT);
   printf(&quot;char max = %d\n&quot;, CHAR_MAX);
   printf(&quot;char min = %d\n&quot;, CHAR_MIN);
   printf(&quot;signed char max = %d\n&quot;, SCHAR_MAX);
   printf(&quot;signed char min = %d\n&quot;, SCHAR_MIN);
   printf(&quot;unsigned char max = %u\n&quot;, UCHAR_MAX);
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
int max = 2147483647
int min = -2147483648
unsigned int max = 4294967295
long max = 2147483647
long min = -2147483648
unsigned long max = 4294967295
long long max = 9223372036854775807
long long min = -9223372036854775808
unsigned long long max = 18446744073709551615
Bits in char = 8
char max = 127
char min = -128
signed char max = 127
signed char min = -128
unsigned char max = 255</pre>

<p>Again, the outputs depend on the system.</p>

<p>The minimum of unsigned integer is always 0. The other constants are <code>SHRT_MAX</code>, <code>SHRT_MIN</code>, <code>USHRT_MAX</code>, <code>LONG_MIN</code>, <code>LONG_MAX</code>, <code>ULONG_MAX</code>. Try inspecting this header (search for <code>limits.h</code> under your compiler).</p>

<h5>*Header <span class="font-code">&lt;float.h&gt;</span></h5>

<p>Similarly, the <code>float.h</code> header contain information on limits for floating point numbers, such as minimum number of significant digits (<code>FLT_DIG</code>, <code>DBL_DIG</code>, <code>LDBL_DIG</code> for <code>float</code>, <code>double</code> and <code>long double</code>), number of bits for mantissa (<code>FLT_MANT_DIG</code>, <code>DBL_MANT_DIG</code>, <code>LDBL_MANT_DIG</code>), maximum and minimum exponent values, etc. Try inspecting this header (search for <code>cfloat</code> under your compiler).</p>

<h5>Choosing Types</h5>

<p>As a programmer, you need to choose variables and decide on the type of the variables to be used in your programs. Most of the times, the decision is intuitive. For example, use an integer type for counting and whole number; a floating-point type for number with fractional part,<code> char</code> for a single character, and <code>boolean</code> for binary outcome.</p>

<h5>Rule of Thumb</h5>

<ul>
<li>Use <code>int</code> for integer and <code>double</code> for floating point numbers. Use <code>byte</code>, <code>short</code>, <code>long</code> and <code>float</code> only if you have a good reason to choose that specific precision.</li>

<li>Use <code>int</code> (or <code>unsigned int</code>) for <em>counting</em> and <em>indexing</em>, NOT floating-point type (<code>float</code> or <code>double</code>). This is because integer type are precise and more efficient in operations.</li>

<li>Use an integer type if possible. Use a floating-point type only if the number contains a fractional part.</li>
</ul>

<p>Read my article on &quot;<a href="../java/DataRepresentation.html">Data Representation</a>&quot; if you wish to understand how the numbers and characters are represented inside the computer memory. In brief,  It is important to take note that <code>char '1'</code> is different from <code>int 1</code>, <code>short 1</code>, <code>float 1.0</code>, <code>double 1.0</code>, and <code>String &quot;1&quot;</code>. They are represented differently in the computer memory, with different precision and interpretation. For example, <code>short 1</code> is <code>&quot;00000000 00000001&quot;</code>, <code>int 1</code> is <code>&quot;00000000 00000000 00000000 00000001&quot;</code>, <code>long long 1</code> is <code>&quot;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001&quot;</code>, <code>float 1.0</code> is <code>&quot;0 01111111 0000000 00000000 00000000&quot;</code>, <code>double 1.0</code> is <code>&quot;0 01111111111 0000 00000000 00000000 00000000 00000000 00000000 00000000&quot;</code>, <code>char '1'</code> is <code>&quot;00110001&quot;</code>.</p>

<p> There is a subtle difference between <code>int 0</code> and <code>double 0.0</code>.</p>

<p>Furthermore, you MUST know the type of a value before you can interpret a value. For example, this value <code>&quot;00000000 00000000 00000000 00000001&quot;</code> cannot be interpreted unless you know the type.</p>

<h5>*The <span class="font-code">typedef</span> Statement</h5>

<p>Typing &quot;<code>unsigned int</code>&quot; many time  can get annoying. The <code>typedef</code> statement can be used to create a new name for an existing type. For example, you can create a new type called &quot;<code>uint</code>&quot; for &quot;<code>unsigned int</code>&quot; as follow. You should place the <code>typedef</code> immediately after <code>#include</code>. Use <code>typedef</code> with care because it makes the program hard to read and understand.<br />
</p>

<pre class="color-example">
typedef unsigned int uint;</pre>

<p>Many C compilers define a type called <code>size_t</code>, which is a <code>typedef</code> of <code>unsigned int</code>.</p>
<pre class="color-example">
typedef unsigned int size_t;</pre>


<h4>Output via <span class="font-code">printf()</span> Function</h4>

<p>C programs use function <code>printf()</code> of library <code>stdio</code> to print output to the console. You need to issue a so-called <em>preprocessor directive</em> &quot;<code>#include &lt;stdio.h&gt;</code>&quot; to use <code>printf()</code>.</p>

<p>To print a string literal such as &quot;Hello, world&quot;, simply place it inside the parentheses, as follow:</p>

<pre class="color-syntax">
printf(<em>aStringLiteral</em>);</pre>

<p>For example,</p>
<pre class="color-example">
printf(&quot;Hello, world\n&quot;);</pre>

<pre class="output">
Hello, world
_</pre>

<p>The <code>\n</code> represents the <em>newline</em> character. Printing a newline advances the cursor (denoted by <code>_</code> in the above example) to the beginning of next line. <code>printf()</code>, by default, places the cursor after the printed string, and does not advance the cursor to the next line. For example,</p>

<pre class="color-example">
printf(&quot;Hello&quot;);
printf(&quot;, &quot;);
printf(&quot;world!&quot;);
printf(&quot;\n&quot;);
printf(&quot;Hello\nworld\nagain\n&quot;);</pre>

<pre class="output">
Hello, world!
Hello
world
again
_</pre>

<h5>Formatted Output via <span class="font-code">printf()</span></h5>

<p>The &quot;<code>f</code>&quot; in <code>printf()</code> stands for &quot;formatted&quot; printing. To do formatted printing, you need to use the following syntax:</p>
<pre class="color-syntax">
printf(<em>formattingString</em>, <em>variable1</em>, <em>variable2</em>, ...)</pre>

<p>The <em>formattingString</em> is a string composing of normal texts and <em>conversion specifiers</em>. Normal texts will be printed as they are. A conversion specifier begins with a percent sign (<code>%</code>), followed by a code to specify the type of variable and format of the output (such as the field width and number of decimal places). For example, <code>%d</code> denotes an int; <code>%3d</code> for an <code>int</code> with field-width of 3. The conversion specifiers are used as <em>placeholders</em>, which will be substituted by the variables given after the formatting string in a sequential manner. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Test formatted printing for int (TestPrintfInt.c)
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int number1 = 12345, number2 = 678;
   printf(&quot;Hello, number1 is <span class="color-new">%d</span>.\n&quot;, number1);               <span class="color-comment"> // 1 format specifier</span>
   printf(&quot;number1=<span class="color-new">%d</span>, number2=<span class="color-new">%d</span>.\n&quot;, number1, number2);    <span class="color-comment"> // 2 format specifiers</span>
   printf(&quot;number1=<span class="color-new">%8d</span>, number2=<span class="color-new">%5d</span>.\n&quot;, number1, number2);  <span class="color-comment"> // Set field-widths</span>
   printf(&quot;number1=<span class="color-new">%08d</span>, number2=<span class="color-new">%05d</span>.\n&quot;, number1, number2);<span class="color-comment"> // Pad with zero</span>
   printf(&quot;number1=<span class="color-new">%-8d</span>, number2=<span class="color-new">%-5d</span>.\n&quot;, number1, number2);<span class="color-comment"> // Left-align</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Hello, number1 is 12345.
number1=12345, number2=678.
number1=   12345, number2=  678.
number1=00012345, number2=00678.
number1=12345   , number2=678  .</pre>

<h5>Type Conversion Code</h5>

<p>The commonly-used type conversion codes are:</p>

<table class="table-zebra" style="width:80%">
<tr>
<th>Type</th>
<th>Type Conversion Code</th>
<th>Type &amp; Format</th>
</tr>

<tr>
<td rowspan="7">Integers</td>
<td><code>%d</code> (or <code>%i</code>)</td>
<td><code>(signed) int</code></td>
</tr>

<tr class="tr-alt">
<td><code>%u</code></td>
<td><code>unsigned int</code></td>
</tr>

<tr>
<td><code>%o</code></td>
<td><code>int</code> in octal</td>
</tr>

<tr class="tr-alt">
<td><code>%x, %X</code></td>
<td><code>int</code> in hexadecimal (<code>%X</code> uses uppercase A-F)</td>
</tr>

<tr>
<td><code>%hd, %hu</code></td>
<td><code>short</code>, <code>unsigned short</code></td>
</tr>

<tr class="tr-alt">
<td><code>%ld</code>, <code>%lu</code></td>
<td><code>long</code>, <code>unsigned long</code></td>
</tr>

<tr>
<td><code>%lld</code>, <code>%llu</code></td>
<td><code>long long</code>, <code>unsigned long long</code></td>
</tr>

<tr class="tr-alt">
<td rowspan="5">Floating-point</td>
<td><code>%f</code></td>
<td><code>float</code> in fixed notation</td>
</tr>

<tr>
<td><code>%e, %E</code></td>
<td><code>float</code> in scientific notation</td>
</tr>

<tr class="tr-alt">
<td><code>%g, %G</code></td>
<td><code>float</code> in fixed/scientific notation depending on its value</td>
</tr>

<tr>
<td><code>%f</code>, <code>%lf</code> (<code>printf</code>), <code>%lf</code> (<code>scanf</code>) </td>
<td> <code>double</code>: Use <code>%f</code> or <code>%lf</code> in <code>printf()</code>, but <code>%lf</code> in <code>scanf()</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>%Lf</code>, <code>%Le</code>, <code>%LE</code>, <code>%Lg</code>, <code>%LG</code></td>
<td><code>long double</code></td>
</tr>

<tr>
<td>Character</td>
<td><code>%c</code></td>
<td><code>char</code></td>
</tr>

<tr class="tr-alt">
<td>String</td>
<td><code>%s</code></td>
<td>string</td>
</tr>
</table>

<p>Notes:</p>
<ul>
<li>For <code>double</code>, you must use <code>%lf</code> (for long float) in <code>scanf()</code> (or <code>%le</code>, <code>%lE</code>, <code>%lg</code>, <code>%lG</code>), but you can use either <code>%f</code> or <code>%lf</code> in <code>printf()</code> (or <code>%e</code>, <code>%E</code>, <code>%g</code>, <code>%G</code>, <code>%le</code>, <code>%lE</code>, <code>%lg</code>, <code>%lG</code>).</li>
<li>Use <code>%%</code> to print a <code>%</code> in the formatting string.</li>
</ul>

<p>For example,</p>
<pre class="color-example">
int anInt = 12345;
float aFloat = 55.6677;
double aDouble = 11.2233;
char aChar = 'a';
char aStr[] = &quot;Hello&quot;;
 
printf(&quot;The int is <span class="highlight">%d</span>.\n&quot;, anInt);
<span class="color-comment">//The int is 12345.</span>
printf(&quot;The float is <span class="highlight">%f</span>.\n&quot;, aFloat);
<span class="color-comment">//The float is 55.667702.</span>
printf(&quot;The double is <span class="highlight">%lf</span>.\n&quot;, aDouble);
<span class="color-comment">//The double is 11.223300.</span>
printf(&quot;The char is <span class="highlight">%c</span>.\n&quot;, aChar);
<span class="color-comment">//The char is a.</span>
printf(&quot;The string is <span class="highlight">%s</span>.\n&quot;, aStr);
<span class="color-comment">//The string is Hello.</span>
   
printf(&quot;The int (in hex) is <span class="highlight">%x</span>.\n&quot;, anInt);
<span class="color-comment">//The int (in hex) is 3039.</span>
printf(&quot;The double (in scientific) is <span class="highlight">%le</span>.\n&quot;, aDouble);
<span class="color-comment">//The double (in scientific) is 1.122330e+01.</span>
printf(&quot;The float (in scientific) is <span class="highlight">%E</span>.\n&quot;, aFloat);
<span class="color-comment">//The float (in scientific) is 5.566770E+01.</span></pre>

<p>Using the wrong type conversion code usually produces garbage.</p>

<h5>Field Width</h5>

<p>You can optionally specify a field-width before the type conversion code, e.g., <code>%3d</code>, <code>%6f</code>, <code>%20s</code>. If the value to be formatted is shorter than the field width, it will be padded with spaces (by default). Otherwise, the field-width will be ignored. For example,</p>

<pre class="color-example">
int number = 123456;
printf(&quot;number=<span class="highlight">%d</span>.\n&quot;, number);
<span class="color-comment">// number=123456.</span>
printf(&quot;number=<span class="highlight">%8d</span>.\n&quot;, number);
<span class="color-comment">// number=  123456.</span>
printf(&quot;number=<span class="highlight">%3d</span>.\n&quot;, number);  <span class="color-comment">// Field-width too short. Ignored.</span>
<span class="color-comment">// number=123456.</span></pre>

<h5>Precision (Decimal Places) for Floating-point Numbers</h5>
<p>For floating-point numbers, you can optionally specify the number of decimal places to be printed, e.g., <code>%6.2f</code>, <code>%8.3f</code>. For example,</p>

<pre class="color-example">
double value = 123.14159265;
printf(&quot;value=<span class="highlight">%lf</span>;\n&quot;, value);
<span class="color-comment">//value=123.141593;</span>
printf(&quot;value=<span class="highlight">%6.2lf</span>;\n&quot;, value);
<span class="color-comment">//value=123.14;</span>
printf(&quot;value=<span class="highlight">%9.4lf</span>;\n&quot;, value);
<span class="color-comment">//value= 123.1416;</span>
printf(&quot;value=<span class="highlight">%3.2lf</span>;\n&quot;, value);  <span class="color-comment">// Field-width too short. Ignored.</span>
<span class="color-comment">//value=123.14;</span></pre>

<h5>Alignment</h5>

<p>The output  are right-aligned by default. You could include a &quot;<code>-</code>&quot; flag (before the field width) to ask for left-aligned. For example,</p>

<pre class="color-example">
int i1 = 12345, i2 = 678;
printf(&quot;Hello, first int is <span class="highlight">%d</span>, second int is <span class="highlight">%5d</span>.\n&quot;, i1, i2);
<span class="color-comment">//Hello, first int is 12345, second int is   678.</span>
printf(&quot;Hello, first int is <span class="highlight">%d</span>, second int is <span class="highlight">%-5d</span>.\n&quot;, i1, i2);
<span class="color-comment">//Hello, first int is 12345, second int is 678  .</span>
 
char msg[] = &quot;Hello&quot;;
printf(&quot;xx<span class="highlight">%20s</span>xx\n&quot;, msg);
<span class="color-comment">//xx     Helloxx</span>
printf(&quot;xx<span class="highlight">%-20s</span>xx\n&quot;, msg);
<span class="color-comment">//xxHello     xx</span></pre>

<h5>Others</h5>

<ul>
<li><code>+</code> (plus sign): display plus or minus sign preceding the number.</li>
<li><code>#</code> or <code>0</code>: Pad with leading <code>#</code> or <code>0</code>.</li>
</ul>

<h5>C11's <span class="font-code">printf_s()/scanf_s()</span></h5>
<p>C11 introduces more secure version of <code>printf()/scanf()</code> called <code>printf_s()/scanf_s()</code> to deal with mismatched conversion specifiers. Microsoft Visual C implemented its own versions of <code>printf_s()/scanf_s()</code> before C11, and issues a <em>deprecated</em> warning for using <code>printf()/scanf()</code>.</p>

<h4>Input via <span class="font-code">scanf()</span> Function</h4>
<p>In C, you can use <code>scanf()</code> function of <code>&lt;stdio.h&gt;</code> to read inputs from keyboard. <code>scanf()</code> uses the type-conversion code like <code>printf()</code>. For example,</p>

<table class="table-program">
<tr>
<td class="color-line-number-width">
<pre class="color-line-number">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre class="color-listing">
<span class="color-comment">/*
 * TestScanf.c
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int anInt;
   float aFloat;
   double aDouble;
 
   printf(&quot;Enter an int: &quot;);  <span class="color-comment">// Prompting message</span>
   scanf(&quot;<span class="highlight">%d</span>&quot;, <span class="highlight">&amp;</span>anInt);       <span class="color-comment">// Read an int from keyboard and assign to variable anInt.</span>
   printf(&quot;The value entered is %d.\n&quot;, anInt);
 
   printf(&quot;Enter a floating-point number: &quot;);  <span class="color-comment">// Prompting message</span>
   scanf(&quot;<span class="highlight">%f</span>&quot;, <span class="highlight">&amp;</span>aFloat);     <span class="color-comment">// Read a double from keyboard and assign to variable aFloat.</span>
   printf(&quot;The value entered is %f.\n&quot;, aFloat);
 
   printf(&quot;Enter a floating-point number: &quot;);  <span class="color-comment">// Prompting message</span>
   scanf(&quot;<span class="highlight">%lf</span>&quot;, <span class="highlight">&amp;</span>aDouble);     <span class="color-comment">// Read a double from keyboard and assign to variable aDouble.</span>
   printf(&quot;The value entered is %lf.\n&quot;, aDouble);
 
   return 0;
}</pre>
</td>
</tr>
</table>

<p>Notes:</p>
<ul>
<li>To place the input into a variable in <code>scanf()</code>, you need to prefix the variable name by an ampersand sign (<code>&amp;</code>). The ampersand (<code>&amp;</code>) is called address-of operator, which will be explained later. However, it is important to stress that missing ampersand (<code>&amp;</code>) is a common error.</li>
<li>For double, you must use type conversion code <code>%lf</code> for <code>scanf()</code>. You could use <code>%f</code> or <code>%lf</code> for <code>printf()</code>.</li>

</ul>

<h5>Return-Value for <code>scanf()</code></h5>

<p>The <code>scanf()</code> returns an <code>int</code> indicating the number of values read.</p>

<p>For example,</p>
<pre class="color-example">
int number1 = 55, number2 = 66;
int rcode = scanf(&quot;%d&quot;, &amp;number);
printf(&quot;return code is %d\n&quot;, rcode);
printf(&quot;number1 is %d\n&quot;, number1);
printf(&quot;number2 is %d\n&quot;, number2);</pre>

<p>The <code>scanf()</code> returns 1 if user enters an integer which is read into the variable <code>number</code>. It returns 0 if user enters a non-integer (such as &quot;hello&quot;), and variable number is not assigned.</p>

<pre class="color-example">
int number1 = 55, number2 = 66;
int rcode = scanf(&quot;%d%d&quot;, &amp;number1, &amp;number2);
printf(&quot;return code is %d\n&quot;, rcode);
printf(&quot;number1 is %d\n&quot;, number1);
printf(&quot;number2 is %d\n&quot;, number2);</pre>

<p>The <code>scanf()</code> returns 2 if user enters two integers that are read into <code>number1</code> and <code>number2</code>. It returns 1 if user enters an integer followed by a non-integer, and <code>number2</code> will not be affected. It returns 0 if user enters a non-integer, and both <code>number1</code> and <code>number2</code> will not be affected.</p>

<p>Checking the return code of <code>scanf()</code> is recommended for <em>secure coding</em>.</p>

<h4>Literals for Fundamental Types and String</h4>

<p>A <em>literal</em> is a <em>specific constant value</em>, such as <code>123</code>, <code>-456</code>, <code>3.14</code>, <code>'a'</code>, <code>&quot;Hello&quot;</code>, that can be assigned directly to a variable; or used  as part of an expression. They are called <em>literals</em> because they literally and explicitly identify their values.</p>

<h5>Integer Literals</h5>

<p>A whole number, such as <code>123</code> and <code>-456</code>, is treated as an <code>int</code>, by default. For example,</p>

<pre class="color-example">
int number = -123;
int sum = 4567;
<span class="color-error">int bigSum = 8234567890;</span>  <span class="color-comment">// ERROR: this value is outside the range of int</span></pre>
<p>An <code>int</code> literal may precede with a plus (<code>+</code>) or minus (<code>-</code>) sign, followed by digits. No commas or special symbols (e.g., <code>$</code> or space) is allowed (e.g., <code>1,234</code> and <code>$123</code> are invalid). No preceding <code>0</code> is allowed too (e.g., <code>007</code> is invalid).</p>
<p>Besides the default base 10 integers, you can use a prefix <code>'0'</code> (zero) to denote a value in octal, prefix <code>'0x'</code> for a value in hexadecimal, and prefix '<code>0b</code>' for binary value (in some compilers), e.g.,</p>

<pre class="color-example">
int number1 = 1234;       <span class="color-comment">// Decimal</span>
int number2 = 01234;      <span class="color-comment">// Octal 1234, Decimal 2322</span>
int number3 = 0x1abc;     <span class="color-comment">// hexadecimal 1ABC, decimal 15274</span>
int number4 = 0b10001001; <span class="color-comment">// binary (may not work in some compilers)</span></pre>

<p>A <code>long</code> literal is identified by a suffix <code>'L'</code> or <code>'l'</code> (avoid lowercase, which can be confused with the number one). A <code>long long int</code> is identified by a suffix <code>'LL'</code>. You can also use suffix <code>'U'</code> for <code>unsigned int</code>, <code>'UL'</code> for <code>unsigned long</code>, and <code>'ULL'</code> for <code>unsigned long long int</code>. For example,</p>

<pre class="color-example">
long number = 12345678L;     <span class="color-comment">// Suffix 'L' for long</span>
long sum = 123;              <span class="color-comment">// int 123 auto-casts to long 123L</span>
long long bigNumber = 987654321LL;  <span class="color-comment">// Need suffix 'LL' for long long int</span></pre>

<p>No suffix is needed for <code>short</code> literals. But you can only use integer values in the permitted range. For example,</p>

<pre class="color-example">
<span class="color-error">short smallNumber = 1234567890;</span>   <span class="color-comment">// ERROR: this value is outside the range of short.</span>
short midSizeNumber = -12345;</pre>

<h5>Floating-point Literals</h5>

<p>A number with a decimal point, such as <code>55.66</code> and <code>-33.44</code>, is treated as a <code>double</code>, by default. You can also express them in scientific notation, e.g., <code>1.2e3</code>, <code>-5.5E-6</code>, where <code>e</code> or <code>E</code> denotes the exponent in power of 10. You could precede the fractional part or exponent with a plus (<code>+</code>) or minus (<code>-</code>) sign. Exponent shall be an integer. There should be no space or other characters (e.g., space) in the number.</p>

<p>You MUST use a suffix of <code>'f'</code> or <code>'F'</code> for <code>float</code> literals, e.g., <code>-1.2345F</code>. For example,</p>

<pre class="color-example">
<span class="color-error">float average = 55.66;</span>      <span class="color-comment">// Error! RHS is a double. Need suffix 'f' for float.</span>
float average = 55.66f;</pre>

<p>Use suffix <code>'L'</code> (or <code>'l'</code>) for <code>long double</code>.</p>

<h5>Character Literals and Escape Sequences</h5>

<p>A printable <code>char</code> literal is written by enclosing the character with a pair of <em>single quotes</em>, e.g., <code>'z'</code>, <code>'$'</code>, and <code>'9'</code>. In C, characters are represented using 8-bit ASCII code, and can be treated as a 8-bit <em>signed integer</em>s in arithmetic operations. In other words, <code>char</code> and 8-bit signed integer are interchangeable. You can also assign an integer in the range of <code>[-128, 127]</code> to a <code>char</code> variable; and <code>[0, 255]</code> to an <code>unsigned char</code>.</p>

<p>You can find the <a href="../java/DataRepresentation.html#ASCII">ASCII code table HERE</a>.</p>

<p>For example,</p>

<pre class="color-example">
char letter = 'a';             <span class="color-comment"> // Same as 97</span>
char anotherLetter = 98;       <span class="color-comment"> // Same as the letter 'b'</span>
printf(&quot;%c\n&quot;, letter);        <span class="color-comment"> // 'a' printed</span>
printf(&quot;%c\n&quot;, anotherLetter); <span class="color-comment"> // 'b' printed instead of the number</span>
anotherLetter += 2;           <span class="color-comment">  // 100 or 'd'</span>
printf(&quot;%c\n&quot;, anotherLetter);<span class="color-comment">  // 'd' printed</span>
printf(&quot;%d\n&quot;, anotherLetter); <span class="color-comment"> // 100 printed</span></pre>

<p>Non-printable and control characters can be represented by so-called <em>escape sequences</em>, which begins with a back-slash (<code>\</code>) followed by a code. The commonly-used escape sequences are:</p>

<table class="table-zebra" style="width:60%">
  <thead>
  <tr>
    <th>Escape Sequence</th>
    <th>Description</th>
    <th>Hex (Decimal)</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr>
    <td>\n</td>
    <td class="font-normal">New-line (or Line-feed)</td>
    <td>0AH (10D)</td>
  </tr>
  <tr class="tr-alt">
    <td>\r</td>
    <td class="font-normal">Carriage-return</td>
    <td>0DH (13D)</td>
  </tr>
  <tr>
    <td>\t</td>
    <td class="font-normal">Tab</td>
    <td>09H (9D)</td>
  </tr>
  <tr class="tr-alt">
    <td>\&quot;</td>
    <td class="font-normal">Double-quote (needed to include &quot; in double-quoted string)</td>
    <td>22H (34D)</td>
  </tr>
  <tr>
    <td>\'</td>
    <td class="font-normal">Single-quote</td>
    <td>27H (39D)</td>
  </tr>
  <tr class="tr-alt">
    <td>\\</td>
    <td class="font-normal">Back-slash (to resolve ambiguity)</td>
    <td>5CH (92D)</td>
  </tr>
  </tbody>
</table>

<p>Notes:</p>
<ul>
<li>New-line (<code>0AH</code>) and carriage return (<code>0dH</code>), represented by <code>\n</code>, and <code>\r</code> respectively, are used as <em>line delimiter</em> (or <em>end-of-line</em>, or <em>EOL</em>). However, take note that UNIX/Linux/Mac use <code>\n</code> as EOL, Windows use <code>\r\n</code>.</li>

<li>Horizontal Tab (<code>09H</code>) is represented as <code>\t</code>.</li>

<li>To resolve ambiguity, characters back-slash (<code>\</code>), single-quote (<code>'</code>) and double-quote (<code>&quot;</code>) are represented using escape sequences <code>\\</code>, <code>\'</code> and <code>\&quot;</code>, respectively. This is because a single back-slash begins an escape sequence, while single-quotes and double-quotes are used to enclose character and string.</li>
<li>Other less commonly-used escape sequences are: <code>\?</code> or <code>?</code>, <code>\a</code> for alert or bell, <code>\b</code> for backspace, <code>\f</code> for form-feed, <code>\v</code> for vertical tab. These may not be supported in some consoles.</li>
</ul>

<h5>The <span class="font-code">&lt;ctype.h&gt;</span> Header</h5>

<p>The <code>ctype.h</code> header provides functions such as <code>isalpha()</code>, <code>isdigit()</code>, <code>isspace()</code>, <code>ispunct()</code>, <code>isalnum()</code>, <code>isupper()</code>, <code>islower()</code> to determine the type of character; and <code>toupper()</code>, <code>tolower()</code> for case conversion.</p>

<h5>String Literals</h5>

<p>A <code>String</code> literal is composed of zero of more characters surrounded by a pair of <em>double quotes</em>, e.g., <code>&quot;Hello, world!&quot;</code>, <code>&quot;The sum is &quot;</code>, <code>&quot;&quot;</code>.</p>

<p>String literals may contains escape sequences. Inside a <code>String</code>, you need to use <code>\&quot;</code> for double-quote to distinguish it from the ending double-quote, e.g. <code>&quot;\&quot;quoted\&quot;&quot;</code>. Single quote inside a <code>String</code> does not require escape sequence. For example,</p>
<pre class="color-example">
printf(&quot;Use \\\&quot; to place\n a \&quot; within\ta\tstring\n&quot;);</pre>
<pre class="output">
Use \&quot; to place
 a &quot; within	a	string</pre>
 
<p><span class="line-heading">TRY:</span> Write a program to print the following picture. Take note that you need to use escape sequences to print special characters.</p>
<pre class="output">
          '__'
          (oo)
  +========\/
 / || %%% ||
*  ||-----||
   &quot;&quot;     &quot;&quot;</pre>

<h5>Example (Literals)</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing Primitive Types (TestLiteral.c) */</span>
#include &lt;stdio.h&gt;
 
int main() {
   char gender = 'm';             <span class="color-comment"> // char is single-quoted</span>
   unsigned short numChildren = 8;<span class="color-comment"> // [0, 255]</span>
   short yearOfBirth = 1945;      <span class="color-comment"> // [-32767, 32768]</span>
   unsigned int salary = 88000;   <span class="color-comment"> // [0, 4294967295]</span>
   double weight = 88.88;         <span class="color-comment"> // With fractional part</span>
   float gpa = 3.88f;             <span class="color-comment"> // Need suffix 'f' for float</span>
 
   printf(&quot;Gender is %c.\n&quot;, gender);
   printf(&quot;Number of children is %u.\n&quot;, numChildren);
   printf(&quot;Year of birth is %d.\n&quot;, yearOfBirth);
   printf(&quot;Salary is %u.\n&quot;, salary);
   printf(&quot;Weight is %.2lf.\n&quot;, weight);
   printf(&quot;GPA is %.2f.\n&quot;, gpa);
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Gender is m.
Number of children is 8.
Year of birth is 1945.
Salary is 88000.
Weight is 88.88.
GPA is 3.88.</pre>

<h3>Operations</h3>

<h4>Arithmetic Operators</h4>

<p>C supports the following arithmetic operators for numbers: <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, <code>char</code> (treated as 8-bit signed integer), <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code>, <code>unsigned char</code>, <code>float</code>, <code>double</code> and  <code>long double</code>.</p>

<table class="table-zebra" style="width:80%">
  <thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
    <th>Examples</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr class="tr-alt">
    <td>*</td>
    <td class="font-normal">Multiplication</td>
    <td><em>expr1</em> * <em>expr2</em></td>
    <td>2 * 3 &rarr; 6;  3.3 * 1.0 &rarr; 3.3</td>
  </tr>
  <tr>
    <td>/</td>
    <td class="font-normal">Division</td>
    <td><em>expr1</em> / <em>expr2</em></td>
    <td>1 / 2 &rarr; 0;  1.0 / 2.0 &rarr; 0.5</td>
  </tr>
  <tr class="tr-alt">
    <td>%</td>
    <td class="font-normal">Remainder (Modulus)</td>
    <td><em>expr1</em> % <em>expr2</em></td>
    <td>5 % 2 &rarr; 1;  -5 % 2 &rarr; -1</td>
  </tr>
  <tr>
    <td>+</td>
    <td class="font-normal">Addition</td>
    <td><em>expr1</em> + <em>expr2</em></td>
    <td>1 + 2 &rarr; 3;  1.1 + 2.2 &rarr; 3.3</td>
  </tr>
  <tr class="tr-alt">
    <td>-</td>
    <td class="font-normal">Subtraction</td>
    <td><em>expr1</em> - <em>expr2</em></td>
    <td>1 - 2 &rarr; -1;  1.1 - 2.2 &rarr; -1.1</td>
  </tr>
  </tbody>
</table>

<p>All the above operators are <em>binary</em> operators, i.e., they take two operands. The multiplication, division and remainder take <em>precedence</em> over addition and subtraction. Within the same precedence level (e.g., addition and subtraction), the expression is evaluated from left to right. For example, <code>1+2+3-4</code> is evaluated as <code>((1+2)+3)-4</code>.</p>

<p>It is important to take note that <code>int/int</code> produces an <code>int</code>, with the result <em>truncated</em>, e.g.,<code> 1/2 &rarr; 0 </code>(instead of <code>0.5</code>).</p>

<p>Take note that C does not have an exponent (power) operator (<code>'^'</code> is exclusive-or, not exponent).</p>

<h4>Arithmetic Expressions</h4>
<p>In programming, the following arithmetic expression:</p>
<img src="../java/images/JavaBasics_ArithmeticExpression.png" alt="" class="image-left" />
<p>must be written as <code>(1+2*a)/3 + (4*(b+c)*(5-d-e))/f - 6*(7/g+h)</code>. You cannot omit the multiplication symbol <code>'*'</code> (as in Mathematics).</p>
<p>Like Mathematics, the multiplication <code>'*'</code> and division <code>'/'</code> take precedence over addition <code>'+'</code> and subtraction <code>'-'</code>. Parentheses <code>()</code> have higher precedence. The operators <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, and <code>'/'</code> are <em>left-associative</em>. That is, <code>1 + 2 + 3 + 4</code> is treated as <code>(((1+2) + 3) + 4)</code>.</p>

<h4>Mixed-Type Operations</h4>

<p>If both the operands of an arithmetic operation belong to the <em>same type</em>, the operation is carried out in that type, and the result belongs to that type. For example, <code>int/int &rarr; int; double/double &rarr; double</code>.</p>

<p>However, if the two operands belong to <em>different types</em>, the compiler promotes the value of the <em>smaller</em> type to the <em>larger</em> type (known as <em>implicit type-casting</em>). The operation is then carried out in the <em>larger</em> type. For example, <code>int/double &rarr; double/double &rarr; double</code>. Hence, <code>1/2 &rarr; 0, 1.0/2.0 &rarr; 0.5, 1.0/2 &rarr; 0.5, 1/2.0 &rarr; 0.5</code>.</p>

<p>For example,</p>

<table class="table-zebra" style="width:80%">
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Operation</th>
</tr>
</thead>
<tbody class="font-code">
<tr>
<td>int</td>
<td>2 + 3</td>
<td>int 2 + int 3 &rarr; int 5</td>
</tr>

<tr class="tr-alt">
<td>double</td>
<td>2.2 + 3.3</td>
<td>double 2.2 + double 3.3 &rarr; double 5.5</td>
</tr>

<tr>
<td>mix</td>
<td>2 + 3.3</td>
<td>int 2 + double 3.3 &rarr; double 2.0 + double 3.3 &rarr; double 5.3</td>
</tr>

<tr class="tr-alt">
<td>int</td>
<td>1 / 2</td>
<td>int 1 / int 2 &rarr; int 0</td>
</tr>

<tr>
<td>double</td>
<td>1.0 / 2.0</td>
<td>double 1.0 / double 2.0 &rarr; double 0.5</td>
</tr>

<tr class="tr-alt">
<td>mix</td>
<td>1 / 2.0</td>
<td>int 1 / double 2.0 &rarr; double 1.0 + double 2.0 &rarr; double 0.5</td>
</tr>

</tbody>
</table>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing mix-type arithmetic operations (TestMixTypeOp.c) */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int i1 = 2, i2 = 4;
   double d1 = 2.5, d2 = 5.2;
 
   printf(&quot;%d + %d = %d\n&quot;, i1, i2, i1+i2);         <span class="color-comment"> // 2 + 4 = 6</span>
   printf(&quot;%.1lf + %.1lf = %.1lf\n&quot;, d1, d2, d1+d2);<span class="color-comment"> // 2.5 + 5.2 = 7.7</span>
   printf(&quot;%d + %.1lf = %.1lf\n&quot;, i1, d2, i1+d2);   <span class="color-comment"> // 2 + 5.2 = 7.2  &lt;== mix type</span>
 
   printf(&quot;%d / %d = %d\n&quot;, i1, i2, i1/i2);         <span class="color-comment"> // 2 / 4 = 0  &lt;== NOTE: truncate</span>
   printf(&quot;%.1lf / %.1lf = %.2lf\n&quot;, d1, d2, d1/d2);<span class="color-comment"> // 2.5 / 5.2 = 0.48</span>
   printf(&quot;%d / %.1lf = %.2lf\n&quot;, i1, d2, i1/d2);   <span class="color-comment"> // 2 / 5.2 = 0.38  &lt;== mix type</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Overflow/UnderFlow</h4>
<p>Study the output of the following program:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Arithmetic Overflow/Underflow (TestOverflow.c) */</span>
#include &lt;stdio.h&gt;
 
int main() {
  <span class="color-comment"> // Range of int is [-2147483648, 2147483647]</span>
   int i1 = 2147483647;     <span class="color-comment"> // max int</span>
   printf(&quot;%d\n&quot;, i1 + 1);  <span class="color-comment"> // -2147483648 (overflow)</span>
   printf(&quot;%d\n&quot;, i1 + 2);  <span class="color-comment"> // -2147483647</span>
   printf(&quot;%d\n&quot;, i1 * i1); <span class="color-comment"> // 1</span>
 
   int i2 = -2147483648;    <span class="color-comment"> // min int</span>
   printf(&quot;%d\n&quot;, i2 - 1);  <span class="color-comment"> // 2147483647 (underflow)</span>
   printf(&quot;%d\n&quot;, i2 - 2);  <span class="color-comment"> // 2147483646</span>
   printf(&quot;%d\n&quot;, i2 * i2); <span class="color-comment"> // 0</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In arithmetic operations, the resultant value <em>wraps around</em> if it exceeds its range (i.e., overflow or underflow). C runtime does not issue an error/warning message but produces <em>incorrect</em> result.</p>

<p>It is important to take note that <em>checking of overflow/underflow is the programmer's responsibility</em>, i.e., your job!</p>

<p>This feature is an legacy design, where processors were slow. Checking for overflow/underflow consumes computation power and reduces performance.</p>

<p>To check for arithmetic overflow (known as <em>secure coding</em>) is tedious. Google for &quot;INT32-C. Ensure that operations on signed integers do not result in overflow&quot; @ www.securecoding.cert.org.</p>

<h4>Compound Assignment Operators</h4>

<p>Besides the usual simple assignment operator <code>'='</code> described earlier, C also provides the so-called <em>compound assignment operator</em>s as listed:</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Usage</th>
    <th>Description</th>
    <th>Example</th>
  </tr>
  </thead>
  <tbody class="font-code">
    <tr>
      <td>=</td>
      <td><em>var</em> = <em>expr</em></td>
      <td class="font-normal">Assign the value of the LHS to the variable at the RHS</td>
      <td>x = 5;</td>
    </tr>
    <tr class="tr-alt">
      <td>+=</td>
      <td><em>var</em> += <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> + <em>expr</em></td>
      <td>x += 5; same as x = x + 5</td>
    </tr>
    <tr>
      <td>-=</td>
      <td><em>var</em> -= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> - <em>expr</em></td>
      <td>x -= 5; same as x = x - 5</td>
    </tr>
    <tr class="tr-alt">
      <td>*=</td>
      <td><em>var</em> *= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> * <em>expr</em></td>
      <td>x *= 5; same as x = x * 5</td>
    </tr>
    <tr>
      <td>/=</td>
      <td><em>var</em> /= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> / <em>expr</em></td>
      <td>x /= 5; same as x = x / 5</td>
    </tr>
    <tr class="tr-alt">
      <td>%=</td>
      <td><em>var</em> %= <em>expr</em></td>
      <td>same as <em>var</em> = <em>var</em> % <em>expr</em></td>
      <td>x %= 5; same as x = x % 5</td>
    </tr>
  </tbody>
</table>

<h4>Increment/Decrement Operators</h4>

<p>C supports these <em>unary</em> arithmetic operators: increment <code>'++'</code> and decrement <code>'--'</code>.</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Example</th>
    <th>Result</th>
  </tr>
  </thead>
  <tbody class="font-code">
    <tr>
      <td>++</td>
      <td>x++; ++x</td>
      <td class="font-normal">Increment by 1, same as x += 1</td>
    </tr>
    <tr class="tr-alt">
      <td>--</td>
      <td>x--; --x</td>
      <td class="font-normal">Decrement by 1, same as x -= 1</td>
    </tr>
  </tbody>
</table>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test on increment (++) and decrement (--) Operator (TestIncDec.cpp) */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int mark = 76;       <span class="color-comment"> // declare &amp; assign</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 76</span>
 
   mark++;              <span class="color-comment"> // increase by 1 (post-increment)</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 77</span>
 
   ++mark;              <span class="color-comment"> // increase by 1 (pre-increment)</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 78</span>
 
   mark = mark + 1;     <span class="color-comment"> // also increase by 1 (or mark += 1)</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 79</span>
 
   mark--;              <span class="color-comment"> // decrease by 1 (post-decrement)</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 78</span>
 
   --mark;              <span class="color-comment"> // decrease by 1 (pre-decrement)</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 77</span>
 
   mark = mark - 1;     <span class="color-comment"> // also decrease by 1 (or mark -= 1)</span>
   printf(&quot;%d\n&quot;, mark);<span class="color-comment"> // 76</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The increment/decrement unary operator can be placed before the operand (prefix operator), or after the operands (postfix operator). They takes on different meaning in operations.</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Example</th>
    <th>Result</th>
  </tr>
  </thead>
  <tbody class="font-code">
    <tr>
      <td>++var</td>
      <td class="font-normal">Pre-Increment<br />
        Increment <em>var</em>, then use the new value of <em>var</em></td>
      <td>y = ++x;</td>
      <td>same as x=x+1; y=x;</td>
    </tr>
    <tr class="tr-alt">
      <td>var++</td>
      <td class="font-code">Post-Increment<br />
        Use the old value of <em>var</em>, then increment <em>var</em></td>
      <td>y = x++;</td>
      <td>same as oldX=x; x=x+1; y=oldX;</td>
    </tr>
    <tr>
      <td>--var</td>
      <td class="font-code">Pre-Decrement</td>
      <td>y = --x;</td>
      <td>same as x=x-1; y=x;</td>
    </tr>
    <tr class="tr-alt">
      <td>var--</td>
      <td class="font-code">Post-Decrement</td>
      <td>y = x--;</td>
      <td>same as oldX=x; x=x-1; y=oldX;</td>
    </tr>
  </tbody>
</table>

<p>If '++' or '--' involves another operation, then pre- or post-order is important to specify the order of the two operations. For examples,</p>

<pre class="color-example">
x = 5;
printf(&quot;%d\n&quot;, x++);  <span class="color-comment">// Save x (5); Increment x (=6); Print old x (5).</span>
x = 5;
printf(&quot;%d\n&quot;, ++x);  <span class="color-comment">// Increment x (=6); Print x (6).</span>
<span class="color-comment">// This is confusing! Try to avoid! What is i=++i? What is i=i++?</span>
</pre>

<p>Prefix operator (e.g, <code>++i</code>) could be more efficient than postfix operator (e.g., <code>i++</code>) in some situations.</p>

<h4>Implicit Type-Conversion vs. Explicit Type-Casting</h4>

<p>Converting a value from one type to another type is called <em>type casting</em> (or <em>type conversion</em>). There are two kinds of type casting:</p>

<ol>
<li>Implicit type-conversion performed by the compiler automatically, and</li>

<li>Explicit type-casting via an unary <em>type-casting operator</em> in the form of <code>(<em>new-type</em>)<em>operand</em></code>.</li>
</ol>

<h5>Implicit (Automatic) Type Conversion</h5>

<p>When you assign a value of a fundamental (built-in) type to a variable of another fundamental type, C automatically converts the value to the receiving type, if the two types are compatible. For examples,</p>

<ul>
<li>If you assign an <code>int</code> value to a <code>double</code> variable, the compiler automatically casts the <code>int</code> value to a <code>double</code> double (e.g., from 1 to 1.0) and assigns it to the <code>double</code> variable.</li>
<li>if you assign a <code>double</code> value of to an <code>int</code> variable, the compiler automatically casts the <code>double</code> value to an <code>int</code> value (e.g., from 1.2 to 1) and assigns it to the <code>int</code> variable. The fractional part would be truncated and lost. Some compilers issue a warning/error &quot;possible loss in precision&quot;; others do not.</li>
</ul>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Test implicit type casting (TestImplicitTypeCast.c)
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int i;
   double d;
 
   i = 3;
   d = i;   <span class="color-comment"> // Assign an int value to double</span>
   printf(&quot;d = %lf\n&quot;, d); <span class="color-comment"> // d = 3.0</span>
 
   d = 5.5;
   i = d;   <span class="color-comment"> // Assign a double value to int</span>
   printf(&quot;i = %d\n&quot;, i); <span class="color-comment"> // i = 5 (truncated, no warning!)</span>
 
   i = 6.6; <span class="color-comment"> // Assign a double literal to int</span>
   printf(&quot;i = %d\n&quot;, i); <span class="color-comment"> // i = 6 (truncated, no warning!)</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>C will not perform automatic type conversion, if the two types are not compatible.</p>

<h5>Explicit Type-Casting</h5>

<p>You can explicitly perform type-casting via the so-called unary <em>type-casting operator</em> in the form of <code>(<em>new-type</em>)<em>operand</em></code>. The type-casting operator takes one operand in the particular type, and returns an equivalent value in the new type. Take note that it is an operation that yields a resultant value, similar to an addition operation although addition involves two operands. For example,</p>

<pre class="color-example">
printf(&quot;%lf\n&quot;, (double)5); <span class="color-comment"> // int 5 -&gt; double 5.0</span>
printf(&quot;%d\n&quot;, (int)5.5);   <span class="color-comment"> // double 5.5 -&gt; int 5</span>
 
double aDouble = 5.6;
int anInt = (int)aDouble;<span class="color-comment"> // return 5 and assign to anInt. aDouble does not change!</span></pre>

<p><span class="line-heading">Example:</span> Suppose that you want to find the average (in <code>double</code>) of the integers between <code>1</code> and <code>100</code>. Study the following codes:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Testing Explicit Type Cast (Average1to100.c).
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int sum = 0;
   double average;
   int number = 1;
   while (number &lt;= 100) {
      sum += number;     <span class="color-comment"> // Final sum is int 5050</span>
      ++number;
   }
   average = sum / 100;  <span class="color-comment"> // Won't work (average = 50.0 instead of 50.5)</span>
   printf(&quot;Average is %lf\n&quot;, average); <span class="color-comment"> // Average is 50.0</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>You don't get the fractional part although the <code>average</code> is a <code>double</code>. This is because both the <code>sum</code> and <code>100</code> are <code>int</code>. The result of division is an <code>int</code>, which is then implicitly casted to <code>double</code> and assign to the <code>double</code> variable <code>average</code>.  To get the correct answer, you can do either:</p>

<pre class="color-example" >
average = (double)sum / 100;     <span class="color-comment">// Cast sum from int to double before division</span>
average = sum / (double)100;     <span class="color-comment">// Cast 100 from int to double before division</span>
average = sum / 100.0;
average = (double)(sum / 100);   <span class="color-comment">// Won't work. why?</span></pre>

<p><span class="line-heading">Example:</span></p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Converting between Celsius and Fahrenheit (ConvertTemperature.c)
 *   Celsius = (5/9)(FahrenheitɃ32)
 *   Fahrenheit = (9/5)Celsius+32
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   double celsius, fahrenheit;
 
   printf(&quot;Enter the temperature in celsius: &quot;);
   scanf(&quot;%lf&quot;, &amp;celsius);
   fahrenheit = celsius * 9 / 5 + 32;
  <span class="color-comment"> // 9/5*celsius + 32 gives wrong answer! Why?</span>
   printf(&quot;%.2lf degree C is %.2lf degree F\n&quot;, celsius, fahrenheit);
 
   printf(&quot;Enter the temperature in fahrenheit: &quot;);
   scanf(&quot;%lf&quot;, &amp;fahrenheit);
   celsius =  (fahrenheit - 32) * 5 / 9;
  <span class="color-comment"> // 5/9*(fahrenheit - 32) gives wrong answer! Why?</span>
   printf(&quot;%.2lf degree F is %.2lf degree C\n&quot;, fahrenheit, celsius);
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>


<h4>Relational and Logical Operators</h4>

<p>Very often, you need to compare two values before deciding on the action to be taken, e.g., if mark is more than or equal to 50, print &quot;PASS&quot;.</p>
<p>C provides six <em>comparison operators</em> (or <em>relational operators</em>):</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
    <th>Example (x=5, y=8)</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr>
    <td>==</td>
    <td class="font-normal">Equal to</td>
    <td><em>expr1</em> == <em>expr2</em></td>
    <td>(x == y) &rarr; false</td>
  </tr>
  <tr class="tr-alt">
    <td>!=</td>
    <td class="font-normal">Not Equal to</td>
    <td><em>expr1</em> != <em>expr2</em></td>
    <td>(x != y) &rarr; true</td>
  </tr>
  <tr>
    <td>&gt;</td>
    <td class="font-normal">Greater than</td>
    <td><em>expr1</em> &gt; <em>expr2</em></td>
    <td>(x &gt; y) &rarr; false</td>
  </tr>
  <tr class="tr-alt">
    <td>&gt;=</td>
    <td class="font-normal">Greater than or equal to</td>
    <td><em>expr1</em> &gt;= <em>expr2</em></td>
    <td>(x &gt;= 5) &rarr; true</td>
  </tr>
  <tr>
    <td>&lt;</td>
    <td class="font-normal">Less than</td>
    <td><em>expr1</em> &lt; <em>expr2</em></td>
    <td>(y &lt; 8) &rarr; false</td>
  </tr>
  <tr>
    <td>&lt;=</td>
    <td class="font-normal">Less than or equal to</td>
    <td><em>expr1</em> &gt;= <em>expr2</em></td>
    <td>(y &lt;= 8) &rarr; true</td>
  </tr>
  </tbody>
</table>

<p>Each comparison operation involves two operands, e.g., <code>x &lt;= 100</code>. It is invalid to write <code>1 &lt; x &lt; 100</code> in programming. Instead, you need to break out the two comparison operations <code>x &gt; 1</code>, <code>x &lt; 100</code>, and join with with a logical AND operator, i.e., <code>(x &gt; 1) &amp;&amp; (x &lt; 100)</code>, where <code>&amp;&amp;</code> denotes AND operator.</p>

<p>C provides four logical operators:</p>

<table class="table-zebra" style="width:80%">
<thead>
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
  </tr>
  </thead>
  <tbody class="font-code">
  <tr>
    <td>&amp;&amp;</td>
    <td class="font-normal">Logical AND</td>
    <td><em>expr1</em> &amp;&amp; <em>expr2</em></td>
  </tr>
  <tr class="tr-alt">
    <td>||</td>
    <td class="font-normal">Logical OR</td>
    <td><em>expr1</em> || <em>expr2</em></td>
  </tr>
  <tr>
    <td>!</td>
    <td class="font-normal">Logical NOT</td>
    <td>!<em>expr</em></td>
  </tr>
  <tr class="tr-alt">
    <td>^</td>
    <td class="font-normal">Logical XOR</td>
    <td><em>expr1</em> ^ <em>expr2</em></td>
  </tr>
  </tbody>
</table>

<p> The truth tables are as follows:</p>
<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>AND (&amp;&amp;)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>true</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
  <tr>
    <td>false</td>
    <td><span class="color-comment">false</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
</table>

<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>OR (||)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>true</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">true</span></td>
  </tr>
  <tr>
    <td>false</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
</table>
<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>NOT (!)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td></td>
    <td><span class="color-comment">false</span></td>
    <td><span class="color-comment">true</span></td>
  </tr>
</table>

<table class="table-zebra font-code" style="width:30%">
  <tr>
    <th>XOR (^)</th>
    <td>true</td>
    <td>false</td>
  </tr>
  <tr>
    <td>true</td>
    <td><span class="color-comment">false</span></td>
    <td><span class="color-comment">true</span></td>
  </tr>
  <tr>
    <td>false</td>
    <td><span class="color-comment">true</span></td>
    <td><span class="color-comment">false</span></td>
  </tr>
</table>

<p><span class="line-heading">Example:</span></p>
<pre class="color-example">
<span class="color-comment">// Return true if x is between 0 and 100 (inclusive)</span>
(x &gt;= 0) &amp;&amp; (x &lt;= 100)
<span class="color-comment">// wrong to use 0 &lt;= x &lt;= 100</span>
&nbsp; 
<span class="color-comment">// Return true if x is outside 0 and 100 (inclusive)</span>
(x &lt; 0) || (x &gt; 100)   <span class="color-comment">//or</span>
!((x &gt;= 0) &amp;&amp; (x &lt;= 100))
&nbsp;
<span class="color-comment">// Return true if year is a leap year</span>
<span class="color-comment">// A year is a leap year if it is divisible by 4 but not by 100, or it is divisible by 400.</span>
((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)</pre>

<p><span class="line-heading">Exercise:</span> Given the year, month (1-12), and day (1-31), write a boolean expression which returns true for dates before October 15, 1582 (Gregorian calendar cut over date).</p>
<p>Ans: <code>(year &lt; 1582) || (year == 1582 &amp;&amp; month &lt; 10) || (year == 1582 &amp;&amp; month == 10 &amp;&amp; day &lt; 15)</code></p>


<h3>Flow Control</h3>

<p>There are three basic flow control constructs - <em>sequential</em>, <em>conditional</em> (or <em>decision</em>), and <em>loop</em> (or <em>iteration</em>), as illustrated below.</p>
<img class="image-center" src="../java/images/Flowchart_FlowControl.png" alt="structure constructs" />

<h4>Sequential Flow Control</h4>

<p>A program is a sequence of instructions. <em>Sequential</em> flow is the most common and straight-forward, where programming statements are executed in the order that they are written - from top to bottom in a sequential manner.</p>

<h4>Conditional (Decision) Flow Control</h4>

<p>There are a few types of conditionals, <em>if-then</em>, <em>if-then-else</em>, <em>nested-if</em> (<em>if-elseif-elseif-...-else</em>), <em>switch-case</em>, and <em>conditional expression</em>.</p>

<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    <th>Flowchart</th>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// if-then</span>
<strong>if (</strong> <em>booleanExpression</em><em></em> <strong>) {</strong>
   <em>true-block</em> <strong>;</strong>
<strong>}</strong>
 
 
 
 
 
 </pre></td>
    <td><pre class="color-explanation">if (mark &gt;= 50) {
   printf(&quot;Congratulation!\n&quot;);
   printf(&quot;Keep it up!\n&quot;);
}
 
 
 
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_IfThen.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// if-then-else</span>
<strong>if (</strong> <em>booleanExpression</em><em></em> <strong>) {</strong>
   <em>true-block</em> <strong>;</strong>
<strong>} else {</strong>
   <em>false-block</em> <strong>;</strong>
<strong>}</strong>
 
 
 
 </pre></td>
    <td><pre class="color-explanation">if (mark &gt;= 50) {
   printf(&quot;Congratulation!\n&quot;);
   printf(&quot;Keep it up!\n&quot;);
} else {
   printf(&quot;Try Harder!\n&quot;);
}
 
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_IfElse.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// nested-if</span>
<strong>if (</strong> <em>booleanExpr-1</em> <strong>) {</strong>
   <em>block-1</em> <strong>;
} else if (</strong> <em>booleanExpr-2</em> <strong>) {</strong>
   <em>block-2</em> <strong>;
} else if (</strong> <em>booleanExpr-3</em> <strong>) {</strong>
   <em>block-3</em> <strong>;
} else if (</strong> <em>booleanExpr-4</em> <strong>) {</strong>
   ......<strong>
} else {</strong>
   <em>elseBlock</em> <strong>;
}</strong></pre></td>
    <td><pre class="color-explanation">if (mark &gt;= 80) {
   printf(&quot;A\n&quot;);
} else if (mark &gt;= 70) {
   printf(&quot;B\n&quot;);
} else if (mark &gt;= 60) {
   printf(&quot;C\n&quot;);
} else if (mark &gt;= 50) {
   printf(&quot;D\n&quot;);
} else {
   printf(&quot;F\n&quot;);
}
   </pre></td>
    <td><img src="../java/images/Flowchart_NestedIf.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// switch-case</span>
<strong>switch (</strong> <em>selector</em><em></em> <strong>) {
   case</strong> <em>value-1</em><strong>:</strong>
      <em>block-1</em><strong>; break;
   case</strong> <em>value-2</em><strong>:</strong>
      <em>block-2</em><strong>; break;
   case</strong> <em>value-3</em><strong>:</strong>
      <em>block-3</em><strong>; break;</strong>
   ......
<strong>   case</strong> <em>value-n</em><strong>:</strong>
      <em>block-n</em><strong>; break;</strong>
<strong>   default:</strong>
      <em>default-block</em><strong>;
}</strong></pre></td>
    <td><pre class="color-explanation">char oper; int num1, num2, result;
......
switch (oper) {
   case '+': 
      result = num1 + num2; break;
   case '-': 
      result = num1 - num2; break;
   case '*': 
      result = num1 * num2; break;
   case '/': 
      result = num1 / num2; break;
   default:
      printf(&quot;Unknown operator\n&quot;);
}</pre></td>
    <td><img src="../java/images/Flowchart_SwitchCase.png" alt="" /></td>
  </tr>
</table>

<p>&quot;switch-case&quot; is an alternative to the &quot;nested-if&quot;. In a <em>switch-case</em> statement, a <code>break</code> statement is needed for each of the cases. If <code>break</code> is missing, execution will flow through the following case.  You can use either an <code>int</code> or <code>char</code> variable as the case-<em>selector</em>.</p>

<p><span class="line-heading">Conditional Operator:</span> A conditional operator is a ternary (3-operand) operator, in the form of <code><em>booleanExpr</em> ? <em>trueExpr</em> : <em>falseExpr</em></code>. Depending on the <code><em>booleanExpr</em></code>, it evaluates and returns the value of <em><code>trueExpr</code></em> or <code><em>falseExpr</em></code>.</p>
<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment"></span><em>booleanExpr</em> <strong>?</strong> <em>trueExpr</em> <strong>:</strong> <em>falseExpr</em>
 
 
 </pre></td>
    <td><pre class="color-explanation">printf(&quot;%s\n&quot;, (mark &gt;= 50) ? &quot;PASS&quot; : &quot;FAIL&quot;);
   <span class="color-comment">// print either &quot;PASS&quot; or &quot;FAIL&quot;</span>
max = (a &gt; b) ? a : b;   <span class="color-comment">// RHS returns a or b</span>
abs = (a &gt; 0) ? a : -a;  <span class="color-comment">// RHS returns a or -a</span>   </pre></td>
    </tr>
</table>
<p><span class="line-heading">Braces:</span> You could omit the braces <code>{ }</code>, if there is only one statement inside the block. For example,</p>
<pre class="color-example">
if (mark &gt;= 50) 
   printf(&quot;PASS\n&quot;);   <span class="color-comment">// Only one statement, can omit { } but not recommended</span>
else {                 <span class="color-comment">// more than one statements, need { }</span>
   printf(&quot;FAIL\n&quot;);
   printf(&quot;Try Harder!\n&quot;);
}</pre>

<p>However, I recommend that you keep the braces, even though there is only one statement in the block, to improve the readability of your program.</p>

<h5>Exercises</h5>
<p>[TODO]</p>

<h4>Loop Flow Control</h4>
<p>Again, there are a few types of loops: <em>for-loop</em>, <em>while-do</em>, and <em>do-while</em>.</p>

<table class="table-program">
  <tr>
    <th>Syntax</th>
    <th>Example</th>
    <th>Flowchart</th>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// for-loop</span>
<strong>for (</strong><em>init</em><strong>;</strong> <em>test</em><strong>;</strong> <em>post-proc</em><strong>) {</strong>
   <em>body</em> <strong>;</strong>
<strong>}</strong>
 
 
 
 
 </pre></td>
    <td><pre class="color-explanation">
<span class="color-comment">// Sum from 1 to 1000</span>
int sum = 0, number;
for (number = 1; number &lt;= 1000; ++number) {
   sum += number;
}
 
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_For.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// while-do</span>
<strong>while (</strong> <em>condition</em> <strong>) {</strong>
   <em>body</em> <strong>;
}</strong>
 
 
&nbsp;</pre></td>
    <td><pre class="color-explanation">int sum = 0, number = 1;
while (number &lt;= 1000) {
   sum += number;
   ++number;
}
 
 </pre></td>
    <td><img src="../java/images/Flowchart_While.png" alt="" /></td>
  </tr>
  <tr>
    <td><pre class="color-syntax">
<span class="color-comment">// do-while</span>
<strong>do {</strong>
   <em>body</em> <strong>;
}
while (</strong> <em>condition</em> <strong>) ;</strong>
 
 
 </pre></td>
    <td><pre class="color-explanation">int sum = 0, number = 1;
do {
   sum += number;
   ++number;
} while (number &lt;= 1000);
 
 
 </pre></td>
    <td><img src="../java/images/Flowchart_DoWhile.png" alt="" /></td>
  </tr>
</table>

<p>The difference between <em>while-do</em> and <em>do-while</em> lies in the order of the <em>body</em> and <em>condition</em>. In <em>while-do</em>, the <em>condition</em> is tested first. The body will be executed if the <em>condition</em> is true and the process repeats.  In <em>do-while</em>, the <em>body</em> is executed and then the <em>condition</em> is tested. Take note that the <em>body</em> of <em>do-while</em> will be executed at least once (vs. possibly zero for <em>while-do</em>).</p>

<p>Suppose that your program prompts user for a number between <code>1</code> to <code>10</code>, and checks for valid input, do-while with a boolean flag could be more appropriate.</p>

<pre class="color-example">
<span class="color-comment">// Input with validity check</span>
bool valid = false;
int number;
do {
  <span class="color-comment">// prompt user to enter an int between 1 and 10</span>
  ......
  <span class="color-comment">// if the number entered is valid, set done to exit the loop</span>
  if (number &gt;=1 &amp;&amp; number &lt;= 10) {
     valid = true;
  }
} while (!valid);   <span class="color-comment">// Need a semi-colon to terminate do-while</span></pre>

<p>Below is an example of using while-do:</p>

<pre class="color-example">
<span class="color-comment">// Game loop</span>
bool gameOver = false;
while (!gameOver) {
   <span class="color-comment">// play the game</span>
   ......
   <span class="color-comment">// Update the game state 
   // Set gameOver to true if appropriate to exit the game loop</span>
   ......
}</pre>

<p><span class="line-heading">Example (Counter-Controlled Loop):</span> Prompt user for an upperbound. Sum the integers from 1 to a given upperbound and compute its average.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Sum from 1 to a given upperbound and compute their average (SumNumbers.c)
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int sum = 0;    <span class="color-comment"> // Store the accumulated sum</span>
   int upperbound;
 
   printf(&quot;Enter the upperbound: &quot;);
   scanf(&quot;%d&quot;, &amp;upperbound);
 
  <span class="color-comment"> // Sum from 1 to the upperbound</span>
   int number;
   for (number = 1; number &lt;= upperbound; ++number) {
      sum += number;
   }
   printf(&quot;Sum is %d\n&quot;, sum);
   printf(&quot;Average is %.2lf\n&quot;, (double)sum / upperbound);
 
  <span class="color-comment"> // Sum only the odd numbers</span>
   int count = 0;    <span class="color-comment"> // counts of odd numbers</span>
   sum = 0;          <span class="color-comment"> // reset sum</span>
   for (number = 1; number &lt;= upperbound; number = number + 2) {
      ++count;
      sum += number;
   }
   printf(&quot;Sum of odd numbers is %d\n&quot;, sum);
   printf(&quot;Average is %.2lf\n&quot;, (double)sum / count);
}</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading">Example (Sentinel-Controlled Loop):</span> Prompt user for positive integers, and display the count, maximum, minimum and average. Terminate when user enters -1.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Prompt user for positive integers and display the count, maximum,
   minimum and average. Terminate the input with -1 (StatNumbers.c) */</span>
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt; <span class="color-comment"> // for INT_MAX</span>
 
int main() {
   int numberIn = 0; <span class="color-comment"> // input number (positive integer)</span>
   int count = 0;    <span class="color-comment"> // count of inputs, init to 0</span>
   int sum = 0;      <span class="color-comment"> // sum of inputs, init to 0</span>
   int max = 0;      <span class="color-comment"> // max of inputs, init to minimum</span>
   int min = INT_MAX;<span class="color-comment"> // min of inputs, init to maximum (need &lt;climits&gt;)</span>
   int sentinel = -1;<span class="color-comment"> // Input terminating value</span>
 
  <span class="color-comment"> // Read Inputs until sentinel encountered</span>
   printf(&quot;Enter a positive integer or %d to exit: &quot;, sentinel);
   scanf(&quot;%d&quot;, &amp;numberIn);
   while (numberIn != sentinel) {
     <span class="color-comment"> // Check input for positive integer</span>
      if (numberIn &gt; 0) {
         ++count;
         sum += numberIn;
         if (max &lt; numberIn) max = numberIn;
         if (min &gt; numberIn) min = numberIn;
      } else {
         printf(&quot;error: input must be positive! try again...\n&quot;);
      }
      printf(&quot;Enter a positive integer or %d to exit: &quot;, sentinel);
      scanf(&quot;%d&quot;, &amp;numberIn);
   }
 
  <span class="color-comment"> // Print result</span>
   printf(&quot;\n&quot;);
   printf(&quot;Count is %d\n&quot;, count);
   if (count &gt; 0) {
      printf(&quot;Maximum is %d\n&quot;, max);
      printf(&quot;Minimum is %d\n&quot;, min);
      printf(&quot;Average is %.2lf\n&quot;, (double)sum / count);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes</p>

<ul>
<li>In computing, a <em>sentinel value</em> is a special value that indicates the end of data (e.g., a negative value to end a sequence of positive value, end-of-file, null character in the null-terminated string). In this example, we use -1 as the sentinel value to indicate the end of inputs, which is a sequence of positive integers. Instead of hardcoding the value of -1, we use a variable called <code>sentinel</code> for flexibility and ease-of-maintenance.</li>
<li>Take note of the <em>while-loop pattern</em> in reading the inputs.  In this pattern, you need to <em>repeat</em> the prompting and input statement.</li>
</ul>

<h5>Exercises</h5>
<p>[TODO]</p>

<h4>Interrupting Loop Flow - &quot;<span class="font-code">break</span>&quot; and &quot;<span class="font-code">continue</span>&quot;</h4>
<p>The <code>break</code> statement breaks out and exits the current (innermost) loop.</p>
<p>The <code>continue</code> statement aborts the current iteration and continue to the next iteration of the current (innermost) loop.</p>
<p><code>break</code> and <code>continue</code> are poor structures as they are hard to read and hard to follow.  Use them only if absolutely necessary.  You can always write the same program without using <code>break</code> and <code>continue</code>.</p>

<p><span class="line-heading">Example (<span class="font-code">break</span>):</span> The following program lists the non-prime numbers between 2 and an upperbound.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  List non-prime from 1 to an upperbound (NonPrimeList.c).
 */</span>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
 
int main() {
   int upperbound, number, maxFactor, factor;
   printf(&quot;Enter the upperbound: &quot;);
   scanf(&quot;%d&quot;, &amp;upperbound);
   for (number = 2; number &lt;= upperbound; ++number) {
     <span class="color-comment"> // Not a prime, if there is a factor between 2 and sqrt(number)</span>
      maxFactor = (int)sqrt(number);
      for (factor = 2; factor &lt;= maxFactor; ++factor) {
         if (number % factor == 0) {  <span class="color-comment"> // Factor?</span>
            printf(&quot;%d &quot;, number);
            break;  <span class="color-comment"> // A factor found, no need to search for more factors</span>
         }
      }
   }
   printf(&quot;\n&quot;);
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Let's rewrite the above program without using <code>break</code> statement. A <code>while</code> loop is used (which is controlled by the <code>boolean</code> flag) instead of <code>for</code> loop with <code>break</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  List primes from 1 to an upperbound (PrimeList.c).
 */</span>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
 
int main() {
   int upperbound, number, maxFactor, isPrime, factor;
   printf(&quot;Enter the upperbound: &quot;);
   scanf(&quot;%d&quot;, &amp;upperbound);
 
   for (number = 2; number &lt;= upperbound; ++number) {
     <span class="color-comment"> // Not prime, if there is a factor between 2 and sqrt of number</span>
      maxFactor = (int)sqrt(number);
      isPrime = 1;
      factor = 2;
      while (isPrime &amp;&amp; factor &lt;= maxFactor) {
         if (number % factor == 0) {  <span class="color-comment"> // Factor of number?</span>
             isPrime = 0;
         }
         ++factor;
      }
      if (isPrime) printf(&quot;%d &quot;, number);
   }
   printf(&quot;\n&quot;);
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading">Example (<span class="font-code">continue</span>):</span></p>

<pre class="color-example">
<span class="color-comment">// Sum 1 to upperbound, exclude 11, 22, 33,...</span>
int upperbound = 100;
int sum = 0;
int number;
for (number = 1; number &lt;= upperbound; ++number) {
   if (number % 11 == 0) continue;  <span class="color-comment">// Skip the rest of the loop body, continue to the next iteration
</span>   sum += number;
}
<span class="color-comment">// It is better to re-write the loop as:</span>
for (number = 1; number &lt;= upperbound; ++number) {
   if (number % 11 != 0) sum += number;
}</pre>

<p><span class="line-heading">Example (<span class="font-code">break</span> and <span class="font-code">continue</span>):</span> Study the following program.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td>
<pre>
<span class="color-comment">/* A mystery series (Mystery.c) */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int number = 1;
   while (1) {
      ++number;
      if ((number % 3) == 0) continue;
      if (number == 133) break;
      if ((number % 2) == 0) {
         number += 3;
      } else {
         number -= 3;
      }
      printf(&quot;%d &quot;, number);
   }
   printf(&quot;\n&quot;);
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Terminating Program</h4>

<p>There are a few ways that you can terminate your program, before reaching the end of the programming statements.</p>

<p><span class="line-heading"><span class="font-code">exit()</span>:</span> You could invoke the function <code>exit(int exitCode)</code>, in <code>&lt;stdlib.h&gt;</code>, to terminate the program and return the control to the Operating System.  By convention, return code of zero indicates normal termination; while a non-zero <code>exitCode</code> (-1) indicates <em>abnormal termination</em>. For example,</p>

<p><span class="line-heading"><span class="font-code">abort()</span>:</span> The header <code>&lt;stdlib.h&gt;</code> also provide a function called <code>abort()</code>, which can be used to terminate the program <em>abnormally</em>.</p>

<pre class="color-example">
if (errorCount &gt; 10) {
   printf(&quot;too many errors\n&quot;);
   exit(-1);  <span class="color-comment">// Terminate the program
              // OR abort();</span>
}</pre>


<p><span class="line-heading">The &quot;<span class="font-code">return</span>&quot; Statement:</span> You could also use a &quot;<code>return <em>returnValue</em></code>&quot; statement in the <code>main()</code> function to terminate the program and return control back to the Operating System.
  For example,</p>
<pre class="color-example">
int <strong>main</strong>() {
   ...
   if (errorCount &gt; 10) {
      printf(&quot;too many errors\n&quot;);
      return -1;  <span class="color-comment">// Terminate and return control to OS from main()</span>
   }
   ...
}</pre>

<h4>Nested Loops</h4>

<p>The following diagram illustrates a nested for-loop, i.e., an inner for-loop within an outer for-loop.</p>

<img class="image-center" src="images/NestedForLoop.png" alt="NestedForLoop.png" />

<p>Try out the following program, which prints a 8-by-8 checker box pattern using <em>nested loops</em>, as follows:</p>

<pre class="output">
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #</pre>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  Print square pattern (PrintSquarePattern.c).
 */</span>
#include &lt;stdio.h&gt;
 
int main() {
   int size = 8, row, col;
   for (row = 1; row &lt;= size; ++row) {    <span class="color-comment"> // Outer loop to print all the rows</span>
      for (col = 1; col &lt;= size; ++col) { <span class="color-comment"> // Inner loop to print all the columns of each row</span>
         printf(&quot;# &quot;);
      }
      printf(&quot;\n&quot;);  <span class="color-comment"> // A row ended, bring the cursor to the next line</span>
   }
 
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This program contains two <em>nested</em> for-loops. The inner loop is used to print a row of eight &quot;<code># </code>&quot;, which is followed by printing a newline. The outer loop repeats the inner loop to print all the rows.</p>

<p>Suppose that you want to print this pattern  instead (in program called <code>PrintCheckerPattern.cpp</code>):</p>

<pre class="output">
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #</pre>
<p>You need to print an additional space for even-number rows.  You could do so by adding the following statement before Line 8.</p>
<pre  class="color-example">
if ((row % 2) == 0) {   <span class="color-comment">// print a leading space for even-numbered rows</span>
   printf(&quot; &quot;);
}</pre>

<h5>Exercises</h5>

<ol>
<li>Print these patterns using nested loop (in a program called <code>PrintPattern1x</code>). Use a variable called <code>size</code> for the size of the pattern and try out various sizes. You should use as few <code>printf()</code> statements as possible.
  <pre class="output">
 # * # * # * # *    # # # # # # # #    # # # # # # # #    1                                1
# * # * # * # *     # # # # # # #        # # # # # # #    2 1                            1 2
 # * # * # * # *    # # # # # #            # # # # # #    3 2 1                        1 2 3
# * # * # * # *     # # # # #                # # # # #    4 3 2 1                    1 2 3 4
 # * # * # * # *    # # # #                    # # # #    5 4 3 2 1                1 2 3 4 5
# * # * # * # *     # # #                        # # #    6 5 4 3 2 1            1 2 3 4 5 6
 # * # * # * # *    # #                            # #    7 6 5 4 3 2 1        1 2 3 4 5 6 7
# * # * # * # *     #                                #    8 7 6 5 4 3 2 1    1 2 3 4 5 6 7 8
     (a)                  (b)                (c)                (d)                (e)</pre>
    <em>Hints</em>:<br />
    The equations for major and opposite diagonals are row = col and row + col = size + 1. Decide on what to print above and below the diagonal.</li>

<li>Print the timetable of 1 to 9, as follows, using nested loop. (Hints: you need to use an <em>if-else</em> statement to check whether the product is single-digit or double-digit, and print an additional space if needed.)
<pre class="output">
 1  2  3  4  5  6  7  8  9
 2  4  6  8 10 12 14 16 18
 ...... </pre></li>
 
<li>Print these patterns using nested loop.
<pre class="output">
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
#           #        #                          #          #       #        # #       # #
#           #          #                      #              #   #          #   #   #   #
#           #            #                  #                  #            #     #     #
#           #              #              #                  #   #          #   #   #   #
#           #                #          #                  #       #        # #       # #
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
     (a)                 (b)               (c)                (d)                (e)</pre></li>
</ol>

<h4>Some Issues in Flow Control</h4>

<p><span class="line-heading">Dangling <span class="font-code">else</span>:</span> The &quot;dangling else&quot; problem can be illustrated as follows:</p>
<pre class="color-example">
if (i == 0)
   if (j == 0)
      printf(&quot;i and j are zero\n&quot;);
else printf(&quot;i is not zero\n&quot;);   <span class="color-comment">// intend for the outer-if</span></pre>

<p>The <code>else</code> clause in the above codes is syntactically applicable to both the outer-if and the inner-if.  The C compiler always associate the <code>else</code> clause with the innermost if (i.e., the nearest if).  Dangling else can be resolved by applying explicit parentheses. The above codes are logically incorrect and require explicit parentheses as shown below.</p>

<pre class="color-example">
if ( i == 0) {
   if (j == 0) printf(&quot;i and j are zero\n&quot;);
} else {
   printf(&quot;i is not zero\n&quot;);   <span class="color-comment">// non-ambiguous for outer-if</span>
}</pre>

<p><span class="line-heading">Endless Loop:</span> The following constructs:</p>

<pre class="color-example">
while (1) { ...... }</pre>

<p>is commonly used.  It seems to be an endless loop (or infinite loop), but it is usually terminated via a <code>break</code> or <code>return</code> statement inside the loop body. This kind of code is hard to read - avoid if possible by re-writing the condition.</p>

<h4>Exercises</h4>
<p>[TODO]</p>

<h3>Writing Correct and Good Programs</h3>

<p>It is important to write programs that produce the correct results.  It is also important to write programs that others (and you yourself three days later) can understand, so that the programs can be maintained - I call these programs good programs.</p>

<p>Here are the suggestions:</p>

<ul>
<li>Follow established convention so that everyone has the same basis of understanding.</li>

<li>Format and layout of the source code with appropriate indents, white spaces and white lines. Use 3 or 4 spaces for indent, and blank lines to separate sections of codes.</li>

<li>Choose good names that are self-descriptive and meaningful, e.g., <code>row</code>, <code>col</code>, <code>size</code>, <code>xMax</code>, <code>numStudents</code>. Do not use meaningless names, such as <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>. Avoid single-alphabet names (easier to type but often meaningless), except common names likes x, <code>y</code>, <code>z</code> for co-ordinates and <code>i</code> for index.</li>

<li>Provide comments to explain the important as well as salient concepts. Comment your codes liberally.</li>

<li>Write your program documentation while writing your programs.</li>

<li>Avoid <em>un-structured</em> constructs, such as <code>break</code> and <code>continue</code>, which are hard to follow.</li>

<li> Use &quot;mono-space&quot; fonts (such as Consola, Courier New, Courier) for writing/displaying your program.</li>
</ul>

<h5>Programming Errors</h5>

<p>There are generally three classes of programming errors:</p>

<ol>
<li><em>Compilation Error</em> (or <em>Syntax Error</em>): can be fixed easily.</li>

<li><em>Runtime Error</em>: program halts pre-maturely without producing the results - can also be fixed easily.</li>

<li><em>Logical Error</em>: program completes but produces incorrect results. It is easy to detect if the program always produces wrong result. It is extremely hard to fix if the program produces the correct result most of the times, but incorrect result sometimes. For example,

<pre class="color-example">
<span class="color-comment">// Can compile and execute, but give wrong result – sometimes!</span>
if (mark &gt; 50) {
   printf(&quot;PASS\n&quot;);
} else {
   printf(&quot;FAIL\n&quot;);
}</pre>
This kind of errors is very serious if it is not caught before production. Writing good programs helps in minimizing and detecting these errors. A good <em>testing strategy</em> is needed to ascertain the correctness of the program. <em>Software testing</em> is an advanced topics which is beyond our current scope.</li>
</ol>

<h5>Debugging Programs</h5>

<p>Here are the common debugging techniques:</p>

<ol>
<li>Stare at the screen! Unfortunately, errors usually won't pop-up even if you stare at it extremely hard.</li>

<li>Study the error messages! Do not close the console when error occurs and pretending that everything is fine. This helps most of the times.</li>

<li>Insert print statements at appropriate locations to display the intermediate results. It works for simple toy program, but it is neither effective nor efficient for complex program.</li>

<li>Use a graphic debugger. This is the most effective means. Trace program execution step-by-step and watch the value of variables and outputs.</li>

<li>Advanced tools such as profiler (needed for checking memory leak and function usage).</li>

<li>Proper program testing to wipe out the logical errors.</li>
</ol>

<h5>Testing Your Program for Correctness</h5>

<p>How to ensure that your program always produces correct result, 100% of the times? It is impossible to try out all the possible outcomes, even for a simple program. Program testing usually involves a set of representative test cases, which are designed to catch the major classes of errors.  Program testing is beyond the scope of this writing.</p>

<h3>Arrays</h3>

<h4>Array Declaration and Usage</h4>

<p>Suppose that you want to find the average of the marks for a class of 30 students, you certainly do not want to create 30 variables: <code>mark1</code>, <code>mark2</code>, ..., <code>mark30</code>. Instead, You could use a single variable, called an <em>array</em>, with 30 elements.</p>

<p>An array is <em>a list of elements of the same type</em>, identified by a pair of square brackets <code>[ ]</code>.  To use an array, you need to <em>declare</em> the array with 3 things: a <em>name,</em> a <em>type</em> and a <em>dimension</em> (or <em>size</em>, or <em>length</em>). The syntax is:</p>

<pre class="color-syntax">
<em>type</em> <em>arrayName</em>[<em>arraylength</em>];</pre>

<p> I recommend using a plural name for array, e.g., <code>marks</code>, <code>rows</code>, <code>numbers</code>. For example,</p>

<pre class="color-example">
int marks[5];        <span class="color-comment">// Declare an int array called marks with 5 elements</span>
double numbers[10]; <span class="color-comment"> // Declare an double array of 10 elements</span>

<span class="color-comment">// Use #define to specify the length</span>
#define SIZE 9
int numbers[SIZE];
 
<span class="color-comment">// Some compilers support an variable as array length, e.g.,
</span><span class="color-comment"></span>const int SIZE = 9;
float temps[SIZE];   <span class="color-comment">// Use const int as array length</span>
<span class="color-comment"> 
</span>int size;
printf(&quot;Enter the length of the array: &quot;);
scanf(&quot;%d&quot;, size);
float values[size];</pre>

<p>Take note that, in C, the value of the elements are undefined after declaration.</p>

<p>You can also initialize the array during declaration with a comma-separated list of values, as follows:</p>

<pre class="color-example">
<span class="color-comment">// Declare and initialize an int array of 3 elements</span>
int numbers[3] = {11, 33, 44};
<span class="color-comment">// If length is omitted, the compiler counts the elements</span>
<span class="color-comment"></span>int numbers[] = {11, 33, 44};
<span class="color-comment">// Number of elements in the initialization shall be equal to or less than length</span>
int numbers[5] = {11, 33, 44};  <span class="color-comment">// Remaining elements are zero. Confusing! Don't do this</span>
int numbers[2] = {11, 33, 44};  <span class="color-comment">// ERROR: too many initializers</span>
<span class="color-comment">
// Use {0} or {} to initialize all elements to 0</span>
<strong>int numbers[5] = {0};</strong>  <span class="color-comment">// First element to 0, the rest also to zero</span>
<strong>int numbers[5] = {};</strong>   <span class="color-comment">// All element to 0 too</span></pre>

<h5>Example: Array Declaration and Initialization</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test local array initialization (TestArrayInit.c) */</span>
#include &lt;stdio.h&gt;
#define SIZE 5
 
int main() {
   int i;
 
   int a1[SIZE];  <span class="color-comment"> // Uninitialized</span>
   for (i = 0; i &lt; SIZE; ++i) printf(&quot;%d &quot;, a1[i]);
   printf(&quot;\n&quot;);  <span class="color-comment"> // ? ? ? ? ?</span>
 
   int a2[SIZE] = {21, 22, 23, 24, 25};<span class="color-comment"> // All elements initialized</span>
   for (i = 0; i &lt; SIZE; ++i) printf(&quot;%d &quot;, a2[i]);
   printf(&quot;\n&quot;);  <span class="color-comment"> // 21 22 23 24 25</span>
 
   int a3[] = {31, 32, 33, 34, 35};  <span class="color-comment"> // Size deduced from init values</span>
   int a3Size = sizeof(a3)/sizeof(int);
   printf(&quot;Size is %d\n&quot;, a3Size);  <span class="color-comment"> // 5</span>
   for (i = 0; i &lt; a3Size; ++i) printf(&quot;%d &quot;, a3[i]);
   printf(&quot;\n&quot;);  <span class="color-comment"> // 31 32 33 34 35</span>
 
   int a4[5] = {41, 42}; <span class="color-comment"> // Leading elements initialized, the rests to 0</span>
   for (i = 0; i &lt; SIZE; ++i) printf(&quot;%d &quot;, a4[i]);
   printf(&quot;\n&quot;);  <span class="color-comment"> // 41 42 0 0 0</span>
 
   int a5[5] = {0}; <span class="color-comment"> // First elements to 0, the rests to 0 too</span>
   for (i = 0; i &lt; SIZE; ++i) printf(&quot;%d &quot;, a5[i]);
   printf(&quot;\n&quot;);  <span class="color-comment"> // 0 0 0 0 0</span>
 
   int a6[5] = {};  <span class="color-comment"> // All elements to 0 too</span>
   for (i = 0; i &lt; SIZE; ++i) printf(&quot;%d &quot;, a6[i]);
   printf(&quot;\n&quot;);  <span class="color-comment"> // 0 0 0 0 0</span>
 
  <span class="color-comment"> // Using variable as the length of array</span>
   const int SIZE_2 = 5;
   int a7[SIZE_2]; <span class="color-comment"> // okay without initialization</span>
   int a8[SIZE_2] = {5, 4, 3, 2, 1};<span class="color-comment"> // error: variable-sized object may not be initialized</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>You can refer to an element of an array via an index (or subscript) enclosed within the square bracket <code>[ ]</code>.  C's array index begins with zero. For example, suppose that <code>marks</code> is an <code>int</code> array of 5 elements, then the 5 elements are: <code>marks[0]</code>, <code>marks[1]</code>, <code>marks[2]</code>, <code>marks[3]</code>, and <code>marks[4]</code>.</p>

<pre class="color-example">
<span class="color-comment">// Declare &amp; allocate a 5-element int array</span>
int marks[5];
<span class="color-comment">// Assign values to the elements</span>
marks[0] = 95;
marks[1] = 85;
marks[2] = 77;
marks[3] = 69;
marks[4] = 66;
printf(&quot;%d\n&quot;, marks[0]&quot;);
printf(&quot;%d\n&quot;, marks[3] + marks[4];</pre>

<img class="image-center" src="images/Array.png" alt="Array.png" />

<p>To create an array, you need to known the length (or size) of the array in advance, and allocate accordingly.  Once an array is created, its length is fixed and cannot be changed. At times, it is hard to ascertain the length of an array (e.g., how many students in a class?). Nonetheless, you need to estimate the length and allocate an upper bound. This  is probably the major drawback of using an array.</p>

<p>You can find the array length using expression <code>sizeof(<em>arrayName</em>)/sizeof(<em>arrayName</em>[0])</code>, where <code>sizeof(<em>arrayName</em>)</code> returns the total bytes of the array and <code>sizeof(<em>arrayName</em>[0])</code> returns the bytes of first element.</p>
<p>C does not perform array <em>index-bound check</em>.  In other words, if the index is beyond the array's bounds, it does not issue a warning/error. For example,</p>

<pre class="color-example">
const int size = 5;
int numbers[size];  <span class="color-comment">// array index from 0 to 4</span>
 
<span class="color-comment">// Index out of bound!
// Can compiled and run, but could pose very serious side effect!</span>
<span class="color-error">numbers[88]</span> = 999;
printf(&quot;%d\n&quot;, <span class="color-error">numbers[77]</span>);
</pre>

<p> This is another pitfall of C. Checking the index bound consumes computation power and depicts the performance. However, it is better to be safe than fast. Newer programming languages such as Java/C# performs array index bound check.</p>

<h4>Array and Loop</h4>

<p>Arrays works hand-in-hand with loops. You can process all the elements of an array via a loop, for example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 *  Find the mean and standard deviation of numbers kept in an array (MeanStdArray.c).
 */</span>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define SIZE 7
 
int main() {
   int marks[] = {74, 43, 58, 60, 90, 64, 70};
   int sum = 0;
   int sumSq = 0;
   double mean, stdDev;
   int i;
   for (i = 0; i &lt; SIZE; ++i) {
      sum += marks[i];
      sumSq += marks[i] * marks[i];
   }
   mean = (double)sum/SIZE;
   printf(&quot;Mean is %.2lf\n&quot;, mean);
 
   stdDev = sqrt((double)sumSq/SIZE - mean*mean);
   printf(&quot;Std dev is %.2lf\n&quot;, stdDev);
 
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Exercises</h5>
<p>[TODO]</p>

<h4>Multi-Dimensional Array</h4>
<p>For example,</p>
<pre class="color-example">int[2][3] = { {11, 22, 33}, {44, 55, 66} };</pre>

<img class="image-center" src="images/Array2D.png" alt="Array2D.png" />

<p>For 2D array (table), the first index is the row number, second index is the column number. The elements are stored in a so-called <em>row-major</em> manner, where the column index runs out first.</p>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Multi-dimensional Array (Test2DArray.c) */</span>
#include &lt;stdio.h&gt;
void printArray(const int[][3], int);
 
int main() {
   int myArray[][3] = {{8, 2, 4}, {7, 5, 2}};<span class="color-comment"> // 2x3 initialized</span>
                <span class="color-comment"> // Only the first index can be omitted and implied</span>
   printArray(myArray, 2);
   return 0;
}
 
<span class="color-comment">// Print the contents of rows-by-3 array (columns is fixed)</span>
void printArray(const int array[][3], int rows) {
   int i, j;
   for (i = 0; i &lt; rows; ++i) {
      for (j = 0; j &lt; 3; ++j) {
         printf(&quot;%d &quot;, array[i][j]);
      }
      printf(&quot;\n&quot;);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h3>Functions</h3>

<h4>Why Functions?</h4>

<p>At times, a certain portion of codes has to be used many times. Instead of re-writing the codes many times, it is better to put them into a &quot;subroutine&quot;, and &quot;call&quot; this &quot;subroutine&quot; many time - for ease of maintenance and understanding. Subroutine is  called method (in Java) or function (in C/C++).</p>

<p>The benefits of using functions are:</p>

<ol>
<li><em>Divide and conquer</em>: construct the program from simple, small pieces or components.  Modularize the program into self-contained tasks.</li>

<li><em>Avoid repeating codes</em>: It is easy to copy and paste, but hard to maintain and synchronize all the copies.</li>

<li><em>Software Reuse</em>: you can reuse the functions in other programs, by packaging them into library codes.</li>
</ol>

<p>Two parties are involved in using a function: a <em>caller</em> who calls the function, and the <em>function</em> called. The caller passes <em>argument(s)</em> to the function.  The function receives these argument(s), performs the programmed operations within the function's body, and returns a piece of result back to the caller.</p>

<h4>Using Functions</h4>

<h5>Get Started with an Example</h5>

<p>Suppose that we need to evaluate the area of a circle many times, it is better to write a function called <code>getArea()</code>, and re-use it when needed.</p>

<img class="image-center" src="images/C_Function.png" alt="C_Function.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Function (TestFunction.c) */</span>
#include &lt;stdio.h&gt;
const int PI = 3.14159265;
 
<span class="color-comment">// Function Prototype (Function Declaration)</span>
double getArea(double radius);
 
int main() {
   double radius1 = 1.1, area1, area2;
  <span class="color-comment"> // call function getArea()</span>
   area1 = getArea(radius1);
   printf(&quot;area 1 is %.2lf\n&quot;, area1);
  <span class="color-comment"> // call function getArea()</span>
   area2 = getArea(2.2);
   printf(&quot;area 2 is %.2lf\n&quot;, area2);
  <span class="color-comment"> // call function getArea()</span>
   printf(&quot;area 3 is %.2lf\n&quot;, getArea(3.3));
}
 
<span class="color-comment">// Function Definition</span>
<span class="color-comment">// Return the area of a circle given its radius</span>
double getArea(double radius) {
   return radius * radius * PI;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
area 1 is 3.63
area 2 is 14.52
area 3 is 32.67</pre>

<p>In the above example, a reusable function called <code>getArea()</code> is defined, which receives a parameter (in <code>double</code>) from the caller, performs the calculation, and return a piece of result (in <code>double</code>) to the caller.  In the <code>main()</code>, we invoke <code>getArea()</code> functions thrice, each time with a different parameter.</p>

<p>In C, you need to declare a <em>function </em><em>prototype</em> (before the function is used), and provide a <em>function definition</em>, with a body containing the programmed operations.</p>

<h5>Function Definition</h5>

<p>The syntax for function definition is as follows:</p>

<pre class="color-syntax">
<em>returnValueTyp</em>e <em>functionName </em><strong>(</strong> <em>parameterList</em> <strong>) {</strong>
   <em>functionBody</em> <strong>;
}</strong></pre>

<ul>
<li>The <em>parameterList</em> consists of comma-separated <em>parameter-type</em> and <em>parameter-name</em>, i.e., <code><em>param-1-type param-1-name</em>, <em>param-2-type param-2-name</em>,...</code></li>
<li>The <em>returnValueType</em> specifies the type of the return value, such as <code>int</code> or <code>double</code>. An special return type called <code>void</code> can be used to denote that the function returns no value. In C, a function is allowed to return one value or no value (<code>void</code>). It cannot return multiple values. [C does not allow you to return an array!]</li>

</ul>

<h5>The &quot;<span class="font-code">return</span>&quot; Statement</h5>

<p>Inside the function's body, you could use a <code>return</code> statement to return a value (of the <code><em>returnValueType</em></code> declared in the function's header) and pass the control back to the caller. The syntax is:</p>

<pre class="color-syntax">
<strong>return</strong> <em>expression</em>;   <span class="color-comment">// Evaluated to a value of <em>returnValueType</em> declared in function's signature</span>
<strong>return</strong>;              <span class="color-comment">// For function with return type of void</span></pre>

<p>Take note that invoking a function (by the caller) transfers the control to the function. The <code>return</code> statement in the function transfers the control back to the caller.</p>

<h5>Function Naming Convention</h5>

<p>A function's name shall be a verb or verb phrase (action), comprising one or more words. The first word is in lowercase, while the rest are initial-capitalized (known as <em>camel-case</em>).  For example, <code>getArea()</code>, <code>setRadius()</code>, <code>moveDown()</code>, <code>isPrime()</code>, etc.</p>

<h5>Function Prototype</h5>

<p>In C, a function must be declared before it can be called. It can be achieved by either placing the <em>function definition</em> before it is being used, or declare a so-called <em>function prototype</em>.</p>
<p>A function prototype tells the compiler the function's interface, i.e., the return-type, function name, and the parameter type list (the number and type of parameters).  The function can now be defined anywhere in the file. For example,</p>

<pre class="color-example">
<span class="color-comment">// Function prototype - placed before the function is used.</span>
double getArea(double);  <span class="color-comment">// without the parameter name</span>
int max(int, int);</pre>
<p>You could optionally include the parameter names in the function prototype. The names will be ignored by the compiler, but serve as documentation. For example,</p>

<pre class="color-example">
<span class="color-comment">// Function Prototype</span>
double getArea(double radius);  <span class="color-comment">// parameter names are ignored, but serve as documentation</span>
int max(int number1, int number2);</pre>

<p>Function prototypes are usually grouped together and placed in a so-called <em>header file</em>. The header file can be included in many programs. We will discuss header file later.</p>

<h5>Another Example</h5>

<p>We have a function called <code>max(int, int)</code>, which takes two <code>int</code> and return their maximum. We invoke the <code>max()</code> function from the <code>main()</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Testing max function (TestMaxFunction.c) */</span>
#include &lt;stdio.h&gt;
 
int maximum(int, int);<span class="color-comment"> // Function prototype (declaration)</span>
 
int main() {
   printf(&quot;%d\n&quot;, maximum(5, 8)); <span class="color-comment"> // Call maximum() with literals</span>
 
   int a = 6, b = 9, c;
   c = maximum(a, b);             <span class="color-comment"> // Call maximum() with variables</span>
   printf(&quot;%d\n&quot;, c);
 
   printf(&quot;%d\n&quot;, maximum(c, 99));<span class="color-comment"> // Call maximum()</span>
}
 
<span class="color-comment">// Function definition</span>
<span class="color-comment">// A function that returns the maximum of two given int</span>
int maximum(int num1, int num2) {
   return (num1 &gt; num2) ? num1 : num2;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>The &quot;<span class="font-code">void</span>&quot; Return Type</h5>

<p>Suppose that you need a function to perform certain actions (e.g., printing) without a need to return a value to the caller, you can declare its return-value type as <code>void</code>. In the function's body, you could use a &quot;<code>return;</code>&quot; statement without a return value to return control to the caller. In this case, the <code>return</code> statement is optional. If there is no <code>return</code> statement, the entire body will be executed, and control returns to the caller at the end of the body.</p>

<h5>Actual Parameters vs. Formal Parameters</h5>

<p>Recall that a function receives <em>arguments</em> from its caller, performs the actions defined in the function's body, and return a value (or nothing) to the caller.</p>

<p>In the above example, the variable <code>(double radius)</code> declared in the signature of <code>getArea(double radius)</code> is known as <em>formal parameter</em>. Its scope is within the function's body. When the function is invoked by a caller, the caller must supply so-called <em>actual parameter</em>s (or <em>arguments</em>), whose value is then used for the actual computation. For example, when the function is invoked via &quot;<code>area1 = getArea(radius1)</code>&quot;, <code>radius1</code> is the actual parameter, with a value of <code>1.1</code>.</p>

<h5>Scope of Function's Local Variables and Parameters</h5>

<p>All variables, including function's parameters, declared inside a function are available only to the function. They are created when the function is called, and freed (destroyed) after the function returns. They are called <em>local variables</em> because they are local to the function and not available outside the function. They are also called <em>automatic variables</em>, because they are created and destroyed automatically - no programmer's explicit action needed to allocate and deallocate them.</p>

<h5>Boolean Functions</h5>

<p>A boolean function returns a <code>int</code> value of either 0 or not 0 to the caller.</p>

<p>Suppose that we wish to write a function called <code>isOdd()</code> to check if a given number is odd.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Test Boolean function (BooleanfunctionTest.c).
 */</span>
#include &lt;stdio.h&gt;
 
<span class="color-comment">// Function Prototype</span>
int isOdd(int);
 
int main() {
   printf(&quot;%d\n&quot;, isOdd(5)); <span class="color-comment"> // 1 (true)</span>
   printf(&quot;%d\n&quot;, isOdd(6)); <span class="color-comment"> // 0 (false)</span>
   printf(&quot;%d\n&quot;, isOdd(-5));<span class="color-comment"> // 0 (false)</span>
}
 
int isOdd(int number) {
   if (number % 2 == 1) {
      return 1;
   } else {
      return 0;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This seemingly correct codes produces <code>false</code> for <code>-5</code>, because <code>-5%2</code> is <code>-1</code> instead of <code>1</code>.  You may rewrite the condition:</p>
<pre class="color-example">
bool isOdd(int number) {
   if (number % 2 == 0) {
      return false;
   } else {
      return true;
   }
}</pre>
<p>The above code produces the correct answer, but is poor.  For boolean function, you should simply return the resultant value of the comparison, instead of using a conditional statement, as follow:</p>
<pre class="color-example">
int isEven(int number) {
   return (number % 2 == 0);
}
 
int isOdd(int number) {
  return !(number % 2 == 0);  <span class="color-comment">// OR return !isEven(number);</span>
}
 
int main() {
   int number = -9;
   if (isEven(number)) {      <span class="color-comment">// Don't write (isEven(number) != 0)</span>
      printf(&quot;Even\n&quot;);
   }
   if (isOdd(number)) {      <span class="color-comment">// Don't write (isOdd(number) != 0)</span>
      printf(&quot;Odd\n&quot;);
   }
}</pre>

<h4>Functions and Arrays</h4>

<p>You can also pass arrays into function. However, you also need to pass the size of the array into the function. This is because there is no way to tell the size of the array from the array argument inside the called function.</p>

<p>For example,</p>

<h5>Example: Computing the Sum of an Array and Print Array's Contents</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Function to compute the sum of an array (SumArray.c) */</span>
#include &lt;stdio.h&gt;
 
<span class="color-comment">// Function prototype</span>
int sum(int array[], int size);   <span class="color-comment"> // Need to pass the array size too</span>
void print(int array[], int size);
 
<span class="color-comment">// Test Driver</span>
int main() {
   int a1[] = {8, 4, 5, 3, 2};
   print(a1, 5);  <span class="color-comment"> // {8,4,5,3,2}</span>
   printf(&quot;sum is %d\n&quot;, sum(a1, 5)); <span class="color-comment"> // sum is 22</span>
}
 
<span class="color-comment">// Function definition</span>
<span class="color-comment">// Return the sum of the given array</span>
int sum(int array[], int size) {
   int sum = 0;
   int i;
   for (i = 0; i &lt; size; ++i) {
      sum += array[i];
   }
   return sum;
}
 
<span class="color-comment">// Print the contents of the given array</span>
void print(int array[], int size) {
   int i;
   printf(&quot;{&quot;);
   for (i = 0; i &lt; size; ++i) {
      printf(&quot;%d&quot;, array[i]);
      if (i &lt; size - 1) {
         printf(&quot;,&quot;);
      }
   }
   printf(&quot;}\n&quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Pass-by-Value vs. Pass-by-Reference</h4>

<p>There are two ways that a parameter can be passed into a function: <em>pass by value</em> vs. <em>pass by reference</em>.</p>

<h5>Pass-by-Value</h5>

<p>In pass-by-value, a &quot;copy&quot; of argument is created and passed into the function. The invoked function works on the &quot;clone&quot;, and cannot modify the original copy. In C, fundamental types (such as <code>int</code> and <code>double</code>) are passed by value. That is, you cannot modify caller's value inside the function - there is no <em>side effect</em>.</p>

<h5>Example (Fundamental Types are Passed by Value)</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Fundamental types are passed by value into Function (TestPassByValue.c) */</span>
#include &lt;stdio.h&gt;
 
<span class="color-comment">// Function prototypes</span>
int inc(int number);
 
<span class="color-comment">// Test Driver</span>
int main() {
   int n = 8;
   printf(&quot;Before calling function, n is %d\n&quot;, n);<span class="color-comment"> // 8</span>
   int result = inc(n);
   printf(&quot;After calling function, n is %d\n&quot;, n); <span class="color-comment"> // 8</span>
   printf(&quot;result is %d\n&quot;, result);               <span class="color-comment"> // 9</span>
}
 
<span class="color-comment">// Function definitions</span>
<span class="color-comment">// Return number+1</span>
int inc(int number) {
   ++number; <span class="color-comment"> // Modify parameter, no effect to caller</span>
   return number;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Pass-by-Reference</h5>

<p>On the other hand, in pass-by-reference, a <em>reference</em> of the caller's variable is passed into the function. In other words, the invoked function works on the same data. If the invoked function modifies the parameter, the same caller's copy will be modified as well.</p>
<p>In C, arrays are passed by reference. That is, you can modify the contents of the caller's array inside the invoked function - there could be <em>side effect</em> in passing arrays into function.</p>
<p>C does not allow functions to return an array. Hence, if you wish to write a function that modifies the contents of an array (e.g., sorting the elements of an array), you need to rely on pass-by-reference to work on the same copy inside and outside the function. Recall that in pass-by-value, the invoked function works on a <em>clone</em> copy and has no way to modify the original copy.</p>

<h5>Example (Array is passed by Reference): Increment Each Element of an Array</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Function to increment each element of an array (IncrementArray.c) */</span>
#include &lt;stdio.h&gt;
 
<span class="color-comment">// Function prototypes</span>
void inc(int array[], int size);
void print(int array[], int size);
 
<span class="color-comment">// Test Driver</span>
int main() {
   int a1[] = {8, 4, 5, 3, 2};
 
  <span class="color-comment"> // Before increment</span>
   print(a1, 5);  <span class="color-comment"> // {8,4,5,3,2}</span>
  <span class="color-comment"> // Do increment</span>
   inc(a1, 5);    <span class="color-comment"> // Array is passed by reference (having side effect)</span>
  <span class="color-comment"> // After increment</span>
   print(a1, 5);  <span class="color-comment"> // {9,5,6,4,3}</span>
}
 
<span class="color-comment">// Function definitions</span>
 
<span class="color-comment">// Increment each element of the given array</span>
void inc(int array[], int size) { <span class="color-comment"> // array[] is not const</span>
   int i;
   for (i = 0; i &lt; size; ++i) {
      array[i]++; <span class="color-comment"> // side-effect</span>
   }
}
 
<span class="color-comment">// Print the contents of the given array</span>
void print(int array[], int size) {
   int i;
   printf(&quot;{&quot;);
   for (i = 0; i &lt; size; ++i) {
      printf(&quot;%d&quot;, array[i]);
      if (i &lt; size - 1) {
         printf(&quot;,&quot;);
      }
   }
   printf(&quot;}\n&quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Array is passed into function by reference. That is, the invoked function works on the same copy of the array as the caller. Hence, changes of array inside the function is reflected outside the function (i.e., side effect).</p>

<h5>Why Arrays are Pass-by-Reference?</h5>

<p>Array is designed to be passed by reference, instead of by value using a cloned copy. This is because passing huge array by value is inefficient - the huge array needs to be cloned.</p>

<h4>&quot;<span class="font-code">const</span>&quot; Function Parameters</h4>
<p>Pass-by-reference risks corrupting the original data. If you do not have the intention of modifying the arrays inside the function, you could use the <code>const</code> keyword in the function parameter. A <code>const</code> function argument cannot be modified inside the function.</p>

<p>Use <code>const</code> whenever possible for passing references as it prevent you from inadvertently modifying the parameters and protects you against many programming errors.</p>

<h5 id="LinearSearch">Example: Search an Array using Linear Search</h5>

<p>In a linear search, the search key is compared with each element of the array linearly. If there is a match, it returns the index of the array between [0, size-1]; otherwise, it returns -1 or the size of of the array (some implementations deal with only positive indexes). Linear search has complexity of O(n).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Search an array for the given key using Linear Search (LinearSearch.c) */</span>
#include &lt;stdio.h&gt;
 
int linearSearch(const int a[], int size, int key);
 
int main() {
   const int SIZE = 8;
   int a1[] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   printf(&quot;%d\n&quot;, linearSearch(a1, SIZE, 8)); <span class="color-comment"> // 0</span>
   printf(&quot;%d\n&quot;, linearSearch(a1, SIZE, 4)); <span class="color-comment"> // 1</span>
   printf(&quot;%d\n&quot;, linearSearch(a1, SIZE, 99));<span class="color-comment"> // 8 (not found)</span>
}
 
<span class="color-comment">// Search the array for the given key</span>
<span class="color-comment">// If found, return array index [0, size-1]; otherwise, return size</span>
int linearSearch(const int a[], int size, int key) {
   int i;
   for (i = 0; i &lt; size; ++i) {
      if (a[i] == key) return i;
   }
   return size;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5 id="BubbleSort">Example: Sorting an Array using Bubble Sort</h5>

<p>Wiki &quot;<a href="en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a>&quot; for the <code></code>detailed algorithm and illustration. In brief, we pass thru the list, compare two adjacent items and swap them if they are in the wrong order. Repeat the pass until no swaps are needed. For example,</p>

<pre class="color-example">
{8,4,5,3,2,9,4,1}
PASS 1 ...
{8,4,5,3,2,9,4,1} =&gt; {4,8,5,3,2,9,4,1}
{4,8,5,3,2,9,4,1} =&gt; {4,5,8,3,2,9,4,1}
{4,5,8,3,2,9,4,1} =&gt; {4,5,3,8,2,9,4,1}
{4,5,3,8,2,9,4,1} =&gt; {4,5,3,2,8,9,4,1}
{4,5,3,2,8,9,4,1} =&gt; {4,5,3,2,8,4,9,1}
{4,5,3,2,8,4,9,1} =&gt; {4,5,3,2,8,4,1,9}
PASS 2 ...
{4,5,3,2,8,4,1,9} =&gt; {4,3,5,2,8,4,1,9}
{4,3,5,2,8,4,1,9} =&gt; {4,3,2,5,8,4,1,9}
{4,3,2,5,8,4,1,9} =&gt; {4,3,2,5,4,8,1,9}
{4,3,2,5,4,8,1,9} =&gt; {4,3,2,5,4,1,8,9}
PASS 3 ...
{4,3,2,5,4,1,8,9} =&gt; {3,4,2,5,4,1,8,9}
{3,4,2,5,4,1,8,9} =&gt; {3,2,4,5,4,1,8,9}
{3,2,4,5,4,1,8,9} =&gt; {3,2,4,4,5,1,8,9}
{3,2,4,4,5,1,8,9} =&gt; {3,2,4,4,1,5,8,9}
PASS 4 ...
{3,2,4,4,1,5,8,9} =&gt; {2,3,4,4,1,5,8,9}
{2,3,4,4,1,5,8,9} =&gt; {2,3,4,1,4,5,8,9}
PASS 5 ...
{2,3,4,1,4,5,8,9} =&gt; {2,3,1,4,4,5,8,9}
PASS 6 ...
{2,3,1,4,4,5,8,9} =&gt; {2,1,3,4,4,5,8,9}
PASS 7 ...
{2,1,3,4,4,5,8,9} =&gt; {1,2,3,4,4,5,8,9}
PASS 8 ...
{1,2,3,4,4,5,8,9}</pre>

<p>Bubble sort is not efficient, with complexity of O(n<sup>2</sup>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Sorting an array using Bubble Sort (BubbleSort.c) */</span>
#include &lt;stdio.h&gt;
 
void bubbleSort(int a[], int size);
void print(const int a[], int size);
 
int main() {
   const int SIZE = 8;
   int a[] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   print(a, SIZE);
   printf(&quot;\n&quot;);
   bubbleSort(a, SIZE);
   print(a, SIZE);
   printf(&quot;\n&quot;);
}
 
<span class="color-comment">// Sort the given array of size</span>
void bubbleSort(int a[], int size) {
   int done = 0;<span class="color-comment"> // terminate if no more swap thru a pass</span>
   int pass = 0;     <span class="color-comment"> // pass number, for tracing</span>
   int temp;         <span class="color-comment"> // use for swapping</span>
 
   while (!done) {
      printf(&quot;PASS %d...\n&quot;, ++pass);  <span class="color-comment"> // for tracing</span>
      done = 1;
     <span class="color-comment"> // Pass thru the list, compare adjacent items and swap</span>
     <span class="color-comment"> // them if they are in wrong order</span>
      int i;
      for (i = 0; i &lt; size - 1; ++i) {
         if (a[i] &gt; a[i+1]) {
            print(a, size);<span class="color-comment"> // for tracing</span>
            temp = a[i];
            a[i] = a[i+1];
            a[i+1] = temp;
            done = 0;  <span class="color-comment"> // swap detected, one more pass</span>
            printf(&quot;=&gt; &quot;); <span class="color-comment"> // for tracing</span>
            print(a, size);
            printf(&quot;\n&quot;);
         }
      }
   }
}
 
<span class="color-comment">// Print the contents of the given array of size</span>
void print(const int a[], int size) {
   int i;
   printf(&quot;{&quot;);
   for (i = 0; i &lt; size; ++i) {
      printf(&quot;%d&quot;, a[i]);
      if (i &lt; size - 1) printf(&quot;,&quot;);
   }
   printf(&quot;} &quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5 id="InsertionSort">Example: Sorting an Array using Insertion Sort</h5>

<p>Wiki &quot;<a href="http://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a>&quot; for the algorithm and illustration. In brief, pass thru the list. For each element, compare with all previous elements and insert it at the correct position by shifting the other elements. For example,</p>

<pre class="color-example">
{8,4,5,3,2,9,4,1}
{8} {4,5,3,2,9,4,1}
{4,8} {5,3,2,9,4,1}
{4,5,8} {3,2,9,4,1}
{3,4,5,8} {2,9,4,1}
{2,3,4,5,8} {9,4,1}
{2,3,4,5,8,9} {4,1}
{2,3,4,4,5,8,9} {1}
{1,2,3,4,4,5,8,9}</pre>

<p>Insertion sort is also not efficient, with complexity of O(n<sup>2</sup>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Sorting an array using Insertion Sort (InsertionSort.c) */</span>
#include &lt;stdio.h&gt;
 
void insertionSort(int a[], int size);
void print(const int a[], int iMin, int iMax);
 
int main() {
   const int SIZE = 8;
   int a[] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   print(a, 0, SIZE - 1);
   printf(&quot;\n&quot;);
   insertionSort(a, SIZE);
   print(a, 0, SIZE - 1);
   printf(&quot;\n&quot;);
}
 
<span class="color-comment">// Sort the given array of size using insertion sort</span>
void insertionSort(int a[], int size) {
   int temp;  <span class="color-comment"> // for shifting elements</span>
   int i, prev, shift;
   for (i = 1; i &lt; size; ++i) {
     <span class="color-comment"> // for tracing</span>
      print(a, 0, i - 1);   <span class="color-comment"> // already sorted</span>
      print(a, i, size - 1);<span class="color-comment"> // to be sorted</span>
      printf(&quot;\n&quot;);
 
     <span class="color-comment"> // For element at i, insert into proper position in [0, i-1]</span>
     <span class="color-comment"> //  which is already sorted.</span>
     <span class="color-comment"> // Shift down the other elements</span>
      for (prev = 0; prev &lt; i; ++prev) {
         if (a[i] &lt; a[prev]) {
           <span class="color-comment"> // insert a[i] at prev, shift the elements down</span>
            temp = a[i];
            for (shift = i; shift &gt; prev; --shift) {
               a[shift] = a[shift-1];
            }
            a[prev] = temp;
            break;
         }
      }
   }
}
 
<span class="color-comment">// Print the contents of the array in [iMin, iMax]</span>
void print(const int a[], int iMin, int iMax) {
   int i;
   printf(&quot;{&quot;);
   for (i = iMin; i &lt;= iMax; ++i) {
      printf(&quot;%d&quot; ,a[i]);
      if (i &lt; iMax) printf(&quot;,&quot;);
   }
   printf(&quot;} &quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5 id="SelectionSort">Example: Sorting an Array using Selection Sort</h5>

<p>Wiki &quot;<a href="http://en.wikipedia.org/wiki/Selection_sort">Selection Sort</a>&quot; for the algorithm and illustration. In brief, Pass thru the list. Select the smallest element and swap with the head of the list. For example,</p>

<pre class="color-example">
{8,4,5,3,2,9,4,1}
{} {8,4,5,3,2,9,4,1} =&gt; {} {1,4,5,3,2,9,4,8}
{1} {4,5,3,2,9,4,8} =&gt; {1} {2,5,3,4,9,4,8}
{1,2} {5,3,4,9,4,8} =&gt; {1,2} {3,5,4,9,4,8}
{1,2,3} {5,4,9,4,8} =&gt; {1,2,3} {4,5,9,4,8}
{1,2,3,4} {5,9,4,8} =&gt; {1,2,3,4} {4,9,5,8}
{1,2,3,4,4} {9,5,8} =&gt; {1,2,3,4,4} {5,9,8}
{1,2,3,4,4,5} {9,8} =&gt; {1,2,3,4,4,5} {8,9}
{1,2,3,4,4,5,8,9}</pre>

<p>Selection sort is also not efficient, with complexity of O(n<sup>2</sup>).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Sorting an array using Selection Sort (SelectionSort.c) */</span>
#include &lt;stdio.h&gt;
 
void selectionSort(int a[], int size);
void print(const int a[], int iMin, int iMax);
 
int main() {
   const int SIZE = 8;
   int a[] = {8, 4, 5, 3, 2, 9, 4, 1};
 
   print(a, 0, SIZE - 1);
   printf(&quot;\n&quot;);
   selectionSort(a, SIZE);
   print(a, 0, SIZE - 1);
   printf(&quot;\n&quot;);
}
 
<span class="color-comment">// Sort the given array of size using selection sort</span>
void selectionSort(int a[], int size) {
   int temp;<span class="color-comment"> // for swapping</span>
   int i, j;
   for (i = 0; i &lt; size - 1; ++i) {
     <span class="color-comment"> // for tracing</span>
      print(a, 0, i - 1);
      print(a, i, size - 1);
 
     <span class="color-comment"> // [0, i-1] already sort</span>
     <span class="color-comment"> // Search for the smallest element in [i, size-1]</span>
     <span class="color-comment"> //  and swap with a[i]</span>
      int minIndex = i; <span class="color-comment"> // assume fist element is the smallest</span>
      for (j = i + 1; j &lt; size; ++j) {
         if (a[j] &lt; a[minIndex]) minIndex = j;
      }
      if (minIndex != i) { <span class="color-comment"> // swap</span>
         temp = a[i];
         a[i] = a[minIndex];
         a[minIndex] = temp;
      }
 
     <span class="color-comment"> // for tracing</span>
      printf(&quot;=&gt; &quot;);
      print(a, 0, i - 1);
      print(a, i, size - 1);
      printf(&quot;\n&quot;);
   }
}
 
<span class="color-comment">// Print the contents of the array in [iMin, iMax]</span>
void print(const int a[], int iMin, int iMax) {
   int i;
   printf(&quot;{&quot;);
   for (i = iMin; i &lt;= iMax; ++i) {
      printf(&quot;%d&quot;, a[i]);
      if (i &lt; iMax) printf(&quot;,&quot;);
   }
   printf(&quot;} &quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Program Notes:</p>

<ul>
<li>[TODO]</li>
</ul>

<h5>&quot;<span class="font-code">const</span>&quot; Fundamental-Type Function Parameters?</h5>

<p>You could also use <code>const</code> for fundamental-type function parameters (such as <code>int</code>, <code>double</code>) to prevent the parameters from being modified inside the function. However, as fundamental-type parameters are passed by value (with a cloned copy), there will never be side effect on the caller. We typically do not use the <code>const</code> keyword for fundamental types. In other words, <code>const</code> is used to indicate that there shall NOT be side-effect.</p>

<h4>Mathematical Functions (Header <span class="font-code">&lt;math.h&gt;</span>)</h4>

<p>C provides many common-used Mathematical functions in library <code>&lt;math.h&gt;</code>. The signatures of some of these functions are:</p>

<table class="table-program">
<tr>
<td>
<pre class="color-syntax">
<strong>sin(x), cos(x), tan(x), asin(x), acos(x), atan(x)</strong>:
   Take argument-type and return-type of float, double, long double.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>atan2(y, x)</strong>:
   Return arc-tan of y/x. Better than atan(x) for handling 90 degree.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>sinh(x), cosh(x), tanh(x)</strong>:
   hyper-trigonometric functions.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>pow(x, y), sqrt(x):</strong>
   power and square root.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>ceil(x), floor(x):</strong>
   returns the ceiling and floor integer of floating point number.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>fabs(x), fmod(x, y):</strong>
   floating-point absolute and modulus.</pre>
</td>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>exp(x), log(x), log10(x):</strong>
   exponent and logarithm functions.</pre>
</td>
</tr>

</table>

<h4>Generating Random Numbers</h4>

<p>The <code>stdlib.h</code> header provides a function <code>rand()</code>, which generates a pseudo-random integral number between 0 and <code>RAND_MAX</code> (inclusive). <code>RAND_MAX</code> is a constant defined in <code>stdlib.h</code> (typically the maximum value of 16-/32-bit signed integer, such as 32767). You can generate a random number between <code>[0,n)</code> via <code>rand() % n</code>.</p>
<p><code>rand()</code> generates the same squence of pseudo-random numbers on different invocations. The <code>stblib.h</code> also provides a <code>srand()</code> function to <em>seed</em> or initialize the random number generator. We typically seed it with the current time obtained via <code>time(0)</code> function (in <code>&lt;time.h&gt;</code> header), which returns the number of seconds since January 1st, 1970.</p>

<h5>Example 1: Test <span class="font-code">rand()</span> and <span class="font-code">srand(time(0))</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test Random Number Generation (TestRand.c) */</span>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; <span class="color-comment"> // for rand(), srand()</span>
#include &lt;time.h&gt;   <span class="color-comment"> // for time()</span>
 
int main() {
  <span class="color-comment"> // rand() generate a random number in [0, RAND_MAX]</span>
   printf(&quot;RAND_MAX is %d\n&quot;, RAND_MAX);  <span class="color-comment"> // 32767</span>
 
  <span class="color-comment"> // Generate 10 pseudo-random numbers between 0 and 99</span>
  <span class="color-comment"> //   without seeding the generator.</span>
  <span class="color-comment"> // You will get the same sequence, every time you run this program</span>
   int i;
   for (i = 0; i &lt; 10; ++i) {
      printf(&quot;%d &quot;, rand() % 100);  <span class="color-comment"> // need &lt;stdlib.h&gt; header</span>
   }
   printf(&quot;\n&quot;);
 
  <span class="color-comment"> // Seed the random number generator with current time</span>
   srand(time(0));  <span class="color-comment"> // need &lt;cstdlib&gt; and &lt;ctime&gt; header</span>
  <span class="color-comment"> // Generate 10 pseudo-random numbers</span>
  <span class="color-comment"> // You will get different sequence on different run,</span>
  <span class="color-comment"> //   because the current time is different</span>
   for (i = 0; i &lt; 10; ++i) {
      printf(&quot;%d &quot;, rand() % 100);  <span class="color-comment"> // need &lt;stdlib.h&gt; header</span>
   }
   printf(&quot;\n&quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Example 2: Test <span class="font-code">rand()</span>'s Distribution</h5>

<p>We shall test the <code>rand()</code>'s distribution by repeatedly throwing a 6-sided die and count the occurrences.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test rand() distribution by throwing a die repeatedly (TestRandomDie.c) */</span>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; <span class="color-comment"> // for rand(), srand()</span>
#include &lt;time.h&gt;   <span class="color-comment"> // for time()</span>
 
const int TOTAL_COUNT = 2000000; <span class="color-comment"> // Close to INT_MAX</span>
const int NUM_FACES = 6;
int frequencies[6] = {0};<span class="color-comment"> // frequencies of 0 to 5, init to zero</span>
 
int main() {
   srand(time(0));<span class="color-comment"> // seed random number generator with current time</span>
  <span class="color-comment"> // Throw the die and count the frequencies</span>
   int i;
   for (i = 0; i &lt; TOTAL_COUNT; ++i) {
      ++frequencies[rand() % 6];
   }
 
  <span class="color-comment"> // Print statistics</span>
   for (i = 0; i &lt; NUM_FACES; i++) {
      printf(&quot;%d: %d (%.2lf%)\n&quot;, i+1, frequencies[i],
           100.0 * frequencies[i] / TOTAL_COUNT);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
1: 333109 (16.66%)
2: 333113 (16.66%)
3: 333181 (16.66%)
4: 333562 (16.68%)
5: 333601 (16.68%)
6: 333434 (16.67%)</pre>

<p>As seen from the output, <code>rand()</code> is fairly <em>uniformly-distributed</em> over <code>[0, RAND_MAX]</code>.</p>

<h4>Exercises</h4>

<p>[TODO]</p>

<h3>Characters and Strings</h3>
<p>A C-string is an array of characters terminated with a null character, denoted as <code>'\0'</code> which is equivalent to ASCII 0. For example,</p>

<pre class="color-example">
char message[] = {'H', 'e', 'l', 'l', 'o', '\0'};
char message[] = &quot;Hello&quot;;      <span class="color-comment">// same as above</span></pre>

<p>Clearly, the length of array is the length of string plus 1, to account for the terminating null character <code>'\0'</code>.</p>

<p>You can use <code>scanf()</code> to input a string, and <code>printf()</code> to print a string, with %s conversion specifier. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
int main() {
   char message[256];
     <span class="color-comment"> // The length of char array shall be sufficient to hold the string</span>
     <span class="color-comment"> // plus the terminating null character '\0'</span>
   printf(&quot;Enter a message: &quot;);
   scanf(&quot;%s&quot;, message);
     <span class="color-comment"> // Do not place an &amp; before the array variable</span>
   printf(&quot;The message is: %s\n&quot;, message);
     <span class="color-comment"> // Print up to but not including the terminating null character '\0'</span>
 
  <span class="color-comment"> // print each characters</span>
   int i;
   for (i = 0; message[i] != '\0'; ++i) {
      printf(&quot;'%c' &quot;, message[i]);
   }
   printf(&quot;\n&quot;);
 
   int len = strlen(message);
     <span class="color-comment"> // Length of string does not include terminating null character '\0'</span>
   printf(&quot;The length of string is %d\n&quot;, len);
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Enter a message: <strong>hello</strong>
The message is: hello
'h' 'e' 'l' 'l' 'o'
The length of string is 5</pre>

<p>Take note that you need to allocate a <code>char</code> array that is big enough to hold the input string including the terminating null character <code>'\0'</code>.</p>

<h4>Character Type and Conversion in <span class="font-code">&lt;ctype.h&gt;</span> Header</h4>

<table class="table-zebra">
<tr>
<th>Function</th>
<th colspan="2">Description</th>
</tr>

<tr>
<td><code>int <strong>isalpha</strong>(int c);<br />
int <strong>isdigit</strong>(int c);<br />
int <strong>isalnum</strong>(int c);<br />
int <strong>isxdigit</strong>(int c);<br />
int <strong>isspace</strong>(int c);<br />
int <strong>iscntrl</strong>(int c);<br />
int <strong>ispunct</strong>(int c);<br />
int <strong>isprint</strong>(int c);<br />
int <strong>isgraph</strong>(int c);</code></td>
<td><code>[a-zA-Z]<br />
[0-9]<br />
[a-zA-Z0-9]<br />
[0-9A-Fa-f]<br />
[ \t\n]</code><br />
Control character<br />
Punctuation character<br />
Printable character<br />
Graphical character</td>
<td>Check the character's type and return true (non-zero) or false (0)</td>
</tr>

<tr class="tr-alt">
<td><code>int <strong>isupper</strong>(int c);<br />
int <strong>islower</strong>(int c);</code></td>
<td><code>[A-Z]<br />
[a-z]</code></td>
<td>Check if uppercase/lowercase and return true (non-zero) or false (0)</td>
</tr>

<tr>
<td><code>int <strong>toupper</strong>(int c);<br />
int <strong>tolower</strong>(int c);</code></td>
<td>To Uppercase<br />
To Lowercase</td>
<td>Return the uppercase/lowercase character, if <code>c</code> is a lowercase/uppercase character; otherwise, return <code>c</code>.</td>
</tr>
</table>


<p>Example: [TODO]</p>

<h4>String/Number Conversion in <span class="font-code">&lt;stdlib.h&gt;</span> Header</h4>

<p>The <code>stdlib.h</code> contains function prototypes for conversion between string and numbers.</p>

<table class="table-zebra">
<tr>
<th>Function</th>
<th colspan="2">Description</th>
</tr>

<tr>
<td><code>int <strong>atoi</strong>(const char * str);<br />
double <strong>atof</strong>(const char * str);<br />
long <strong>atol</strong>(const char * str);<br />
long long <strong>atoll</strong>(const char * str);<br /></code></td>
<td>String to <code>int</code><br />
String to <code>double</code><br />
String to <code>long</code><br />
String to <code>long long</code></td>
<td>Convert the <code>str</code> to <br />  <code>int/double/long/long long</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>double <strong>strtod</strong>(const char* str, char** endptr);<br />
float <strong>strtof</strong>(const char* str, char** endptr);</code></td>
<td>String to <code>double</code><br />
String to <code>float</code></td>
<td>Convert the <code>str</code> to <code>double/float</code>.<br />If <code>endptr</code> is not a null pointer, <br />
  it will be set to point to the first character after the number.</td>
</tr>

<tr>
<td><code>long  <strong>strtol</strong>(const char* str, char** endptr, int base);<br />
unsigned long <strong>strtoul</strong>(const char* str, char** endptr, int base);</code></td>
<td>String to <code>long</code><br />
String to <code>unsigned long</code></td>
<td>Convert the <code>str</code> to <code>long/unsigned long</code>.</td>
</tr>
</table>

<p>Example: [TODO]</p>


<h4>String Manipulation in <span class="font-code">&lt;string.h&gt;</span> Header</h4>

<table class="table-zebra">
<tr>
<th>Function</th>
<th colspan="2">Description</th>
</tr>

<tr>
<td><code>char* <strong>strcpy</strong>(char* dest, const char* src);<br />
char* <strong>strncpy</strong>(char* dest, const char* src, size_t n);<br /></code></td>
<td>String copy<br />
String copy at most n-chars</td>
<td>Copy <code>src</code> into <code>dest</code>. <br />
  Return <code>dest</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>char* <strong>strcat</strong>(char* dest, const char* src);<br />
char* <strong>strncat</strong>(char* dest, const char* src, size_t n);<br /></code></td>
<td>String concatenation<br />
String concatenation at most n-char</td>
<td>Concatenate <code>src</code> into <code>dest</code>.<br />
  Return <code>dest</code>.</td>
</tr>

<tr>
<td><code>int <strong>strcmp</strong>(const char* s1, const char* s2);<br />
int <strong>strncmp</strong>(const char* s1, const char* s2, size_t n);</code></td>
<td>String compare<br />
String compare at most n-char</td>
<td>Comparing <code>s1</code> and <code>s2</code>.<br />
Return 0, less than 0, more than 0<br />
if <code>s1</code> is the same, less than, more than <code>s2</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>int <strong>strlen</strong>(const char* str);</code></td>
<td>String Length</td>
<td>Return the length of <code>str</code><br />
(excluding terminating null char)</td>
</tr>

<tr>
<td><code>char* <strong>strchr</strong>(const char* str, int c);<br />
char* <strong>strrchr</strong>(const char* str, int c);</code></td>
<td>Search string for char<br />
Search string for char reverse</td>
<td>Return a pointer to the first/last occurrence<br />
of <code>c</code> in <code>str</code><br />
if present. Otherwise, return <code>NULL</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>char* <strong>strpbrk</strong>(const char* str, const char* pattern);</code></td>
<td>Search string for char in pattern</td>
<td>Locate the first occurrence in <code>str</code><br />
of <em>any character</em> in <code>pattern</code>.</td>
</tr>

<tr>
<td><code>char* <strong>strstr</strong>(const char* str, const char* substr);</code></td>
<td>Search string for sub-string</td>
<td>Return a pointer to the first occurrence<br />
of <code>substr</code> in <code>str</code><br />
if present. Otherwise, return <code>NULL</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>char* <strong>strspn</strong>(const char* str, const char* substr);<br />
char* <strong>strcspn</strong>(const char* str, const char* substr);</code></td>
<td>Search string for span of substr<br />
Search string for complement span of substr</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><code>char* <strong>strtok</strong>(char* str, char *delimit);</code></td>
<td>Split string into tokens</td>
<td>&nbsp;</td>
</tr>

<tr class="tr-alt">
<td><code>void* <strong>memcpy</strong>(void *dest, const void *src, size_t n);<br />
void* <strong>memmove</strong>(void *dest, const void *src, size_t n);<br />
int <strong>memcmp</strong>(const void *p1, const void *p2, size_t n);<br />
void* <strong>memchr</strong>(void *ptr, int value, size_t n);<br />
void* <strong>memset</strong>(void *ptr, int value, size_t n);</code></td>
<td>Memory block copy<br />
Memory block move<br />
Memory block compare<br />
Search memory block for char<br />
Memory block set (fill)</td>
<td>&nbsp;</td>
</tr>
</table>

<p>Example: [TODO]</p>


<h4>char/string IO in <span class="font-code">&lt;stdio.h&gt;</span> Header</h4>

<table class="table-zebra">
<tr>
<th>Function</th>
<th colspan="2">Description</th>
</tr>

<tr>
<td><code>int getchar();<br />
int putchar(int c);</code></td>
<td>Get character (from <code>stdin</code>)<br />
Put character (to <code>stdout</code>)</td>
<td>Input/Output a character<br />
  from <code>stdin/stdout</code>.</td>
</tr>

<tr class="tr-alt">
<td><code>int getc(FILE *stream);<br />
int putc(int c, FILE *stream);<br />
int ungetc(int c, FILE *stream);</code></td>
<td>Get character (from FILE stream)<br />
Put character (to FILE stream)<br />
Un-get character (to FILE stream)</td>
<td>Input/Output a character<br />
from <code>FILE</code> stream.</td>
</tr>

<tr>
<td><code>char* gets(char *str);<br />
int puts(const char* str);</code></td>
<td>Get string (from <code>stdin</code>)<br />
Put string (to <code>stdout</code>)</td>
<td>Input/Output string<br />from <code>stdin/stdout</code>.</td>
</tr>

<tr>
<td><code>int sprintf(char *str, const char *format, ...);<br />
int sscanf(char *str, const char *format, ....);</code></td>
<td>Formatted print (to string)<br />
Formatted scan (from string)</td>

<td>Formatted string input/output.<br />
Similar to <code>printf()</code> and <code>scanf()</code>,<br />
except that the output/input comes from the <code>str</code>.</td>
</tr>
</table>

<p>Example: [TODO]</p>


<h3>File Input/Output</h3>
<p>[TODO]</p>

<h4>File IO in <span class="font-code">&lt;stdio.h&gt;</span> Header</h4>

<table class="table-zebra">
<tr>
<th>Function</th>
<th colspan="2w">Description</th>
</tr>

<tr>
<td><code>FILE* fopen(const char* filename, const char* mode);<br /> 
int fclose(FILE *stream);<br />
FILE* freopen(const char* filename, const char* mode, FILE *stream);</code></td>
<td>File open<br />
File close</td>
<td>Open/Close a file.</td>
</tr>

<tr class="tr-alt">
<td><code>int fprintf(FILE *stream, const char *format, ...);<br  />
int fscanf(FILE *stream, const char *format, ...);
</code></td>
<td>Formatted print to file<br />
Formatted scan from file</td>
<td>Formatted file input/output.<br />
Similar to <code>printf()/scanf()</code>,<br />
except that the input/output comes from file</td>
</tr>

<tr>
<td><code>int fgetc(FILE *stream)<br />
int fputc(int c, FILE *stream);<br />
char* fgets(char *str, size_t n, FILE *stream);<br />
int fputs(const char *str, FILE *stream);</code></td>
<td>Get character from file<br />
Put character to file<br />
Get string from file<br />
Put string to file</td>
<td>Unformatted character/string input/output from file</td>
</tr>

<tr class="tr-alt">
<td><code>size_t fread(void *ptr size_t size, size_t count, FILE *stream)<br />
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);<br />
int fgetpos(FILE *stream, fpos_t *pos);<br />
int fsetpos(FILE *stream, const fpos_t *pos);<br />
int fseek(FILE *stream, long offset, int origin);<br />
long ftell(FILE *stream);</code></td>
<td>File read<br />
File write<br />
Get file position<br />
Set file position<br />
File seek<br />
Tell file</td>
<td>Direct Access</td>
</tr>

<tr>
<td><code>void rewind(FILE *stream);</code></td>
<td>Rewind file</td>
<td>Set the file position to the beginning</td>
</tr>

<tr class="tr-alt">
<td><code>int fflush(FILE *stream);</code></td>
<td>File Flush</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><code>int feof(FILE *stream);<br />
int ferror(FILE *stream);<br />
void perror(const char *str);</code></td>
<td>Test end-of-file<br />
  Check file error<br />
  Print error message</td>
<td>&nbsp;</td>
</tr>
</table>

<h5>Open/Close File</h5>

<p>To open a file, use <code>fopen(filename, mode)</code>. The modes are:</p>

<table class="table-zebra">
<tr>
<th>Mode</th>
<th colspan="2">Description</th>
</tr>

<tr>
<td><code>&quot;r&quot;</code></td>
<td>Read</td>
<td>Open file for reading. The file shall exist.</td>
</tr>

<tr>
<td><code>&quot;w&quot;</code></td>
<td>Write</td>
<td>Open file for writing. If the file does not exist, create a new file; otherwise, discard existing contents.</td>
</tr>

<tr>
<td><code>&quot;a&quot;</code></td>
<td>Append</td>
<td>Open file for writing. If the file does not exist, create a new file; otherwise, append to the existing file.</td>
</tr>
<tr>
<td><code>&quot;r+&quot;</code></td>
<td>Read/Write</td>
<td>Open file for reading/writing. The file shall exist.</td>
</tr>
<tr>
<td><code>&quot;w+&quot;</code></td>
<td>Read/Write</td>
<td>Open file for reading/writing. If the file does not exist, create a new file; otherwise, discard existing contents.</td>
</tr>
<tr>
<td><code>&quot;a+&quot;</code></td>
<td>Read/Append</td>
<td>Open file for reading/writing. If the file does not exist, create a new file; otherwise, append to the existing file.</td>
</tr>

<tr>
<td colspan="2"><code>&quot;rb&quot; &quot;wb&quot; &quot;ab&quot; &quot;rb+&quot; &quot;wb+&quot; &quot;ab+&quot;</code></td>
<td>For binary files.</td>
</tr>
</table>

<h5>File Stream</h5>
<p>You can use <code>stdin</code>, <code>stdout</code>, <code>stderr</code> to denote <em>standard input stream</em> (keyboard), <em>standard output stream</em> (console) and <em>standard error stream</em> (console).</p>

<h4>Sequential-Access File</h4>

<h5>Example 1: Formatted File Input/Output</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/* Test File IO (TestFileIO.c) */</span>
#include &lt;stdio.h&gt;
 
int main() {
   FILE *fin, *fout;
 
   fout = fopen(&quot;test.txt&quot;, &quot;w&quot;);
   fprintf(fout, &quot;%d %lf %s\n&quot;, 123, 44.55, &quot;Hello&quot;);
   fclose(fout);
 
   fin = fopen(&quot;test.txt&quot;, &quot;r&quot;);
   int i;
   double d;
   char msg[80];
   fscanf(fin, &quot;%d %lf %s&quot;, &amp;i, &amp;d, msg);
   printf(&quot;i is %d\n&quot;, i);
   printf(&quot;d is %lf\n&quot;, d);
   printf(&quot;msg is %s\n&quot;, msg);
   fclose(fin);
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Example 2</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td>
<pre>
#include &lt;stdio.h&gt;
#define SIZE 80    <span class="color-comment">// size of string buffer</span>
 
int main() {
   FILE * pFile;
   char buffer[SIZE];
 
   pFile = fopen(&quot;test.txt&quot; , &quot;r&quot;);
   if (pFile == NULL) {
      perror(&quot;Error opening file&quot;);
   } else {
      while (!feof(pFile)) {
         if (fgets(buffer, SIZE, pFile) == NULL) break;
         fputs (buffer , stdout);
      }
      fclose(pFile);
   }
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Direct-Access File IO</h4>
<p>[TODO]</p>


<h3>Pointers and Dynamic Allocation</h3>
<p>[TODO]</p>

<h4>Array and Pointer</h4>
<p>[TODO]</p>

<h4>String as <span class="font-code">char</span> pointer</h4>

<p>In C, an array name is equivalent to a pointer pointing to the first element of the array. For example, if <code>msg</code> is a <code>char</code> array (<code>char msg[256]</code>),  then <code>msg</code> is <code>&amp;msg[0]</code>.</p>
<p>We can declare and initialize a string via <code>char</code> pointer; and operate the string via <code>char</code> pointer.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11</pre>
</td>
<td>
<pre>
#include &lt;stdio.h&gt;
 
int main() {
   char *msg = &quot;hello&quot;;  <span class="color-comment">// Append a terminating null character '\0'</span>
   char *p;
 
   for (p = msg; *p != '\0'; ++p) {
      printf(&quot;'%c' &quot;, *p);
   }
   printf(&quot;\n&quot;);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>[TODO]</p>

<h3><span class="font-code">struct</span>, <span class="font-code">union</span> and <span class="font-code">enum</span></h3>
<p>[TODO]</p>

<h3>Miscellaneous</h3>

<h4>Bit Operations</h4>
<p>[TODO]</p>

<h4>C Library Headers</h4>

<ul>
<li><span class="line-heading-code-new">&lt;stdio.h&gt;</span>: contains function prototypes for standard input/output functions such as <code>printf()</code> and <code>scanf()</code>.</li>

<li><span class="line-heading-code-new">&lt;stdlib.h&gt;</span>: contains function prototypes for conversion between numbers and texts (e.g., <code>atoi()</code>, <code>atof()</code>, <code>strtod()</code>)<code></code>; memory allocation (<code>malloc()</code>, <code>free()</code>); random number generator (<code>rand()</code>, <code>srand()</code>); system utilities (<code>exit()</code>, <code>abort()</code>).</li>

<li><span class="line-heading-code-new">&lt;math.h&gt;</span>: contains function prototypes for mathematical functions (e.g., <code>pow()</code>, <code>sqrt()</code>).<code></code></li>

<li><span class="line-heading-code-new">&lt;ctype.h&gt;</span>: (character type) contains function prototypes for testing character <code></code>properties (<code>isupper()</code>, <code>isalpha()</code>, <code>isspace()</code>) and case conversion (<code>toupper()</code>, <code>tolower()</code>).</li>

<li><span class="line-heading-code-new">&lt;limits.h&gt;, &lt;float.h&gt;</span>: contains integer and float size and limits.<code></code></li>

<li><span class="line-heading-code-new">&lt;string.h&gt;</span>: contains function prototypes for string processing functions (e.g., <code>strcpy()</code>, <code>strcat()</code>, <code>strcmp()</code>).</li>

<li><span class="line-heading-code-new">&lt;time.h&gt;</span>: contains function prototypes for date and time functions (e.g., <code>time()</code>).</li>

<li><span class="line-heading-code-new">&lt;assert.h&gt;</span>: for assertion (to aid in diagnostics).</li>

<li><span class="line-heading-code-new">&lt;errno.h&gt;</span>: for error reporting.</li>
<li><span class="line-heading-code-new">&lt;signal.h&gt;</span>: for raising and handling signals.</li>

<li><span class="line-heading-code-new">&lt;stdarg.h&gt;</span>: for handling variable argument.</li>

<li><span class="line-heading-code-new">&lt;stddef.h&gt;</span>: contains common type definition such as <code>size_t</code>.</li>

<li><span class="line-heading-code-new">&lt;locale.h&gt;</span>:</li>

<li><span class="line-heading-code-new">&lt;setjmp.h&gt;</span>:</li>
</ul>

<h4>Keywords</h4>
<p>ISO C90 (ANSI C 89) has 32 keywords:</p>
<ul>
<li>Type: <code>int</code>, <code>double</code>, <code>long</code>, <code>char</code>, <code>float</code>, <code>short</code>, <code>unsigned</code>, <code>signed</code>, <code>typedef</code>, <code>sizeof</code> (10).</li>
<li>Control: <code>if</code>, <code>else</code>, <code>switch</code>, <code>case</code>, <code>break</code>, <code>default</code>, <code>for</code>, <code>do</code>, <code>while</code>, <code>continue</code>, <code>goto</code> (11).</li>
<li>Function: <code>return</code>, <code>void</code> (2)</li>
<li>Data Structure: <code>struct</code>, <code>enum</code>, <code>union</code> (3)</li>
<li>Memory: <code>auto<span class="color-comment"></span></code>, <code>register</code>, <code>extern</code>, <code>const</code>, <code>volatile</code>, <code>static</code> (6).</li>
</ul>

<p>ISO C99 adds 5 keywords, total of 37:</p>
<ul>
<li><code>_Bool</code>, <code>_Complex</code>, <code>_Imaginary</code>, <code>inline</code>, <code>restrict</code> (5).</li>
</ul>

<p>ISO C11 adds 7 more keywords, total of 44:</p>

<ul>
<li><code>_Alignas</code>, <code>_Alignof</code>, <code>_Atomic</code>, <code>_Generic</code>, <code>_Noreturn</code>, <code>_Static_assert</code>, <code>_Thread_local</code> (7).</li>
</ul>

<br />

<a class="references" href="../howto/References.html#cpp">Link to &quot;C References and Resources&quot;</a>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: Cygwin/MInGW GCC g++ 4.6.2<br />
Last modified: June, 2013</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
