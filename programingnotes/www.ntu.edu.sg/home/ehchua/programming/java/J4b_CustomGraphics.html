<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Custom Graphics Programming - Java Programming Tutorial</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Custom Graphics</h2>
</div>

<div id="content-main">


<p>This chapter shows you how you can paint your own custom drawing (such as  graphs, charts, drawings and, in particular, computer game avatars) because you cannot find  standard GUI components that meets your requirements.  I shall stress that you should try to reuse the standard GUI components as far as possible and leave custom graphics as the last resort.  Nonetheless, custom graphics is crucial in game programming.</p>

<p>Read &quot;Swing Tutorial&quot; trail &quot;<a href="http://java.sun.com/docs/books/tutorial/uiswing/painting/index.html">Performing Custom Painting</a>&quot;.</p>

<h3>The <span class="font-code">java.awt.Graphics</span> Class: Graphics Context and Custom Painting</h3>

<p>A <em>graphics context</em> provides the capabilities of drawing on the screen. The graphics context maintains states such as the color and font used in drawing, as well as interacting with the underlying operating system to perform the drawing. In Java, custom painting is done via the <code>java.awt.Graphics</code> class, which manages a graphics context, and provides a set of <em>device-independent</em> methods for drawing texts, figures and images on the screen on different platforms.</p>
<p>The <code>java.awt.Graphics</code> is an <code>abstract</code> class, as the actual act of drawing is system-dependent and device-dependent. Each operating platform will provide a subclass of <code>Graphics</code> to perform the actual drawing under the platform, but conform to the specification defined in <code>Graphics</code>.</p>

<img class="image-center" src="images/AWT_GraphicsClassDiagram.png" alt="AWT_GraphicsClassDiagram.png" />

<h4><span class="font-code">Graphics</span> Class' Drawing Methods</h4>

<p>The <code>Graphics</code> class provides methods for drawing three types of graphical objects:</p>
<ol>
<li>Text strings: via the <code>drawString()</code> method. Take note that <code>System.out.println()</code> prints to the <em>system console</em>, not to the graphics screen.</li>
<li>Vector-graphic primitives and shapes: via methods <code>drawXxx()</code> and <code>fillXxx()</code>, where <code>Xxx</code> could be  <code>Line</code>, <code>Rect</code>, <code>Oval</code>, <code>Arc</code>, <code>PolyLine</code>, <code>RoundRect</code>, or <code>3DRect</code>. </li>
<li>Bitmap images: via the <code>drawImage()</code> method.</li>
</ol>

<pre class="color-example">
<span class="color-comment">// Drawing (or printing) texts on the graphics screen:</span>
drawString(String <em>str</em>, int <em>xBaselineLeft</em>, int <em>yBaselineLeft</em>);
&nbsp;
<span class="color-comment">// Drawing lines:</span>
drawLine(int <em>x1</em>, int <em>y1</em>, int <em>x2</em>, int <em>y2</em>);
drawPolyline(int[] <em>xPoints</em>, int[] <em>yPoints</em>, int <em>numPoint</em>);
&nbsp;
<span class="color-comment">// Drawing primitive shapes:</span>
drawRect(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>);
drawOval(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>);
drawArc(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>arcAngle</em>);
draw3DRect(int <em>xTopLeft</em>, int, <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, boolean <em>raised</em>);
drawRoundRect(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, int <em>arcWidth</em>, int <em>arcHeight</em>)
drawPolygon(int[] <em>xPoints</em>, int[] <em>yPoints</em>, int <em>numPoint</em>);
&nbsp;
<span class="color-comment">// Filling primitive shapes:</span>
fillRect(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>);
fillOval(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>);
fillArc(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, int <em>startAngle</em>, int <em>arcAngle</em>);
fill3DRect(int <em>xTopLeft</em>, int, <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, boolean <em>raised</em>);
fillRoundRect(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, int <em>arcWidth</em>, int <em>arcHeight</em>)
fillPolygon(int[] <em>xPoints</em>, int[] <em>yPoints</em>, int <em>numPoint</em>);
&nbsp;
<span class="color-comment">// Drawing (or Displaying) images:</span>
drawImage(Image <em>img</em>, int <em>xTopLeft</em>, int <em>yTopLeft</em>, ImageObserver <em>obs</em>);  <span class="color-comment">// draw image with its size</span>
drawImage(Image <em>img</em>, int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>, ImageObserver <em>o</em>);  <span class="color-comment">// resize image on screen</span>
</pre>

<p>These drawing methods is illustrated below. The <code>drawXxx()</code> methods draw the outlines; while <code>fillXxx()</code> methods fill the internal. Shapes with negative <code><em>width</em></code> and <code><em>height</em></code> will not be painted. The <code>drawImage()</code> will be discussed later.</p>

<img class="image-center" src="images/Graphics_drawXxx.png" alt="Graphics_drawXxx.png" />

<h4><span class="font-code">Graphics</span> Class' Methods for Maintaining the Graphics Context</h4>
<p>The graphic context maintains <em>states</em> (or <em>attributes</em>) such as the current painting color, the current font for drawing text strings, and the current painting rectangular area (called <em>clip</em>). You can use the methods <code>getColor()</code>, <code>setColor()</code>, <code>getFont()</code>, <code>setFont()</code>, <code>getClipBounds()</code>, <code>setClip()</code> to get or set the color, font, and clip area. Any painting outside the clip area is ignored.</p>

<pre class="color-syntax">
<span class="color-comment">// Graphics context's current color.</span>
void setColor(Color <em>c</em>)
Color getColor()
 
<span class="color-comment">// Graphics context's current font.</span>
void setFont(Font <em>f</em>)
Font getFont()

<span class="color-comment">// Set/Get the current clip area. Clip area shall be rectangular and no rendering is performed outside the clip area.</span>
void setClip(int <em>xTopLeft</em>, int <em>yTopLeft</em>, int <em>width</em>, int <em>height</em>)
void setClip(Shape <em>rect</em>)
public abstract void clipRect(int x, int y, int width, int height) <span class="color-comment">// intersects the current clip with the given rectangle</span>
Rectangle getClipBounds()  <span class="color-comment">// returns an Rectangle</span>
Shape getClip()            <span class="color-comment">// returns an object (typically Rectangle) implements Shape</span></pre>

<h4><span class="font-code">Graphics</span> Class' Other Methods</h4>

<pre class="color-syntax">
void clearRect(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)
   <span class="color-comment">// Clear the rectangular area to background</span>
void copyArea(int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, int <em>dx</em>, int <em>dy</em>)
   <span class="color-comment">// Copy the rectangular area to offset (dx, dy).</span>
void translate(int <em>x</em>, int <em>y</em>)
   <span class="color-comment">// Translate the origin of the graphics context to (x, y). Subsequent drawing uses the new origin.</span>
FontMetrics getFontMetrics()
FontMetrics getFontMetrics(Font <em>f</em>)
   <span class="color-comment">// Get the FontMetrics of the current font / the specified font</span></pre>

<h4>Graphics Coordinate System</h4>

<img class="image-float-right" src="images/Graphics_Coordinates.png" alt="Graphics_Coordinates.png" />

<p>In Java Windowing Subsystem (like most of the 2D Graphics systems), the origin <code>(0,0)</code> is located at the top-left corner.</p>
<p>EACH component/container has its own coordinate system, ranging for <code>(0,0)</code> to <code>(width-1, height-1)</code> as illustrated.</p>
<p>You can use method <code>getWidth()</code> and <code>getHeight()</code> to retrieve the width and height of a component/container. You can use <code>getX()</code> or <code>getY()</code> to get the top-left corner <code>(x,y)</code> of this component's origin relative to its parent.</p>

<h3>Custom Painting Template</h3>
<p>Under Swing, custom painting is usually performed by extending (i.e., subclassing) a <code>JPanel</code> as the drawing canvas and override the <code>paintComponent(Graphics g)</code> method to perform your own drawing with the drawing methods provided by the <code>Graphics</code> class. The Java Windowing Subsystem invokes (calls back) <code>paintComponent(g)</code> to render the <code>JPanel</code> by providing the current graphics context <code>g</code>, which can be used to invoke the drawing methods. The extended <code>JPanel</code> is often programmed as an inner class of a <code>JFrame</code> application to facilitate access of private variables/methods. Although we typically draw on the <code>JPanel</code>, you can in fact draw on any <code>JComponent</code> (such as <code>JLabel</code>, <code>JButton</code>).</p>

<p> The custom painting code template is as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing's components and containers</span>
 
<span class="color-comment">/** Custom Drawing Code Template */</span>
<span class="color-comment">// A Swing application extends javax.swing.JFrame</span>
public class CGTemplate extends JFrame {
  <span class="color-comment"> // Define constants</span>
   public static final int CANVAS_WIDTH  = 640;
   public static final int CANVAS_HEIGHT = 480;
 
  <span class="color-comment"> // Declare an instance of the drawing canvas,
   // which is an inner class called DrawCanvas extending javax.swing.JPanel.</span>
   private DrawCanvas canvas;
 
   <span class="color-comment">// Constructor to set up the GUI components and event handlers</span>
   public CGTemplate() {
      canvas = new DrawCanvas();   <span class="color-comment"> // Construct the drawing canvas</span>
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
 
     <span class="color-comment"> // Set the Drawing JPanel as the JFrame's content-pane</span>
      Container cp = getContentPane();
      cp.add(canvas);
     <span class="color-comment"> // or &quot;setContentPane(canvas);&quot;</span>
 
      setDefaultCloseOperation(EXIT_ON_CLOSE);  <span class="color-comment"> // Handle the CLOSE button</span>
      pack();             <span class="color-comment"> // Either pack() the components; or setSize()</span>
      setTitle(&quot;......&quot;); <span class="color-comment"> // &quot;super&quot; JFrame sets the title</span>
      setVisible(true);   <span class="color-comment"> // &quot;super&quot; JFrame show</span>
   }
 
   <span class="color-comment">/**
    * Define inner class DrawCanvas, which is a JPanel used for custom drawing.
    */</span>
   <span class="color-new">private class DrawCanvas extends JPanel {
     <span class="color-comment"> // Override paintComponent to perform your own painting</span>
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);    <span class="color-comment"> // paint parent's background</span>
         setBackground(Color.BLACK); <span class="color-comment"> // set background color for this JPanel</span>
 
        <span class="color-comment"> // Your custom painting codes. For example,</span>
        <span class="color-comment"> // Drawing primitive shapes</span>
         g.setColor(Color.YELLOW);   <span class="color-comment"> // set the drawing color</span>
         g.drawLine(30, 40, 100, 200);
         g.drawOval(150, 180, 10, 10);
         g.drawRect(200, 210, 20, 30);
         g.setColor(Color.RED);      <span class="color-comment"> // change the drawing color</span>
         g.fillOval(300, 310, 30, 50);
         g.fillRect(400, 350, 60, 50);
        <span class="color-comment"> // Printing texts</span>
         g.setColor(Color.WHITE);
         g.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));
         g.drawString(&quot;Testing custom drawing ...&quot;, 10, 20);
      }
   }</span>
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
     <span class="color-comment"> // Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new CGTemplate();<span class="color-comment"> // Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<h5>Dissecting the Program</h5>
<ul>
  <li>Custom painting is performed by extending a <code>JPanel</code> (called <code>DrawCanvas</code>) and overrides the <code>paintComponent(Graphics g)</code> method to do your own drawing with the drawing methods provided by the <code>Graphics</code> class.</li>
<li><code>DrawCanvas</code> is designed as an inner class of this <code>JFrame</code> application, so as to facilitate access of the private variables/methods.</li>
<li>Java Windowing Subsystem invokes (calls back) <code>paintComponent(g)</code> to render the <code>JPanel</code>,  with the current graphics context in <code>g</code>, whenever there is a need to refresh the display (e.g., during the initial launch, restore, resize, etc).  You can use the drawing methods (<code>g.drawXxx()</code> and <code>g.fillXxx()</code>) on the current graphics context <code>g</code> to perform custom painting on the <code>JPanel</code>.</li>
<li>The size of the <code>JPanel</code> is set via the <code>setPreferredSize()</code>. The <code>JFrame</code> does not set its size, but packs the components contained via <code>pack()</code>.</li>
<li>In the <code>main()</code>, the constructor is called in the event-dispatch thread via static method <code>javax.swing.SwingUtilities.invokeLater()</code> (instead of running in the main thread), to ensure thread-safety and avoid deadlock, as recommended by the Swing developers.</li>
</ul>

<h5>(Advanced) Anonymous Inner Class for Drawing Canvas</h5>
<p>Instead of a named-inner class called <code>DrawCanvas</code> in the previous example, you can also use an anonymous inner class for the drawing canvas, if the painting code is short. For example,</p>

<pre class="color-example">
<span class="color-comment">// Create an anonymous inner class extends JPanel
// Construct an instance called canvas</span>
JPanel canvas = new JPanel() {
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);  <span class="color-comment">// paint parent's background</span><br />      ......
   } 
};
......</pre>

<h5>(Advanced) Getting the Graphics Context</h5>
<p>You can retrieve the <code>Graphics</code> context of a <code>JComponent</code> via the <code>getGraphics()</code> method. This is, however, not commonly used. For example,</p>
<pre class="color-example">
JPanel panel = new JPanel();
Graphics graphics = panel.getGraphics();</pre>

<h5>Custom Painting in AWT (Obsolete)</h5>
<p>Under AWT, you can perform custom painting by extending <code>java.awt.Canvas</code>, and override the <code>paint(Graphics g)</code> method, in a <code>java.awt.Frame</code> application.  Similarly, you can explicitly invoke <code>repaint()</code> to update the graphics.</p>



<h4>Refreshing the Display via <span class="font-code">repaint()</span></h4>

<p>At times, we need to <em>explicitly refresh the display</em> (e.g., in game and animation). We shall NOT invoke <code>paintComponent(Graphics)</code> directly. Instead, we invoke the <code>JComponent</code>'s <code>repaint()</code> method. The Windowing Subsystem will in turn call back the <code>paintComponent()</code> with the current <code>Graphics</code> context and execute it in the event-dispatching thread for thread safety.  You can <code>repaint()</code> a particular <code>JComponent</code> (such as a <code>JPanel</code>) or the entire <code>JFrame</code>. The children contained within the <code>JComponent</code> will also be repainted.</p>




<h3>Colors and Fonts</h3>
<h4><span class="font-code">java.awt.Color</span></h4>

<img class="image-float-right" src="images/Graphics_StandardColors.png" alt="Graphics_StandardColors.png" />

<p>The class <code>java.awt.Color</code> provides  13 standard colors as named-constants.  They are: <code>Color.RED</code>, <code>GREEN</code>, <code>BLUE</code>, <code></code><code></code><code></code><code>MAGENTA</code>, <code>CYAN</code>,  <code>YELLOW</code>, <code></code><code>BLACK</code>, <code>WHITE</code>, <code>GRAY</code>, <code>DARK_GRAY</code>, <code>LIGHT_GRAY</code>, <code>ORANGE</code>, and <code>PINK</code>.  (In JDK 1.1, these constant names are in lowercase, e.g., red. This violates the Java naming convention for constants.  In JDK 1.2, the uppercase names are added. The lowercase names were not removed for backward compatibility.)</p>

<p>You can use the <code>toString()</code> to print the RGB values of these color (e.g., <code>System.out.println(Color.RED)</code>):</p>

<pre class="output">
RED       : java.awt.Color[r=255, g=0,   b=0]
GREEN     : java.awt.Color[r=0,   g=255, b=0]
BLUE      : java.awt.Color[r=0,   g=0,   b=255]
YELLOW    : java.awt.Color[r=255, g=255, b=0]
MAGENTA   : java.awt.Color[r=255, g=0,   b=255]
CYAN      : java.awt.Color[r=0,   g=255, b=255]
WHITE     : java.awt.Color[r=255, g=255, b=255]
BLACK     : java.awt.Color[r=0,   g=0,   b=0]
GRAY      : java.awt.Color[r=128, g=128, b=128]
LIGHT_GRAY: java.awt.Color[r=192, g=192, b=192]
DARK_GRAY : java.awt.Color[r=64,  g=64,  b=64]
PINK      : java.awt.Color[r=255, g=175, b=175]
ORANGE    : java.awt.Color[r=255, g=200, b=0]</pre>

<p>You can also use the RGB values or RGBA value (A for alpha to specify transparency/opaque) to construct your own color via constructors:</p>

<pre class="color-syntax">
Color(int <em>r</em>, int <em>g</em>, int <em>b</em>);             <span class="color-comment">// between 0 and 255</span>
Color(float <em>r</em>, float <em>g</em>, float <em>b</em>);       <span class="color-comment">// between 0.0f and 1.0f</span>
Color(int <em>r</em>, int <em>g</em>, int <em>b</em>, int <em>alpha</em>);         <span class="color-comment">// between 0 and 255</span>
Color(float <em>r</em>, float <em>g</em>, float <em>b</em>, float <em>alpha</em>); <span class="color-comment">// between 0.0f and 1.0f</span>
   <span class="color-comment">// <em>alpha</em> of 0 for totally transparent, 255 (or 1.0f) for totally opaque
   // The default <em>alpha</em> is 255 (or 1.0f) for totally opaque</span></pre>
   
<p>For example:</p>
<pre class="color-example">
Color myColor1 = new Color(123, 111, 222);
Color myColor2 = new Color(0.5f, 0.3f, 0.1f);
Color myColor3 = new Color(0.5f, 0.3f, 0.1f, 0.5f);  <span class="color-comment">// semi-transparent</span></pre>

<p>To retrieve the individual components, you can use <code>getRed()</code>, <code>getGreen()</code>, <code>getBlue()</code>, <code>getAlpha()</code>, etc.</p>

<p>To set the background and foreground (text) color of a component/container<code></code>, you can invoke:</p>

<pre class="color-example">
JLabel label = new JLabel(&quot;Test&quot;);
label.setBackground(Color.LIGHT_GRAY);
label.setForeground(Color.RED);</pre>

<p>To set the color of the <code>Graphics</code> context <code>g</code> (for drawing lines, shapes, and texts), use <code>g.setColor(<em>color</em>)</code>:</p>
<pre class="color-example">
g.setColor(Color.RED);
g.drawLine(10, 20, 30, 40);   <span class="color-comment">// in Color.RED</span>
Color myColor = new Color(123, 111, 222);
g.setColor(myColor);
g.drawRect(10, 10, 40, 50);   <span class="color-comment">// in myColor</span>
</pre>

<h4>(Advanced) <span class="font-code">JColorChooser</span> Example</h4>

<img class="image-float-right" src="images/Graphics_JColorChooser.png" alt="Graphics_JColorChooser.png" />

<p>This example uses the <code>javax.swing.JColorChooser</code> to set the background color of the <code>JPanel</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre>
</td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT's event classes and listener interfaces</span>
import javax.swing.*;     <span class="color-comment">// Using Swing's components and containers</span>
 
<span class="color-comment">/**
 * An example of using ColorChooser to set the background 
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JColorChooserDemo extends JFrame {
   JPanel panel;
   Color bgColor = Color.LIGHT_GRAY;  <span class="color-comment">// Panel's background color</span>
 
   <span class="color-comment">// Constructor to setup the UI components and event handlers</span>
   public JColorChooserDemo() {
      panel = new JPanel(new BorderLayout());
 
      JButton btnColor = new JButton(&quot;Change Color&quot;);
      panel.add(btnColor, BorderLayout.SOUTH);
      btnColor.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            Color color = JColorChooser.showDialog(JColorChooserDemo.this,
                  &quot;Choose a color&quot;, bgColor);
            if (color != null) { <span class="color-comment">// new color selected</span>
               bgColor = color;
            }
            panel.setBackground(bgColor); <span class="color-comment">// change panel's background color</span>
         }
      });
 
      setContentPane(panel);
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setTitle(&quot;JColorChooser Demo&quot;);
      setSize(300, 200);
      setLocationRelativeTo(null);  <span class="color-comment">// center the application window</span>
      setVisible(true);             <span class="color-comment">// show it</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new JColorChooserDemo();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<h4><span class="font-code">java.awt.Font</span></h4>
<p>The class <code>java.awt.Font</code> represents a specific font face, which can be used for rendering texts.  You can use the following constructor to construct a <code>Font</code> instance:</p>
<pre class="color-example">
public Font(String <em>name</em>, int <em>style</em>, int <em>size</em>);
<span class="color-comment">// <em>name</em>:  Family name &quot;Dialog&quot;, &quot;DialogInput&quot;, &quot;Monospaced&quot;, &quot;Serif&quot;, or &quot;SansSerif&quot; or
//        Physical font found in this GraphicsEnvironment.
//        You can also use String constants Font.DIALOG, Font.DIALOG_INPUT, Font.MONOSPACED, 
//          Font.SERIF, Font.SANS_SERIF (JDK 1.6)
// <em>style</em>: Font.PLAIN, Font.BOLD, Font.ITALIC or Font.BOLD|Font.ITALIC (Bit-OR)
// <em>size</em>:  the point size of the font (in pt) (1 inch has 72 pt).</span>
</pre>

<p>You can use the <code>setFont()</code> method to set the current font for the <code>Graphics</code> context <code>g</code> for rendering texts.  For example,</p>
<pre class="color-example">
Font myFont1 = new Font(Font.MONOSPACED, Font.PLAIN, 12);
Font myFont2 = new Font(Font.SERIF, Font.BOLD | Font.ITALIC, 16);  <span class="color-comment">// bold and italics</span>
JButton btn = new JButton(&quot;RESET&quot;);
btn.setFont(myFont1);
JLabel lbl = new JLabel(&quot;Hello&quot;);
lbl.setFont(myFont2);
......
g.drawString(&quot;In default Font&quot;, 10, 20);     <span class="color-comment">// in default font</span>
Font myFont3 = new Font(Font.SANS_SERIF, Font.ITALIC, 12);
g.setFont(myFont3);
g.drawString(&quot;Using the font set&quot;, 10, 50);  <span class="color-comment">// in myFont3</span>
</pre>

<h5>Font's Family Name vs. Font Name</h5>
<p>A font could have many <em>faces</em> (or <em>style</em>), e.g., plain, bold or italic. All these faces have similar typographic design. The <em>font face name</em>, or <em>font name</em> for short, is the name of a particular font face, like &quot;Arial&quot;, &quot;Arial Bold&quot;, &quot;Arial Italic&quot;, &quot;Arial Bold Italic&quot;. The <em>font family name</em> is the name of the font family that determines the typographic design across several faces, like &quot;Arial&quot;. For example,</p>

<pre class="color-example">
java.awt.Font[family=Arial,name=Arial,style=plain,size=1]
java.awt.Font[family=Arial,name=Arial Bold,style=plain,size=1]
java.awt.Font[family=Arial,name=Arial Bold Italic,style=plain,size=1]
java.awt.Font[family=Arial,name=Arial Italic,style=plain,size=1]</pre>

<h5>Logical Font vs. Physical Font</h5>
<p>JDK supports these <em>logical font family</em> names: &quot;<code>Dialog</code>&quot;, &quot;<code>DialogInput</code>&quot;, &quot;<code>Monospaced</code>&quot;, &quot;<code>Serif</code>&quot;, or &quot;<code>SansSerif</code>&quot;. JDK 1.6 provides these <code>String</code> constants: <code>Font.DIALOG</code>, <code>Font.DIALOG_INPUT</code>, <code>Font.MONOSPACED</code>, <code>Font.SERIF</code>, <code>Font.SANS_SERIF</code>.</p>
<p>Physical font names are actual font libraries such as &quot;Arial&quot;, &quot;Times New Roman&quot; in the system.</p>


<h5><span class="font-code">GraphicsEnvironment</span>'s <span class="font-code">getAvailableFontFamilyNames()</span> and <span class="font-code">getAllFonts()</span></h5>

<p>You can use <code>GraphicsEnvironment</code>'s <code>getAvailableFontFamilyNames()</code> to list all the font famiy names; and <code>getAllFonts()</code> to construct all <code>Font</code> instances (with font size of 1 pt). For example,</p>

<pre class="color-example">
GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
      
<span class="color-comment">// Get all font family name in a String[]</span>
String[] fontNames = env.getAvailableFontFamilyNames();
for (String fontName : fontNames) {
   System.out.println(fontName);
}
      
<span class="color-comment">// Construct all Font instance (with font size of 1)</span>
Font[] fonts = env.getAllFonts();
for (Font font : fonts) {
   System.out.println(font);
}</pre>

<h5><span class="font-code">Font</span>'s <span class="font-code">deriveFont()</span></h5>
<p>You can use <code>Font</code>'s <code>deriveFont()</code> to derive a new <code>Font</code> instance from this <code>Font</code> with varying size, style and others.</p>

<pre class="color-syntax">
public Font deriveFont(float size)
public Font deriveFont(int style)
public Font deriveFont(AffineTransform trans)
public Font deriveFont(int style, float size)
public Font deriveFont(int style, AffineTransform trans)</pre>

<p>For example,</p>
<pre class="color-example">
Font font = new Font(Font.MONOSPACED, Font.BOLD, 12);
System.out.println(font);
   <span class="color-comment">// java.awt.Font[family=Monospaced,name=Monospaced,style=bold,size=12]</span>
Font fontDerived = font.deriveFont(20); 
System.out.println(fontDerived);
   <span class="color-comment">// java.awt.Font[family=Monospaced,name=Monospaced,style=plain,size=12]</span></pre>

<h4>(Advanced) <span class="font-code">java.awt.FontMetrics</span></h4>
<p>The <code>java.awt.FontMetrics</code> class can be used to measure the exact width and height of the string for a particular font face, so that you can position the string as you desire (such as at the center of the screen).</p>

<p>To create a <code>FontMetrics</code>, use <code>getFontMetrics()</code> methods of the <code>Graphics</code> class, as follows:</p>
<pre class="color-syntax">
<span class="color-comment">// In java.awt.Graphics</span>
public abstract FontMetrics getFontMetrics(Font f)
   <span class="color-comment">// Get the FontMetrics of the specified font</span>
public abstract FontMetrics getFontMetrics()
   <span class="color-comment">// Get the FontMetrics of the current font</span>
</pre>

<img class="image-center" src="images/Graphics_FontMetrics.png" alt="Graphics_FontMetrics.png" />

<pre class="color-syntax">
<span class="color-comment">// in java.awt.FontMetrics</span>
public int getHeight()
public int getLeading()
public int getAscent()
public int getDescent()</pre>

<p>The most commonly-used function for <code>FontMetrics</code> is to measure the width of a given <code>String</code> displayed in a certain font.</p>

<pre class="color-syntax">
public int stringWidth(String str)
   <span class="color-comment">// Returns the total width for showing the specified String in this Font.</span></pre>

<p>To centralize a string on the drawing canvas (e.g., JPanel):</p>
<pre class="color-example">
public void paintComponent(Graphics g) {
   super.paintComponent(g);
   g.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 30));
   <span class="color-comment">// Get font metrics for the current font</span>
   FontMetrics fm = g.getFontMetrics();
   <span class="color-comment">// Centralize the string</span>
   String msg = &quot;Hello, world!&quot;;
   int msgWidth = fm.stringWidth(msg);
   int msgAscent = fm.getAscent();
   <span class="color-comment">// Get the position of the leftmost character in the baseline</span>
   <span class="color-comment">// getWidth() and getHeight() returns the width and height of this component</span>
   int msgX = getWidth() / 2 - msgWidth / 2;
   int msgY = getHeight() / 2 + msgAscent / 2;
   g.drawString(msg, msgX, msgY);
}</pre>


<h3>Custom Graphics Examples</h3>
<h4 id="moveALine">Example 1: Moving an Object via Key/Button Action</h4>

<img class="image-float-right" src="images/Graphics_MoveALine.png" alt="Graphics_MoveALine.png" />

<p>This example illustrates how to re-paint the screen in response to a <code>KeyEvent</code> or <code>ActionEvent</code>.</p>

<p>The display consists of two <code>JPanel</code> in a <code>JFrame</code>, arranged in <code>BorderLayout</code>. The top panel is used for custom painting;  the bottom panel holds two <code>JButton</code> arranged in <code>FlowLayout</code>. Clicking the &quot;Move Right&quot; or &quot;Move Left&quot; buttons moves the line. The <code>JFrame</code> listens to the &quot;Left-arrow&quot; and &quot;Right-arrow&quot; keys, and responses by moving the line left or right.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.awt.event.*; <span class="color-comment">// Using AWT's event classes and listener interface</span>
import javax.swing.*;    <span class="color-comment">// Using Swing's components and containers</span>
<span class="color-comment">/**
 * Custom Graphics Example: Using key/button to move a line left or right.
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class CGMoveALine extends JFrame {
   <span class="color-comment">// Define constants for the various dimensions</span>
   public static final int CANVAS_WIDTH = 400;
   public static final int CANVAS_HEIGHT = 140;
   public static final Color LINE_COLOR = Color.BLACK;
   public static final Color CANVAS_BACKGROUND = Color.CYAN;
 
   <span class="color-comment">// The moving line from (x1, y1) to (x2, y2), initially position at the center</span>
   private int x1 = CANVAS_WIDTH / 2;
   private int y1 = CANVAS_HEIGHT / 8;
   private int x2 = x1;
   private int y2 = CANVAS_HEIGHT / 8 * 7;
 
   private DrawCanvas canvas; <span class="color-comment">// The custom drawing canvas (an innder class extends JPanel)</span>
 
   <span class="color-comment">// Constructor to set up the GUI components and event handlers</span>
   public CGMoveALine() {
      <span class="color-comment">// Set up a panel for the buttons</span>
      JPanel btnPanel = new JPanel(new FlowLayout());
      JButton btnLeft = new JButton(&quot;Move Left &quot;);
      btnPanel.add(btnLeft);
      btnLeft.addActionListener(new ActionListener() {
         public void actionPerformed(ActionEvent evt) {
            x1 -= 10;
            x2 -= 10;
            canvas.repaint();
            requestFocus(); <span class="color-comment">// change the focus to JFrame to receive KeyEvent</span>
         }
      });
      JButton btnRight = new JButton(&quot;Move Right&quot;);
      btnPanel.add(btnRight);
      btnRight.addActionListener(new ActionListener() {
         public void actionPerformed(ActionEvent evt) {
            x1 += 10;
            x2 += 10;
            canvas.repaint();
            requestFocus(); <span class="color-comment">// change the focus to JFrame to receive KeyEvent</span>
         }
      });
 
      <span class="color-comment">// Set up a custom drawing JPanel</span>
      canvas = new DrawCanvas();
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
 
      <span class="color-comment">// Add both panels to this JFrame's content-pane</span>
      Container cp = getContentPane();
      cp.setLayout(new BorderLayout());
      cp.add(canvas, BorderLayout.CENTER);
      cp.add(btnPanel, BorderLayout.SOUTH);
 
      <span class="color-comment">// &quot;super&quot; JFrame fires KeyEvent</span>
      addKeyListener(new KeyAdapter() {
         @Override
         public void keyPressed(KeyEvent evt) {
            switch(evt.getKeyCode()) {
               case KeyEvent.VK_LEFT:
                  x1 -= 10;
                  x2 -= 10;
                  repaint();
                  break;
               case KeyEvent.VK_RIGHT:
                  x1 += 10;
                  x2 += 10;
                  repaint();
                  break;
            }
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); <span class="color-comment">// Handle the CLOSE button</span>
      setTitle(&quot;Move a Line&quot;);
      pack();           <span class="color-comment">// pack all the components in the JFrame</span>
      setVisible(true); <span class="color-comment">// show it</span>
      requestFocus();   <span class="color-comment">// set the focus to JFrame to receive KeyEvent</span>
   }
 
   <span class="color-comment">/**
    * Define inner class DrawCanvas, which is a JPanel used for custom drawing.
    */</span>
   class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);
         setBackground(CANVAS_BACKGROUND);
         g.setColor(LINE_COLOR);
         g.drawLine(x1, y1, x2, y2); <span class="color-comment">// Draw the line</span>
      }
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes on the Event-Dispatcher Thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new CGMoveALine(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>To do custom painting, you have to decide which superclass to use. It is recommended that you use a <code>JPanel</code> (or a more specialized Swing component such as <code>JButton</code> or <code>JLabel</code>). In this example, we extend the <code>JPanel</code> to do our custom painting, in an inner class, as follows:
  <pre class="color-example">
class DrawCanvas extends JPanel {
   @Override   
   public void paintComponent(Graphics g) {
      super.paintComponent(g);  <span class="color-comment">// paint background</span>
      setBackground(CANVAS_BACKGROUND);
      g.setColor(LINE_COLOR);
      g.drawLine(x1, y1, x2, y2);
   }
}</pre></li>

<li>The <code>paintComponent()</code> method is overridden to provide the custom drawing codes.  We use the <code>drawLine()</code> method to draw a line from <code>(x1,y1)</code> to <code>(x2, y2)</code>.</li>
<li>The <code>paintComponent()</code> method cannot be called directly from your code, because it requires a <code>Graphics</code> object as argument.</li>
<li><code>paintComponent()</code> is a so-called &quot;<em>call-back</em>&quot; method.  The Windowing subsystem invokes this method and provides a pre-configured <code>Graphics</code> object to represent its state (e.g., current color, font, clip area and etc).  There are two kinds of painting: system-triggered painting and application-triggered painting.  In a system-trigger painting, the system request a component to render its content when the component is first made visible on the screen, or the component is resized, or the component is damaged that needs to be repaint.  In an application-triggered painting, the application invokes a <code>repaint()</code> request.  Under both cases, the Windowing subsystem will <em>call-back</em> the <code>paintComponent()</code> to render the contents of the component with a proper <code>Graphics</code> object as argument.</li>
<li>In this example, the application requests for a <code>repaint()</code> in the <code>KeyEvent</code> and <code>MouseEvent</code> handlers, which triggers the <code>paintComponent()</code> with an appropriate <code>Graphics</code> object as the argument.</li>
<li>To be precise, when you invoke the <code>repaint()</code> method to repaint a <code>JComponent</code>, the Windowing subsystem <em>calls-back</em> <code>paint()</code> method.  The <code>paint()</code> method then <em>calls-back</em> three methods: <code>paintComponent()</code>, <code>paintBorder()</code> and <code>paintChilden()</code>.</li>
<li>In the overridden <code>paintComponent()</code> method, we call <code>super.paintComponent()</code> to paint the background of the <code>JComponent</code>.  If this call is omitted, you must either paint the background yourself (via a <code>fillRect()</code> call) or use <code>setOpaque(false)</code> to make the <code>JComponent</code> transparent.  This will inform Swing system to paint those <code>JComponents</code> behind the transparent component.</li>
<li>We choose the <code>JFrame</code> as the source of the <code>KeyEvent</code>. <code>JFrame</code> shall be &quot;<em>in focus</em>&quot; when the key is pressed. The <code>requestFocus()</code> method (of &quot;<code>this</code>&quot; <code>JFrame</code>) is invoked to request for the keyboard focus.</li>
</ul>
<p>[TODO]: may need to revise.</p>

<h5>Try</h5>
<img class="image-float-right" src="images/Graphics_MoveABall.png" alt="Graphics_MoveABall.png" />
<p>Modifying the program to move a ball in response to up/down/left/right buttons, as well as the 4 arrow and &quot;wasd&quot; keys , as shown:</p>

<h4 class="float-clear">Example 2: Moving Sprites</h4>

<p>In game programming, we have moving game objects called <em>sprites</em>. Each sprite is usually modeled in its own class, with its own properties, and it can paint itself.</p>

<h5><span class="font-code">Sprite.java</span></h5>

<p>This class models a sprite, with its own properties, and it can paint itself via the <code>paint()</code> method provided given a <code>Graphics</code> context. A rectangle is used here.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
import java.awt.*;   <span class="color-comment">// Using AWT's Graphics and Color</span>
<span class="color-comment">/**
 * The class Sprite models a moving game object, with its own operations
 *  and can paint itself.
 */</span>
public class Sprite {
   <span class="color-comment">// Variables (package access)</span>
   int x, y, width, height; <span class="color-comment">// Use an rectangle for illustration</span>
   Color color = Color.RED; <span class="color-comment">// Color of the object</span>
 
   <span class="color-comment">// Constructor</span>
   public Sprite(int x, int y, int width, int height, Color color) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.color = color;
   }
 
   <span class="color-comment">// Paint itself given the Graphics context</span>
   public void paint(Graphics g) {
      g.setColor(color);
      g.fillRect(x, y, width, height); <span class="color-comment">// Fill a rectangle</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5><span class="font-code">MoveASprite.java</span></h5>

<p>Instead of repainting the entire display, we only repaint the affected areas (clips), for efficiency, via the <code>repaint(x, y, width, height)</code> method. In <code>moveLeft()</code> and <code>moveRight()</code>, we save the states, move the object, repaint the saved clip-area with the background color, and repaint the new clip-area occupied by the sprite. Repainting is done by asking the sprite to paint itself at the new location, and erase from the old location.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.awt.event.*; <span class="color-comment">// Using AWT's event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing's components and containers</span>
<span class="color-comment">/**
 * Custom Graphics Example: Using key/button to move a object left or right.
 * The moving object (sprite) is defined in its own class, with its own
 * operations and can paint itself.
 */</span>
public class CGMoveASprite extends JFrame {
   <span class="color-comment">// Define constants for the various dimensions</span>
   public static final int CANVAS_WIDTH = 400;
   public static final int CANVAS_HEIGHT = 140;
   public static final Color CANVAS_BG_COLOR = Color.CYAN;
 
   private DrawCanvas canvas; <span class="color-comment">// the custom drawing canvas (an inner class extends JPanel)</span>
   private Sprite sprite;     <span class="color-comment">// the moving object</span>
 
   <span class="color-comment">// Constructor to set up the GUI components and event handlers</span>
   public CGMoveASprite() {
      <span class="color-comment">// Construct a sprite given x, y, width, height, color</span>
      sprite = new Sprite(CANVAS_WIDTH / 2 - 5, CANVAS_HEIGHT / 2 - 40,
            10, 80, Color.RED);
 
      <span class="color-comment">// Set up a panel for the buttons</span>
      JPanel btnPanel = new JPanel(new FlowLayout());
      JButton btnLeft = new JButton(&quot;Move Left &quot;);
      btnPanel.add(btnLeft);
      btnLeft.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            moveLeft();
            requestFocus(); <span class="color-comment">// change the focus to JFrame to receive KeyEvent</span>
         }
      });
      JButton btnRight = new JButton(&quot;Move Right&quot;);
      btnPanel.add(btnRight);
      btnRight.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            moveRight();
            requestFocus(); <span class="color-comment">// change the focus to JFrame to receive KeyEvent</span>
         }
      });
 
      <span class="color-comment">// Set up the custom drawing canvas (JPanel)</span>
      canvas = new DrawCanvas();
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
 
      <span class="color-comment">// Add both panels to this JFrame</span>
      Container cp = getContentPane();
      cp.setLayout(new BorderLayout());
      cp.add(canvas, BorderLayout.CENTER);
      cp.add(btnPanel, BorderLayout.SOUTH);
 
      <span class="color-comment">// &quot;super&quot; JFrame fires KeyEvent</span>
      addKeyListener(new KeyAdapter() {
         @Override
         public void keyPressed(KeyEvent evt) {
            switch(evt.getKeyCode()) {
               case KeyEvent.VK_LEFT:  moveLeft();  break;
               case KeyEvent.VK_RIGHT: moveRight(); break;
            }
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setTitle(&quot;Move a Sprite&quot;);
      pack();            <span class="color-comment">// pack all the components in the JFrame</span>
      setVisible(true);  <span class="color-comment">// show it</span>
      requestFocus();    <span class="color-comment">// &quot;super&quot; JFrame requests focus to receive KeyEvent</span>
   }
 
   <span class="color-comment">// Helper method to move the sprite left</span>
   private void moveLeft() {
      <span class="color-comment">// Save the current dimensions for repaint to erase the sprite</span>
      int savedX = sprite.x;
      <span class="color-comment">// update sprite</span>
      sprite.x -= 10;
      <span class="color-comment">// Repaint only the affected areas, not the entire JFrame, for efficiency</span>
      canvas.repaint(savedX, sprite.y, sprite.width, sprite.height); <span class="color-comment">// Clear old area to background</span>
      canvas.repaint(sprite.x, sprite.y, sprite.width, sprite.height); <span class="color-comment">// Paint new location</span>
   }
 
   <span class="color-comment">// Helper method to move the sprite right</span>
   private void moveRight() {
      <span class="color-comment">// Save the current dimensions for repaint to erase the sprite</span>
      int savedX = sprite.x;
      <span class="color-comment">// update sprite</span>
      sprite.x += 10;
      <span class="color-comment">// Repaint only the affected areas, not the entire JFrame, for efficiency</span>
      canvas.repaint(savedX, sprite.y, sprite.width, sprite.height); <span class="color-comment">// Clear old area to background</span>
      canvas.repaint(sprite.x, sprite.y, sprite.width, sprite.height); <span class="color-comment">// Paint at new location</span>
   }
 
   <span class="color-comment">// Define inner class DrawCanvas, which is a JPanel used for custom drawing</span>
   class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);
         setBackground(CANVAS_BG_COLOR);
         sprite.paint(g);  <span class="color-comment">// the sprite paints itself</span>
      }
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI construction on the Event-Dispatching Thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new CGMoveASprite(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4 id="mypaint" class="float-clear">Example 3: Paint</h4>

<img src="images/Graphics_MyPaint.gif" alt="Graphics_MyPaint.gif" />

<h5 class="font-code float-clear">MyPaint.java</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70</pre>
</td>
<td>
<pre>
import java.util.List;
import java.util.ArrayList;
import java.awt.*;       <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.awt.event.*; <span class="color-comment">// Using AWT's event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing's components and container</span>
 
<span class="color-comment">/**
 * Custom Graphics Example: Paint (similar to Windows' paint program)
 */</span>
public class MyPaint extends JFrame {
   <span class="color-comment">// Define constants for the various dimensions</span>
   public static final int CANVAS_WIDTH = 500;
   public static final int CANVAS_HEIGHT = 300;
   public static final Color LINE_COLOR = Color.RED;
 
   <span class="color-comment">// Lines drawn, consists of a List of PolyLine instances</span>
   private List&lt;PolyLine&gt; lines = new ArrayList&lt;PolyLine&gt;();
   private PolyLine currentLine;  <span class="color-comment">// the current line (for capturing)</span>
 
   <span class="color-comment">// Constructor to set up the GUI components and event handlers</span>
   public MyPaint() {
      DrawCanvas canvas = new DrawCanvas();
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
      canvas.addMouseListener(new MouseAdapter() {
         @Override
         public void mousePressed(MouseEvent evt) {
            <span class="color-comment">// Begin a new line</span>
            currentLine = new PolyLine();
            lines.add(currentLine);
            currentLine.addPoint(evt.getX(), evt.getY());
         }
      });
      canvas.addMouseMotionListener(new MouseMotionAdapter() {
         @Override
         public void mouseDragged(MouseEvent evt) {
            currentLine.addPoint(evt.getX(), evt.getY());
            repaint();  <span class="color-comment">// invoke paintComponent()</span>
         }
      });
 
      setContentPane(canvas);
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setTitle(&quot;Paint&quot;);
      pack();
      setVisible(true);
   }
 
   <span class="color-comment">// Define inner class DrawCanvas, which is a JPanel used for custom drawing</span>
   private class DrawCanvas extends JPanel {
      @Override
      protected void paintComponent(Graphics g) { <span class="color-comment">// called back via repaint()</span>
         super.paintComponent(g);
         g.setColor(LINE_COLOR);
         for (PolyLine line: lines) {
            line.draw(g);
         }
      }
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      SwingUtilities.invokeLater(new Runnable() {
         <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
         @Override
         public void run() {
            new MyPaint(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5 class="font-code">PolyLine.java</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre>
</td>
<td>
<pre>
import java.awt.Graphics;
import java.util.*;
<span class="color-comment">/*
 * The PolyLine class model a line made up of many points
 */</span>
public class PolyLine {
   private List&lt;Integer&gt; xList;  <span class="color-comment">// List of x-coord</span>
   private List&lt;Integer&gt; yList;  <span class="color-comment">// List of y-coord</span>
 
   <span class="color-comment">// Constructor</span>
   public PolyLine() {
      xList = new ArrayList&lt;Integer&gt;();
      yList = new ArrayList&lt;Integer&gt;();
   }
 
   <span class="color-comment">// Add a point to this PolyLine</span>
   public void addPoint(int x, int y) {
      xList.add(x);
      yList.add(y);
   }
 
   <span class="color-comment">// This PolyLine paints itself given the Graphics context</span>
   public void draw(Graphics g) { <span class="color-comment">// draw itself</span>
      for (int i = 0; i &lt; xList.size() - 1; ++i) {
         g.drawLine((int)xList.get(i), (int)yList.get(i), (int)xList.get(i + 1),
               (int)yList.get(i + 1));
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<p>[TODO]</p>

<h3 id="DrawImage">Drawing Images</h3>

<h4><span class="font-code">javax.swing.ImageIcon</span></h4>
<p>The <code>javax.swing.ImageIcon</code> class represents an icon, which is a fixed-size picture, typically small-size and used to decorate components. To create an <code>ImageIcon</code>:</p>

<pre class="color-example">
<span class="color-comment">// Prepare an ImageIcons to be used with JComponents or drawImage()</span>
String imgNoughtFilename = &quot;images/nought.gif&quot;;
ImageIcon iconNought = null;
URL imgURL = getClass().getClassLoader().getResource(imgNoughtFilename);
if (imgURL != null) {
   iconNought = new ImageIcon(imgURL);
} else {
   System.err.println(&quot;Couldn't find file: &quot; + imgNoughtFilename);
}</pre>


<h4><span class="font-code">Graphics</span> Class' <span class="font-code">drawImage()</span></h4>

<p><code>ImageIcon</code> is fixed-in-sized and cannot be resized in display. You can use <code>Graphics</code>'s <code>drawImage()</code> to resize a source image in display.</p>

<p>The <code>java.awt.Graphics</code> class declares 6 overloaded versions of <code>abstract</code> method <code>drawImage()</code>.</p>

<pre class="color-syntax">
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, Color <em>bgcolor</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, Color <em>bgcolor</em>, ImageObserver <em>observer</em>)
   <span class="color-comment">// The <em>img</em> is drawn with its top-left corner at (<em>x</em>, <em>y</em>) scaled to the specified <em>width</em> and <em>height</em>
   //  (default to the image's width and height).
   // The <em>bgColor</em> (background color) is used for &quot;transparent&quot; pixels.</span>

public abstract boolean drawImage(Image <em>img</em>, int <em>destX1</em>, int <em>destY1</em>, int <em>destX2</em>, int <em>destY2</em>,
      int <em>srcX1</em>, int <em>srcY1</em>, int <em>srcX2</em>, int <em>srcY2</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>destX1</em>, int <em>destY1</em>, int <em>destX2</em>, int <em>destY2</em>,
      int <em>srcX1</em>, int <em>srcY1</em>, int <em>srcX2</em>, int <em>srcY2</em>, Color <em>bgcolor</em>, ImageObserver <em>observer</em>)
   <span class="color-comment">// The <em>img</em> &quot;clip&quot; bounded by (<em>scrX1</em>, <em>scrY2</em>) and (<em>scrX2</em>, <em>srcY2</em>) is scaled and drawn from
   // (<em>destX1</em>, <em>destY1</em>) to (<em>destX2</em>, <em>destY2</em>) on the display.</span></pre>

<img class="image-center" src="images/Graphics_DrawImage.png" alt="Graphics_DrawImage.png" />

<p>The coordinates involved is shown in the above diagram. The <code>ImageObserver</code> receives notification about the <code>Image</code> as it is loaded. In most purposes, you can set it to <code>null</code> or <code>this</code>.</p>

<p>The <code>drawImage()</code> method requires an <code>Image</code> instance, which can be obtained via <code>ImageIcon</code>'s <code>getImage()</code> method; or via <code>static</code> method <code>ImageIO.read()</code> (read &quot;<a href="J8b_Game_2DGraphics.html#loadimage">Reading Images into your program</a>&quot;). For example,</p>

<pre class="color-example">
<span class="color-comment">// Prepare an ImageIcon</span>
ImageIcon icon = null;
String imgFilename = &quot;images/duke.gif&quot;;
java.net.URL imgURL = getClass().getClassLoader().getResource(imgFilename);
if (imgURL != null) {
   <span class="color-new">icon =  new ImageIcon(imgURL)</span>;
} else {
   System.err.println(&quot;Couldn't find file: &quot; + imgFilename);
}
 
<span class="color-comment">// Prepare an Image object to be used by drawImage()</span>
final <span class="color-new">Image img = icon.getImage()</span>;
<span class="color-comment">// Extend a JLabel and override paintComponet() to drawImage()</span>
JLabel lbl4 = new JLabel() {
   @Override public void paintComponent(Graphics g) {
      super.paintComponent(g);  <span class="color-comment">// paint background</span>
      g.drawImage(<span class="color-new">img</span>, 0, 0, 200, 200, null);
   }
};
lbl4.setPreferredSize(new Dimension(200, 200));
cp.add(lbl4);</pre>

<h4>Example</h4>

<img class="image-float-right" src="images/Graphics_DrawImageDemo.png" alt="Graphics_DrawImageDemo.png" />

<p>Images:</p>
<p><img src="images/cross.gif" alt="cross.gif" /> <img src="images/nought.gif" alt="nought.gif" /></p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre>
</td>
<td>
<pre>
import java.awt.*;     <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.net.URL;
import javax.swing.*;  <span class="color-comment">// Using Swing's components and container</span>
import java.util.Random;
 
<span class="color-comment">/** Test drawImage() thru ImageIcon */</span>
@SuppressWarnings(&quot;serial&quot;)
public class CGDrawImageDemo extends JFrame {
   <span class="color-comment">// Define constants for the various dimensions</span>
   public static final int ROWS = 3;
   public static final int COLS = 3;
   public static final int IMAGE_SIZE = 50;
   public static final int PADDING = 20;  <span class="color-comment">// padding from the border</span>
   public static final int CELL_SIZE = IMAGE_SIZE + 2 * PADDING;
   public static final int CANVAS_SIZE = CELL_SIZE * ROWS;
 
   private DrawCanvas canvas;    <span class="color-comment">// The drawing canvas (an inner class extends JPanel)</span>
   private Random random = new Random(); <span class="color-comment">// for picking images in random</span>
 
   <span class="color-comment">// Images</span>
   private String imgCrossFilename = &quot;images/cross.gif&quot;;
   private String imgNoughtFilename = &quot;images/nought.gif&quot;;
   private Image imgCross;   <span class="color-comment">// drawImage() uses an Image object</span>
   private Image imgNought;
 
   <span class="color-comment">// Constructor to set up the GUI components and event handlers</span>
   public CGDrawImageDemo() {
      <span class="color-comment">// Prepare the ImageIcon and Image objects for drawImage()</span>
      ImageIcon iconCross = null;
      ImageIcon iconNought = null;
      URL imgURL = getClass().getClassLoader().getResource(imgCrossFilename);
      if (imgURL != null) {
         iconCross = new ImageIcon(imgURL);
      } else {
         System.err.println(&quot;Couldn't find file: &quot; + imgCrossFilename);
      }
      imgCross = iconCross.getImage();
 
      imgURL = getClass().getClassLoader().getResource(imgNoughtFilename);
      if (imgURL != null) {
         iconNought = new ImageIcon(imgURL);
      } else {
         System.err.println(&quot;Couldn't find file: &quot; + imgNoughtFilename);
      }
      imgNought = iconNought.getImage();
 
      canvas = new DrawCanvas();
      canvas.setPreferredSize(new Dimension(CANVAS_SIZE, CANVAS_SIZE));
      setContentPane(canvas);  <span class="color-comment">// use JPanel as content-pane</span>
      setDefaultCloseOperation(EXIT_ON_CLOSE);
      pack();  <span class="color-comment">// pack the components of &quot;super&quot; JFrame</span>
      setTitle(&quot;Test drawImage()&quot;);
      setVisible(true);
   }
 
   <span class="color-comment">// Define inner class DrawCanvas, which is a JPanel used for custom drawing</span>
   private class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);
         setBackground(Color.WHITE);  <span class="color-comment">// Set background color for this JPanel</span>
         <span class="color-comment">// Drawing Images (picked in random)</span>
         for (int row = 0; row &lt; ROWS; ++row) {
            for (int col = 0; col &lt; COLS; ++col) {
               boolean useCross = random.nextBoolean();
               Image img = useCross ? imgCross : imgNought;
               g.drawImage(img,
                     CELL_SIZE * col + PADDING, CELL_SIZE * row + PADDING,
                     IMAGE_SIZE, IMAGE_SIZE, null);
            }
         }
         <span class="color-comment">// Draw Borders</span>
         g.fill3DRect(CELL_SIZE - 2, 0, 4, CELL_SIZE * 3, true);
         g.fill3DRect(CELL_SIZE * 2 - 2, 0, 4, CELL_SIZE * 3, true);
         g.fill3DRect(0, CELL_SIZE - 2, CELL_SIZE * 3, 4, true);
         g.fill3DRect(0, CELL_SIZE * 2 - 2, CELL_SIZE * 3, 4, true);
      }
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new CGDrawImageDemo(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This example places absolute numbers in the draw methods, which is hard to maintain and reuse.  You should define name-constants such as <code>CELL_WIDTH</code>, <code>BORDER_WIDTH</code>, etc, and compute the numbers based on these constants.</p>

<h3 id="animation">Animation</h3>

<h4 id="swingtimer">Animation using <span class="font-code">javax.swing.Timer</span></h4>

<img class="image-float-right" src="images/Graphics_BouncingBall.png" alt="Graphics_BouncingBall.png" />

<p>Creating an animation (such as a bouncing ball) requires repeatedly running an updating task at a regular interval. Swing provides a <code>javax.swing.Timer</code> class which can be used to fire <code>ActionEvent</code> to its registered <code>ActionListeners</code> at regular interval.</p>

<p>The <code>Timer</code> class has one constructor:</p>
<pre class="color-syntax">
public Timer(int <em>delay</em>, ActionListener <em>listener</em>)</pre>

<p>You are required to override the <code>actionPerformed()</code> method of the <code>ActionListener</code> to specify your task's behavior. The <code>Timer</code> fires an <code>ActionEvent</code> to the <code>ActionListener</code> after the (initial) delay, and then at regular interval after delay.<code></code></p>

<p>You can start and stop the <code>Timer</code> via the <code>Timer</code>'s <code>start()</code> and <code>stop()</code> methods. For example,</p>

<pre class="color-example">
int delay = 500; <span class="color-comment">// milliseconds</span>
<span class="color-comment">// Create an instance of an anonymous subclass of ActionListener</span>
ActionListener updateTask = new ActionListener() {
   @Override
   public void actionPerformed(ActionEvent evt) {
      <span class="color-comment">// ......</span>
   }
};
<span class="color-comment">// Start and run the task at regular delay</span>
new Timer(delay, updateTask).start();</pre>


<p>You can use method <code>setRepeats(false)</code> to set the <code>Timer</code> to fire only once, after the delay. You can set the initial delay via <code>setInitialDelay()</code> and regular delay via <code>setDelay()</code>.</p>

<p>A <code>Timer</code> can fire the <code>ActionEvent</code> to more than one <code>ActionListener</code>s. You can register more <code>ActionListener</code>s via the <code>addActionListener()</code> method.</p>
<p>The <code>actionPerformed()</code> runs on the event-dispatching thread, just like all the event handlers. You can be relieved of the multi-threading issues.</p>
<p>JDK 1.3 introduced another timer class called <code>java.util.Timer</code>, which is more general, but <code>javax.swing.Timer</code> is sufficient (and easier) to run animation in Swing application.</p>

<h5>Example: A Bouncing Ball</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using AWT's Graphics and Color</span>
import java.awt.event.*; <span class="color-comment">// Using AWT's event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing's components and container</span>
 
<span class="color-comment">/** 
 * A Bouncing Ball: Running animation via Swing Timer 
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class CGBouncingBallSwingTimer extends JFrame {
   <span class="color-comment">// Define named-constants</span>
   private static final int CANVAS_WIDTH = 640;
   private static final int CANVAS_HEIGHT = 480;
   <span class="color-new">private static final int UPDATE_PERIOD = 50;</span> <span class="color-comment">// milliseconds</span>
 
   private DrawCanvas canvas;  <span class="color-comment">// the drawing canvas (an inner class extends JPanel)</span>
 
   <span class="color-comment">// Attributes of moving object</span>
   private int x = 100, y = 100;  <span class="color-comment">// top-left (x, y)</span>
   private int size = 250;        <span class="color-comment">// width and height</span>
   private int xSpeed = 3, ySpeed = 5; <span class="color-comment">// displacement per step in x, y</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public CGBouncingBallSwingTimer() {
      canvas = new DrawCanvas();
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
      this.setContentPane(canvas);
      this.setDefaultCloseOperation(EXIT_ON_CLOSE);
      this.pack();
      this.setTitle(&quot;Bouncing Ball&quot;);
      this.setVisible(true);
 
      <span class="color-comment">// Define an ActionListener to perform update at regular interval</span>
      <span class="color-new">ActionListener updateTask = new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            update();</span>   <span class="color-comment">// update the (x, y) position</span>
            <span class="color-new">repaint();</span>  <span class="color-comment">// Refresh the JFrame, callback paintComponent()</span>
         <span class="color-new">}
      };</span>
      <span class="color-comment">// Allocate a Timer to run updateTask's actionPerformed() after every delay msec</span>
      <span class="color-new">new Timer(UPDATE_PERIOD, updateTask).start();</span>
   }
 
   <span class="color-comment">// Update the (x, y) position of the moving object</span>
   public void update() {
      x += xSpeed;
      y += ySpeed;
      if (x &gt; CANVAS_WIDTH - size || x &lt; 0) {
         xSpeed = -xSpeed;
      }
      if (y &gt; CANVAS_HEIGHT - size || y &lt; 0) {
         ySpeed = -ySpeed;
      }
   }
 
   <span class="color-comment">// Define inner class DrawCanvas, which is a JPanel used for custom drawing</span>
   private class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);  <span class="color-comment">// paint parent's background</span>
         setBackground(Color.BLACK);
         g.setColor(Color.BLUE);
         g.fillOval(x, y, size, size);  <span class="color-comment">// draw a circle</span>
      }
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new CGBouncingBallSwingTimer(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p><code>javax.swing.Timer</code> does not provide very accurate timing due to the overhead of event-handling. It probaly cannot be used for real-time application such as displaying a clock.</p>

<p>[TODO] Stop the Timer after x steps</p>

<h4>(Advanced) Animation using a new <span class="font-code">Thread</span></h4>

<img class="image-float-right" src="images/Graphics_BouncingBall.png" alt="Graphics_BouncingBall.png" />

<p>Animation usually involves multi-threading, so that the GUI refreshing operations does not interfere with the programming logic. Multi-threading is an advanced topics. Read &quot;<a href="J5e_multithreading.html">Multithreading &amp; Concurrent Programming</a>&quot;</p>

<p>In the previous example, we use <code>javax.swing.Timer</code>, which run the updating task at regular interval on the event-dispatching thread.  In this example, we shall create a new thread to run the update.</p>

<p>To create a new thread, define a (anonymous and inner) subclass of <code>Thread</code> and override the <code>run()</code> method to specify the behavior of the task. Create an instance and start the instance via the <code>start()</code> method, which calls back the <code>run()</code> defined earlier.</p>

<p>To ensure the new thread does not starve the other threads, in particular the event-dispatching thread, the thread shall yield control via the <code>sleep(mills)</code> method, which also provides the necessary delay.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82</pre>
</td>
<td>
<pre>
import java.awt.*;    <span class="color-comment">// Using AWT's Graphics and Color</span>
import javax.swing.*; <span class="color-comment">// Using Swing's components and containers</span>
 
<span class="color-comment">/**
 * A Bouncing Ball: Running animation via a custom thread
 */</span>
public class CGBouncingBall extends JFrame {
   <span class="color-comment">// Define named-constants</span>
   private static final int CANVAS_WIDTH = 640;
   private static final int CANVAS_HEIGHT = 480;
   <strong>private static final int UPDATE_INTERVAL = 50; <span class="color-comment">// milliseconds</span></strong>
 
   private DrawCanvas canvas;  <span class="color-comment">// the drawing canvas (an inner class extends JPanel)</span>
 
   <span class="color-comment">// Attributes of moving object</span>
   private int x = 100;     <span class="color-comment">// top-left (x, y)</span>
   private int y = 100;
   private int size = 250;  <span class="color-comment">// width and height</span>
   private int xSpeed = 3;  <span class="color-comment">// moving speed in x and y directions</span>
   private int ySpeed = 5;  <span class="color-comment">// displacement per step in x and y</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public CGBouncingBall() {
      canvas = new DrawCanvas();
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
      this.setContentPane(canvas);
      this.setDefaultCloseOperation(EXIT_ON_CLOSE);
      this.pack();
      this.setTitle(&quot;Bouncing Ball&quot;);
      this.setVisible(true);
 
      <span class="color-comment"><strong>// Create a new thread to run update at regular interval</strong></span><strong>
      Thread updateThread = new Thread() {
         @Override
         public void run() {
            while (true) {
               update();   <span class="color-comment">// update the (x, y) position</span>
               repaint();  <span class="color-comment">// Refresh the JFrame. Called back paintComponent()</span>
               try {
                  <span class="color-comment">// Delay and give other thread a chance to run</span>
                  Thread.sleep(UPDATE_INTERVAL);  <span class="color-comment">// milliseconds</span>
               } catch (InterruptedException ignore) {}
            }
         }
      };
      updateThread.start(); <span class="color-comment">// called back run()</span></strong>
   }
 
   <span class="color-comment">// Update the (x, y) position of the moving object</span>
   public void update() {
      x += xSpeed;
      y += ySpeed;
      if (x &gt; CANVAS_WIDTH - size || x &lt; 0) {
         xSpeed = -xSpeed;
      }
      if (y &gt; CANVAS_HEIGHT - size || y &lt; 0) {
         ySpeed = -ySpeed;
      }
   }
 
   <span class="color-comment">// Define Inner class DrawCanvas, which is a JPanel used for custom drawing</span>
   class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);  <span class="color-comment">// paint parent's background</span>
         setBackground(Color.BLACK);
         g.setColor(Color.BLUE);
         g.fillOval(x, y, size, size);  <span class="color-comment">// draw a circle</span>
      }
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new CGBouncingBall(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<ul>
  <li>To update the display regularly, we explicitly invoke the <code>repaint()</code> method of the <code>JFrame</code>, which will callback the <code>paintComponent(g)</code> of all the components contained in this <code>JFrame</code>.</li>
<li>The display refreshing code is run in its own thread, so as to avoid the infamous unresponsive user interface problem. It is programmed as an anonymous inner class, extends class <code>Thread</code>, by overriding the <code>run()</code> method to provide the programmed operations (i.e., <code>repaint()</code>).  The <code>start()</code> method is use to start the thread, which will callback the <code>run()</code>.</li> 
<li>Inside the overridden <code>run()</code>, the <code>repaint()</code> is programmed inside an infinite loop, followed by a <code>Thread.sleep(milliseconds)</code> method, which suspends the thread for the given milliseconds. This operation provides the necessary delay and also yield control to other thread to perform their intended operations.</li>
</ul>

<p>[TODO] Stopping the thread after x steps</p>

<h3>(Advanced) A Closer Look at <span class="font-code">repaint()</span></h3>

<p><span class="line-heading">Reference:</span> &quot;Painting in AWT and Swing&quot; @ <a href="http://www.oracle.com/technetwork/java/painting-140037.html">http://www.oracle.com/technetwork/java/painting-140037.html</a>. I summarize some of the important points here.</p>

<h5>Heavyweight AWT Components vs. Lightweight Swing Components</h5>

<p>The original AWT components are heavyweight components. &quot;Heavyweight&quot; means that the component has it's own opaque native window. Heavyweight components, such as <code>java.awt.Button</code>, are mapped to the platform-specific components. It relies on the windowing subsystem in each native platform to take care of details such as damage detection, clip calculation, and z-ordering. On the other hand, the newer Swing <code>JComponent</code>s (such as <code>javax.swing.JButton</code>) are lightweight components. A &quot;lightweight&quot; component does not own its screen resources but reuses the native window of its closest heavyweight ancestor. Swing <code>JComponent</code>s do not rely on the native platform and are written purely in Java, . The top-level containers, such as <code>JFrame</code>, <code>JApplet</code> and <code>JDialog</code>, which are not subclass of <code>JComponent</code>, remain heavyweight. It is because the lightweight Swing <code>JComponent</code>s need to attach to a heavyweight ancestor.</p>

<h5>Painting Mechanism</h5>

<p>Painting is carried out via a &quot;call-back&quot; mechanism. A program shall put its painting codes in a overridden method (<code>paint()</code> for AWT components or <code>paintComponent()</code> for Swing component), and the windowing subsystem will call back this method when it's time to paint. </p>

<h5>System-triggered vs. Application-triggered Painting Requests</h5>

<p>There are two types of paint (or repaint) requests:</p>
<ol>
<li>System-triggered: e.g., the component is first made visible, the componet is resized, etc. The windowing subsystem will schedule <code>paint()</code> or <code>paintComponent()</code> on the event-dispatching thread.</li>
<li>Application-triggered: application has modified the appearance of the component and requested to repaint the component. However, Application shall not invoke <code>paint()</code> or <code>paintComponent()</code> directly. Instead, it shall invoke a special method called <code>repaint()</code>, which will in turn invoke <code>paint()</code> or <code>paintComponent()</code>. Multiple <code>repaint()</code> requests may be collapsed into a single<code> paint() </code>call.</li>
</ol>

<p>Instead of issuing <code>repaint()</code> to paint the entire component, for efficiency, you can selectively repaint a rectangular clip area. You can also specify a maximum time limit for painting to take place.</p>

<pre class="color-syntax">
public void repaint()
      <span class="color-comment">// requests to repaint this component</span>
public void repaint(long timeMax)  
      <span class="color-comment">// repaint before timeMax msec (for lightweight components)</span>
public void repaint(int x, int y, int width, int height)  
      <span class="color-comment">// repaint the specified rectangular area</span>
public void repaint(long timeMax, int x, int y, int width, int height)  
      <span class="color-comment">// repaint the specified rectangular area within timeMax msec</span></pre>

<h5>Painting the Lightweight Swing Components</h5>
<p>A lightweight needs a heavyweight somewhere up the containment hierarchy in order to have a place to paint, as only heavyweight components have their own opaque window. When this heavyweight ancestor is asked to paint its window, it must also paint all of its lightweight descendants. This is handled by <code>java.awt.Container</code>'s <code>paint()</code> method, which calls <code>paint()</code> on any of its visible, lightweight children which intersect with the rectangle to be painted. Hence, it is crucial for all <code>Container</code> subclasses (lightweight or heavyweight) that override <code>paint()</code> to place a <code>super.paint()</code> call in the <code>paint()</code> method. This <code>super.paint()</code> call invoke <code>Container</code>'s (<code>super</code>) <code>paint()</code> method, which in turn invoke <code>paint()</code> on all its descendants. If the <code>super.paint()</code> call is missing, some of the lightweight descendants will be shown up.</p>

<h5>Opaque and Transparent</h5>

<p>Lightweight components does not own its opaque window and &quot;borrow&quot; the screen real estate of its heavyweight ancestor. As a result, they could be made transparent, by leaving their background pixels unpainted to allow the underlying component to show through.</p>

<p>To improve performance of opaque components, Swing adds a property called <code>opaque</code> to all <code>JComponent</code>s. If <code>opaque</code> is set to <code>true</code>, the component agrees to paint all of the pixels contained within its rectangular bounds. In order words, the windowing subsystem does not have to do anything within these bounds such as painting its ancestors. It <code>opaque</code> is set to <code>false</code>, the component makes no guarantees about painting all the bits within its rectangular bounds, and the windowing subsystem has more work to do.</p>

<p>Swing further factor the <code>paint()</code> method into three methods, which are invoked in the following order:</p>

<pre class="color-plain">
protected void paintComponent(Graphics g)
protected void paintBorder(Graphics g)
protected void paintChildren(Graphics g)</pre>

<p>Swing programs should override <code>paintComponent()</code> instead of <code>paint()</code>.</p>

<p>Most of the standard Swing components (in particular, <code>JPanel</code>) have their look and feel implemented by separate look-and-feel objects (called &quot;UI delegates&quot;) for Swing's Pluggable look and feel feature. This means that most or all of the painting for the standard components is delegated to the UI delegate and this occurs in the following way:</p>

<ol>
<li><code>paint()</code> invokes <code>paintComponent()</code>.</li>
<li>If the <code>ui</code> property is non-<code>null</code>, <code>paintComponent()</code> invokes <code>ui.update()</code>.</li>
<li>If the component's <code>opaque</code> property is <code>true</code>, <code>ui.udpate()</code> fills the component's background with the background color and invokes <code>ui.paint()</code>.</li>
<li><code>ui.paint()</code> renders the content of the component.</li></ol>

<p>This means that subclasses of Swing components which have a UI delegate (such as <code>JPanel</code>), should invoke <code>super.paintComponent()</code> within their overridden <code>paintComponent()</code>, so that <code>ui.update()</code> fills the background (of the superclass such as <code>JPanel</code>) provided <code>opaque</code> is <code>true</code>.</p>

<pre class="color-example">
public class MyPanel extends JPanel {
   @Override
   protected void paintComponent(Graphics g) {
      // Let UI delegate paint first 
      // (including background filling, if I'm opaque)
      
      super.paintComponent(g);  <span class="color-comment">// fill the JPanel's background and invoke ui.paint()</span>
      
      // paint my contents next....
   }
}</pre>

<p>Try removing the <code>super.paintComponent()</code> from a Swing program that does animation (e.g., bouncing ball). The background will not be painted, and the previous screen may not be cleared. You can also paint the background yourself by filling a Rectangle with background color.</p>

<pre class="color-example">
@Override
protected void paintComponent(Graphics g) {
   g.setColor(<em>backgroundColor</em>);
   g.fillRect(0, 0, getWidth() - 1, getHeight() - 1);
}</pre>

<p>Furthermore, if you set the <code>opaque</code> to <code>false</code> (via <code>setOpaque(false)</code>) for the subclass of <code>JPanel</code>, the <code>super.paintComponent(g)</code> does not fill the background.</p>


<p class="references">REFERENCES &amp; RESOURCES</p>
<ul>
<li>&quot;The Swing Tutorial&quot; @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>, in particular, the section on &quot;Performing Custom Graphics&quot;.</li>
<li>&quot;Painting in AWT and Swing&quot; @ <a href="http://www.oracle.com/technetwork/java/painting-140037.html">http://www.oracle.com/technetwork/java/painting-140037.html</a>.</li>
</ul>

</div> 
<!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 1.8.0<br />
Last modified: April, 2016</p></div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
</body>
</html>
