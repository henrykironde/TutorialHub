<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Multithreading and Concurrency - Java Programming Tutorial</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Multithreading &amp; Concurrent Programming</h2>
</div>

<div id="content-main">


<h3>Introduction</h3>

<p>Java supports <em>single-thread</em> as well as <em>multi-thread</em> operations. A single-thread program has a single entry point (the <code>main()</code> method) and a single exit point. A multi-thread program has an initial entry point (the <code>main()</code> method), followed by many entry and exit points, which are run concurrently with the <code>main()</code>. The term &quot;<em>concurrency</em>&quot; refers to doing multiple tasks at the same time.</p>

<p>Java has built-in support for <em>concurrent programming</em> by running multiple threads concurrently within a single program.  A <em>thread</em>, also called a <em>lightweight process</em>, is a single sequential flow of programming operations, with a definite beginning and an end.  During the lifetime of the thread, there is only a single point of execution.  A thread by itself is not a program because it cannot run on its own.  Instead, it runs within a program.  The following figure shows a program with 3 threads running under a single CPU:  </p>

<img class="image-center" src="images/Multithread.gif" alt="Multithread.gif" />

<h4>Multitasking (or Multi-processing)</h4>
<p>Modern operating systems (such as Windows and UNIX) are <em>multitasking</em> system.  A multitasking system can perform many tasks concurrently by sharing the computing resources, such as CPU(s), main memory, and I/O channels.  In a single-CPU machine, only one task can be executed at one time – through time-slicing of the CPU.  In a multi-CPU machine, a few tasks can be executed simultaneously, either distributed among or time-slicing the CPUs.</p>

<p>Multitasking is necessary in today's operating systems for better performance by making full use and optimize the usage of the computing resources. There are generally two kinds of multitasking operating systems:</p>

<ol>
<li><em>Co-operative multitasking systems</em>:  Each task must <em>voluntarily</em> yield control to other tasks.  This has the drawback that a run-away or uncooperative task may hang the entire system.</li>
<li><em>Pre-emptive multitasking systems</em>:  Tasks are given time-slices of the CPU(s) and will be forced to yield control to other tasks once their allocation is used up.</li>
</ol>

<h4>Multithreading (within a Process)</h4>
<p>In UNIX, we <em>fork</em> a new process.  In Windows, we start a program.  A process or program has its own address space and control blocks.  It is called <em>heavyweight</em> because it consumes a lot of system resources. Within a process or program, we can run multiple threads concurrently to improve the performance.</p>

<p>Threads, unlike heavyweight process, are lightweight and run inside a single process – they share the same address space, the resources allocated and the environment of that process.  It is lightweight because it runs within the context of a heavyweight process and takes advantage of the resources allocated for that program and the program’s environment. A thread must carve out its own resources within the running process.  For example, a thread has its own stack, registers and program counter.  The code running within the thread works only within that context, hence, a thread (of a sequential flow of operations) is also called an execution context.</p>

<p>Multithreading within a program improves the performance of the program by optimizing the usage of system resources.  For example, while one thread is blocked (e.g., waiting for completion of an I/O operation), another thread can use the CPU time to perform  computations, resulted in better performance and overall throughput.</p>

<p>Multithreading is also necessary to provide better interactivity with the users.  For example, in a word processor, while one thread is printing or saving the file, another thread can be used to continue typing.  In GUI applications, multithreading is essential in providing a <em>responsive</em> user interface.</p>
<p>For this article, I shall assume that you understand Swing programming, as Swing applications rely on multithreading (to perform their specific function, repaint and process the events) and best to illustrate multithreading.</p>
<p>A typical Java program runs in a single process, and is not interested in multiple processes. However, within the process, it often uses multiple threads to to run multiple tasks concurrently. A standalone Java application starts with a single thread (called <em>main thread</em>) associated with the main() method. This <em>main thread</em> can then start new user threads.</p>


<h3>The Infamous &quot;Unresponsive User Interface&quot;</h3>

<img class="image-float-right" src="images/Multithread_UnresponsiveUI.gif" alt="Multithread_UnresponsiveUI.gif" />


<p>The infamous <em>Unresponsive User Interface (UI) problem</em> is best illustrated by the following Swing program with a counting-loop. </p>
<p>The GUI program has two buttons. Pushing the &quot;Start Counting&quot; button starts the counting. Pushing the &quot;Stop Counting&quot; button is <em>supposed</em> to stop (pause) the counting. The two button-handlers communicate via a <code>boolean</code> flag called <code>stop</code>. The stop-button handler sets the <code>stop</code> flag; while the start-button handler checks if <code>stop</code> flag has been set before continuing the next count.</p>
<p>You should write the program under Eclipse/NetBeans so that we could trace the threads.</p>

<h4>Example 1: Unresponsive UI</h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
 
<span class="color-comment">/** Illustrate Unresponsive UI problem caused by &quot;busy&quot; Event-Dispatching Thread */</span>
public class UnresponsiveUI extends JFrame {
   <span class="color-new">private boolean stop = false;</span>  <span class="color-comment">// start or stop the counter</span>
   private JTextField tfCount;
   private int count = 1;
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public UnresponsiveUI() {
      Container cp = this.getContentPane();
      cp.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));
      cp.add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(count + &quot;&quot;, 10);
      tfCount.setEditable(false);
      cp.add(tfCount);
 
      JButton btnStart = new JButton(&quot;Start Counting&quot;);
      cp.add(btnStart);
      btnStart.addActionListener(new ActionListener() {
         @Override
         <span class="color-new">public void actionPerformed(ActionEvent evt) {
            stop = false;
            for (int i = 0; i &lt; 100000; ++i) {
               if (stop) break;</span>  <span class="color-comment">// check if STOP button has been pushed,
                                 //  which changes the stop flag to true</span>
               <span class="color-new">tfCount.setText(count + &quot;&quot;);
               ++count;
            }
         }</span>
      });
      JButton btnStop = new JButton(&quot;Stop Counting&quot;);
      cp.add(btnStop);
      btnStop.addActionListener(new ActionListener() {
         @Override
         <span class="color-new">public void actionPerformed(ActionEvent evt) {
            stop = true;</span>  <span class="color-comment">// set the stop flag</span>
         <span class="color-new">}</span>
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setTitle(&quot;Counter&quot;);
      setSize(300, 120);
      setVisible(true);
   }
 
   <span class="color-comment">/** The entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         public void run() {
            new UnresponsiveUI();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p> However, once the START button is pushed, the UI is <em>frozen</em> – the counter value is not updated on the display (i.e., the display is not <em>refreshed</em>), and the user interface is not responding to the clicking of the STOP button, or any other user interaction.</p>

<h5>Tracing the threads (Advanced)</h5>

<p>From the program trace (via Eclipse/NetBeans), we observe:</p>
<ol>
<li>The <code>main()</code> method is started in the &quot;main&quot; thread.</li>

<li>The JRE's windowing subsystem, via <code>SwingUtilities.invokeLater()</code>, starts 3 threads: &quot;AWT-Windows&quot; (daemon thread), &quot;AWT-Shutdown&quot; and &quot;AWT-EventQueue-0&quot;.  The &quot;AWT-EventQueue-0&quot; is known as the <em>Event-Dispatching Thread</em> (<em>EDT</em>), which is the one and only thread responsible for handling all the events (such as clicking of buttons) and refreshing the display to ensure thread safety in GUI operations and manipulating GUI components. The constructor <code>UnresponsiveUI()</code> is scheduled to run on the Event-Dispatching thread (via <code>invokeLater()</code>), after all the existing events have been processed. The &quot;main&quot; thread exits after the <code>main()</code> method completes.  A new thread called &quot;DestroyJavaVM&quot; is created.</li>

<li>When you click the START button, the <code>actionPerformed()</code> is run on the EDT. The EDT is now fully-occupied with the compute-intensive counting-loop. In other words, while the counting is taking place, the EDT is <em>busy</em> and unable to process any event (e.g., clicking the STOP button or the window-close button) and refresh the display  - until the counting completes and EDT becomes available.  As the result, the display freezes until the counting-loop completes.</li></ol>

<p>It is recommended to run the GUI construction codes on the EDT via the <code>invokeLater()</code>. This is because many of the GUI components are not guaranteed to be thread-safe. Channeling all accesses to GUI components in a single thread ensure thread safety. Suppose that we run the constructor directly on the <code>main()</code> method (under the &quot;main&quot; thread), as follow:</p>

<pre class="color-example">
public static void main(String[] args) {
   new UnresponsiveUI();
}</pre>

<p>The trace shows that:</p>

<ol>
<li>The <code>main()</code> method starts in the &quot;main&quot; thread.</li>

<li>A new thread &quot;AWT-Windows&quot; (Daemon thread) is started when we step-into the constructor &quot;<code>new UnresponsiveUI()</code>&quot; (because of the &quot;<code>extends JFrame</code>&quot;).</li>
<li>After executing &quot;<code>setVisible(true)</code>&quot;, another two  threads are created - &quot;AWT-Shutdown&quot; and &quot;AWT-EventQueue-0&quot; (i.e., the EDT).</li>
<li>The &quot;main&quot; thread exits after the <code>main()</code> method completes.  A new thread called &quot;DestroyJavaVM&quot; is created.</li>
<li>At this point, there are 4 threads running - &quot;AWT-Windows&quot;, &quot;AWT-Shutdown&quot; and &quot;AWT-EventQueue-0 (EDT)&quot; and &quot;DestroyJavaVM&quot;.</li>
<li>Clicking the START button invokes the <code>actionPerformed()</code> in the EDT.</li>
</ol>

<p>In the earlier case, the EDT is started via the <code>invokeLater()</code>; while in the later case, the EDT starts after <code>setVisible()</code>.</p>

<h4>Example 2: Still Unresponsive UI with Thread</h4>

<p>Instead of using the <em>event-dispatching thread</em> to do the compute-intensive counting, let's create a new thread to do the counting, instead of using the EDT, as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

<span class="color-comment">/** Illustrate the Unresponsive UI problem caused by &quot;starved&quot; event-dispatching thread */</span>
public class UnresponsiveUIwThread extends JFrame {
   private boolean stop = false;
   private JTextField tfCount;
   private int count = 1;
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public UnresponsiveUIwThread() {
      Container cp = getContentPane();
      cp.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));
      cp.add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(count + &quot;&quot;, 10);
      tfCount.setEditable(false);
      cp.add(tfCount);
 
      JButton btnStart = new JButton(&quot;Start Counting&quot;);
      cp.add(btnStart);
      btnStart.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            stop = false;
            <span class="color-comment">// Create our own Thread to do the counting</span>
            <span class="color-new">Thread t = new Thread() {
               @Override
               public void run() {</span>  <span class="color-comment">// override the run() to specify the running behavior</span>
                  <span class="color-new">for (int i = 0; i &lt; 100000; ++i) {
                     if (stop) break;
                     tfCount.setText(count + &quot;&quot;);
                     ++count;
                  }
               }
            };
            t.start();</span>  <span class="color-comment">// call back run()</span>
         }
      });
 
      JButton btnStop = new JButton(&quot;Stop Counting&quot;);
      cp.add(btnStop);
      btnStop.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            stop = true;
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setTitle(&quot;Counter&quot;);
      setSize(300, 120);
      setVisible(true);
   }
 
   <span class="color-comment">/** The entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread safety</span>
      javax.swing.SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new UnresponsiveUIwThread();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>A new thread is created by sub-classing the <code>Thread</code> class, with an anonymous inner class. We override the <code>run()</code> method to specify the running behavior of the thread, which performs the compute-intensive counting.  An instance is created.  Invoking the <code>start()</code> method of the instance causes the <code>run()</code> to execute on its own thread.  (The details on creating new thread will be explained later.)</p>

<p>The responsiveness improves slightly.  But the proper counter value is still not shown, and there is a delay in response to the &quot;STOP&quot; button. (You may not see the difference running with a dual-core processor.)</p>

<p>This is because the counting thread does not voluntarily yield control to the EDT. The &quot;starved&quot; EDT is unable to update the display and response to the &quot;STOP&quot; button.  Nonetheless, the JVM may force the counting thread to yield control according to the scheduling algorithm, which results in delay on updating the display (TODO: not sure about this).</p>

<h5>Tracing the Threads (Advanced)</h5>

<p>When the &quot;START&quot; button is clicked, a new thread called &quot;Thread-<em>n</em>&quot; (n is a running number) is created to run the compute-intensive counting-loop.  However, this thread is not programmed to yield control to other threads, in particular, the event-dispatching thread.</p>

<p>This program is, however, slightly better than the previous program.  The display is updated, and the clicking of &quot;STOP&quot; button has its effect after some delays.</p>

<h4>Example 3: Responsive UI with Thread</h4>

<p>Let's modify the program by making a call to the counting-thread's <code>sleep()</code> method, which requests the counting-thread to yield control to the event-dispatching thread to update the display and response to the &quot;STOP&quot; button.  The counting program now works as desired. The <code>sleep()</code> method also provides the necessary delay needed.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
 
<span class="color-comment">/** Resolve the unresponsive UI problem by running the compute-intensive task
    in this own thread, which yields control to the EDT regularly */</span>
public class UnresponsiveUIwThreadSleep extends JFrame {
   private boolean stop = false;
   private JTextField tfCount;
   private int count = 1;
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public UnresponsiveUIwThreadSleep() {
      Container cp = getContentPane();
      cp.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10));
      cp.add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(count + &quot;&quot;, 10);
      tfCount.setEditable(false);
      cp.add(tfCount);
 
      JButton btnStart = new JButton(&quot;Start Counting&quot;);
      cp.add(btnStart);
      btnStart.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            stop = false;
            <span class="color-comment">// Create a new Thread to do the counting</span>
            Thread t = new Thread() {
               @Override
               public void run() {  <span class="color-comment">// override the run() for the running behaviors</span>
                  for (int i = 0; i &lt; 100000; ++i) {
                     if (stop) break;
                     tfCount.setText(count + &quot;&quot;);
                     ++count;
                     <span class="color-comment">// Suspend this thread via sleep() and yield control to other threads.
                     // Also provide the necessary delay.</span>
                     <span class="color-new">try {
                        sleep(10);</span>  <span class="color-comment">// milliseconds</span>
                     <span class="color-new">} catch (InterruptedException ex) {}</span>
                  }
               }
            };
            t.start();  <span class="color-comment">// call back run()</span>
         }
      });
 
      JButton btnStop = new JButton(&quot;Stop Counting&quot;);
      cp.add(btnStop);
      btnStop.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            stop = true;
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setTitle(&quot;Counter&quot;);
      setSize(300, 120);
      setVisible(true);
   }
 
   <span class="color-comment">/** The entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread safety</span>
      javax.swing.SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new UnresponsiveUIwThreadSleep();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The <code>sleep()</code> method suspends the current thread and put it into the <em>waiting state</em> for the specified number of milliseconds.  Another thread can begin execution (in a single CPU environment).  (The <code>sleep()</code> can be interrupted by invoking the <code>interrupt()</code> method of this thread, which triggers an <code>InterruptedException</code> - this is unusual!)</p>

<p>In this case, the thread created to do the counting (&quot;Thread-n&quot;) yields control <em>voluntarily</em> to other threads after every count (via the &quot;<code>sleep(10)</code>&quot;).  This allows the event-dispatching thread to refresh the display as well as processing the &quot;STOP&quot; button after <em>each</em> count.</p>

<h4>Example 4: <span class="font-code">SwingWorker</span></h4>
<p>JDK 1.6 provides a new <code>javax.swing.SwingWorker</code> class, which can be used to run compute-intensive tasks in background threads, and passes the final result or intermediate results back to methods that run on the event-dispatching thread. We shall discuss <code>SwingWorker</code> in the later section.</p>

<h3>Creating a new Thread</h3>

<p>There are two ways to create a new thread:</p>
<ol>
<li>Extend a subclass from the superclass <code>Thread</code> and override the <code>run()</code> method to specify the running behavior of the thread.  Create an instance and invoke the <code>start()</code> method, which will call-back the <code>run()</code> on a new thread.  For example:

  <pre class="color-example">
Thread t = new Thread() {   <span class="color-comment">// Create an instance of an anonymous inner class that extends Thread</span>
   @Override
   public void run() {      <span class="color-comment">// Override run() to specify the running behaviors</span>
      for (int i = 0; i &lt; 100000; ++i) {
         if (stop) break;
         tfCount.setText(count + &quot;&quot;);
         ++count;
         <span class="color-comment">// Suspend itself and yield control to other threads for the specified milliseconds
         // Also provide the necessary delay</span>
         try {
            sleep(10); <span class="color-comment">// milliseconds</span>
         } catch (InterruptedException ex) {}
      }
   }
};
t.start();  <span class="color-comment">// Start the thread. Call back run() in a new thread</span></pre></li>

<li>Create a class that implements the <code>Runnable</code> interface and provide the implementation to the <code>abstract</code> method <code>run()</code> to specify the running behavior of the thread. Construct a new <code>Thread</code> instance using the constructor with a <code>Runnable</code> object and invoke the <code>start()</code> method, which will call back <code>run()</code> on a new thread.

  <pre class="color-example">
<span class="color-comment">// Create an anonymous instance of an anonymous inner class that implements Runnable
// and use the instance as the argument of Thread's constructor.</span>
Thread t = new Thread(new Runnable() {
   <span class="color-comment">// Provide implementation to abstract method run() to specify the running behavior</span>
   @Override
   public void run() {
      for (int i = 0; i &lt; 100000; ++i) {
         if (stop) break;
         tfCount.setText(count + &quot;&quot;);
         ++count;
         <span class="color-comment">// Suspend itself and yield control to other threads
         // Also provide the necessary delay</span>
         try {
            Thread.sleep(10);  <span class="color-comment">// milliseconds</span>
         } catch (InterruptedException ex) {}
      }
   }
});
t.start();  <span class="color-comment">// call back run() in new thread</span></pre>
</li></ol>

<p>The second method is needed as Java does not support <em>multiple inheritance</em>.  If a class already extends from a certain superclass, it cannot extend from <code>Thread</code>, and have to implement the <code>Runnable</code> interface.  The second method is also used to provide compatibility with JDK 1.1.  It should be noted that the <code>Thread</code> class itself implements the <code>Runnable</code> interface.</p>

<p>The <code>run()</code> method specifies the running behavior of the thread and gives the thread something to do.  You do not invoke the <code>run()</code> method directly from your program.  Instead, you create a <code>Thread</code> instance and invoke the <code>start()</code> method.  The <code>start()</code> method, in turn, will <em>call back</em> the <code>run()</code> on a new thread.</p>

<h4>Interface <span class="font-code">Runnable</span></h4>

<p>The interface <code>java.lang.Runnable</code> declares one <code>abstract</code> method <code>run()</code>, which is used to specify the running behavior of the thread:</p>

<pre class="color-syntax">public void run();</pre>

<h4>Class <span class="font-code">Thread</span></h4>

<p>The class <code>java.lang.Thread</code> has the following constructors:</p>

<pre class="color-syntax">
public <strong>Thread</strong>();
public <strong>Thread</strong>(String <em>threadName</em>);
public <strong>Thread</strong>(Runnable <em>target</em>);
public <strong>Thread</strong>(Runnable <em>target</em>, String <em>threadName</em>);</pre>

<p>The first two constructors are used for creating a thread by sub-classing the <code>Thread</code> class.  The next two constructors are used for creating a thread with an instance of class that implements <code>Runnable</code> interface.</p>

<p>The class <code>Thread</code> implements <code>Runnable</code> interface, as shown in the class diagram.</p>

<img class="image-center" src="images/Multithread_ThreadRunnable.png" alt="Multithread_ThreadRunnable.png" />

<p>As mentioned, the method <code>run()</code> specifies the running behavior of the thread.  You do not invoke the <code>run()</code> method explicitly.  Instead, you call the <code>start()</code> method of the class <code>Thread</code>.  If a thread is constructed by extending the <code>Thread</code> class, the method <code>start()</code> will call back the overridden <code>run()</code> method in the extended class.  On the other hand, if a thread is constructed by providing a <code>Runnable</code> object to the <code>Thread</code>'s constructor, the <code>start()</code> method will call back the <code>run()</code> method of the <code>Runnable</code> object (and not the <code>Thread</code>'s version).</p>

<h4>Creating a new Thread by sub-classing <span class="font-code">Thread</span> and overriding <span class="font-code">run()</span></h4>

<p>To create and run a new thread by extending <code>Thread</code> class:</p>
<ol>
<li>Define a subclass (named or anonymous) that extends from the superclass <code>Thread</code>.</li>
<li>In the subclass, override the <code>run()</code> method to specify the thread's operations, (and provide other implementations such as constructors, variables and methods).</li>
<li>A client class creates an instance of this new class.  This instance is called a <code>Runnable</code> object (because <code>Thread</code> class itself implements <code>Runnable</code> interface).</li>
<li>The client class invokes the <code>start()</code> method of the <code>Runnable</code> object.  The result is two thread running concurrently – the current thread continue after invoking the <code>start()</code>, and a new thread that executes <code>run()</code> method of the <code>Runnable</code> object.</li>
</ol>

<p>For example,</p>

<pre class="color-example">
class MyThread <strong>extends Thread</strong> {
   <span class="color-comment">// override the run() method</span>
   @Override
   public void <strong>run</strong>() {
      <span class="color-comment">// Thread's running behavior</span>
   }
   <span class="color-comment">// constructors, other variables and methods</span>
   ......
}</pre>

<pre class="color-example">
public class Client {
   public static void main(String[] args) {
      ......
      <span class="color-comment">// Start a new thread</span>
      MyThread t1 = new MyThread();
      t1.start();  <span class="color-comment">// Called back run()</span>
      ......
      <span class="color-comment">// Start another thread</span>
      new MyThread().start();
      ......
   }
}</pre>

<p>Often, an inner class (named or anonymous) is used instead of a ordinary subclass.  This is done for readability and for providing access to the private variables and methods of the outer class.  For example,</p>

<pre class="color-example">
public class Client {
   ......
   public Client() {
      Thread t = new Thread() { <span class="color-comment">// Create an anonymous inner class extends Thread</span>
         @Override
         public void <strong>run</strong>() {
            <span class="color-comment">// Thread's running behavior
            // Can access the private variables and methods of the outer class</span>
         }
      };
      t.<strong>start()</strong>;
      ...
      <span class="color-comment">// You can also used a named inner class defined below</span>
      new MyThread().<strong>start()</strong>;
   }

   <span class="color-comment">// Define a named inner class extends Thread</span>   
   class MyThread <strong>extends Thread</strong> {
      public void <strong>run</strong>() {
         <span class="color-comment">// Thread's running behavior
         // Can access the private variables and methods of the outer class</span>
      }
   }
}</pre>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre>
public class MyThread extends Thread {
   private String name;
 
   public MyThread(String name) {   <span class="color-comment">// constructor</span>
      this.name = name;
   }
 
   <span class="color-comment">// Override the run() method to specify the thread's running behavior</span>
   @Override
   public void run() {
      for (int i = 1; i &lt;= 5; ++i) {
         System.out.println(name + &quot;: &quot; + i);
         yield();
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>A class called <code>MyThead</code> is created by extending <code>Thread</code> class and overriding the <code>run()</code> method. A constructor is defined to takes a <code>String</code> as the name of the thread. The <code>run()</code> method prints 1 to 5, but invokes <code>yield()</code> to yield control to other threads voluntarily after printing each number.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12</pre>
</td>
<td>
<pre>
public class TestMyThread {
   public static void main(String[] args) {
      Thread[] threads = {
         new MyThread(&quot;Thread 1&quot;),
         new MyThread(&quot;Thread 2&quot;),
         new MyThread(&quot;Thread 3&quot;)
      };
      for (Thread t : threads) {
         t.start();
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The test class allocates and starts three threads. The output is as follows:</p>

<pre class="output">
Thread 1: 1
Thread 3: 1
Thread 1: 2
Thread 2: 1
Thread 1: 3
Thread 3: 2
Thread 2: 2
Thread 3: 3
Thread 1: 4
Thread 1: 5
Thread 3: 4
Thread 3: 5
Thread 2: 3
Thread 2: 4
Thread 2: 5</pre>

<p>Take note that the output is indeterminate (different run is likely to produce different output), as we do not have complete control on how the threads would be executed.</p>

<h4>Creating a new Thread by implementing the <span class="font-code">Runnable</span> Interface</h4>

<p>To create and run a new thread by implementing <code>Runnable</code> interface:</p>
<ol>
<li>Define a class that implements the <code>Runnable</code> interface.</li>
<li>In the class, provide implementation to the <code>abstract</code> method <code>run()</code> to specify the thread's operations, (and provide other implementations such as constructors, variables and methods).</li>
<li>A client class creates an instance of this new class.  The instance is called a <code>Runnable</code> object.</li>
<li>The client class then constructs a new <code>Thread</code> object with the <code>Runnable</code> object as argument to the constructor, and invokes the <code>start()</code> method.  The <code>start()</code> called back the <code>run()</code> in the <code>Runnable</code> object (instead of the <code>Thread</code> class).</li>
</ol>

<pre class="color-example">
class MyRunnable extends SomeClass <strong>implements Runnable</strong> {
   <span class="color-comment">// provide implementation to abstract method run()</span>
   @Override
   public void <strong>run</strong>() {
      <span class="color-comment">// Thread's running behavior</span>
   }
   ......
   <span class="color-comment">// constructors, other variables and methods</span>
}</pre>

<pre class="color-example">
public class Client {
   ......
   Thread t = new Thread(new MyRunnable());
   t.start();
   ...
}</pre>

<p>Again, an inner class (named or anonymous) is often used for readability and to provide access to the private variables and methods of the outer class.</p>

<pre class="color-example">
Thread t = new Thread(new Runnable() { <span class="color-comment">// Create an anonymous inner class that implements Runnable interface</span>
   public void run() {
      <span class="color-comment">// Thread's running behavior
      // Can access the private variables and methods of the outer class</span>
   }
});
t.start();</pre>

<h4>Methods in the <span class="font-code">Thread</span> Class</h4>

<p>The methods available in Thread class include:</p>
<ul>

<li><span class="line-heading-color-new">public void start()</span>:  Begin a new thread.  JRE calls back the <code>run()</code> method of this class.  The current thread continues.</li>

<li><span class="line-heading-color-new">public void run()</span>:  to specify the execution flow of the new thread.  When <code>run()</code> completes, the thread terminates.</li>

<li><span class="line-heading-color-new">public <span class="underline">static</span> sleep(long millis) throws InterruptedException<br />
public <span class="underline">static</span> sleep(long millis, int nanos) throws InterruptedException<br />
public void interrupt()<br />
</span>
Suspend the current thread and yield control to other threads for the given milliseconds (plus nanoseconds).  Method <code>sleep()</code> is thread-safe as it does not release its monitors.  You can awaken a sleep thread before the specified timing via a call to the <code>interrupt()</code> method. The awaken thread will throw an <code>InterruptedException</code> and execute its <code>InterruptedException</code> handler before resuming its operation.  This is a <code>static</code> method (which does not require an instance) and commonly used to pause the current thread (via <code>Thread.sleep()</code>) so that the other threads can have a chance to execute.  It also provides the necessary delay in many applications. For example:
<pre class="color-example">
try {
   <span class="color-comment">// Suspend the current thread and give other threads a chance to run
   // Also provide the necessary delay</span>
   Thread.sleep(100);  <span class="color-comment">// milliseconds</span>
} catch (InterruptedException ex) {}</pre></li>

<li><span class="line-heading-color-new">public <span class="underline">static</span> void yield()</span>:  hint to the scheduler that the current thread is willing to yield its current use of a processor to allow other threads to run. The scheduler is, however, free to ignore this hint. Rarely-used.</li>

<li><span class="line-heading-color-new">public boolean isAlive()</span>:  Return <code>false</code> if the thread is new or dead.  Returns <code>true</code> if the thread is &quot;runnable&quot; or &quot;not runnable&quot;.</li>

<li><span class="line-heading-color-new">public void setPriority(int p)</span>:  Set the priority-level of the thread, which is implementation dependent.</li>

</ul>

<p>The <code>stop()</code>, <code>suspend()</code>, and <code>resume()</code> methods have been deprecated in JDK 1.4, because they are not thread-safe, due to the release of monitors.  See JDK API documentation for more discussion.</p>

<h4>Daemon threads</h4>
<p>There are two kinds of threads, <em>daemon threads</em> and <em>user threads</em>.  A daemon thread can be set via the <code>setDaemon(boolean on)</code> method.  A daemon thread is an infrastructure thread, e.g., the garbage collector thread and the GUI's event dispatcher thread. The JVM exits when the only threads running are all daemon threads. In other words, the JVM considers its job done, when there is no more user threads and all the remaining threads are its infrastructure threads.</p>

<p>[@PENDING more] </p>
<h4>The Life Cycle of a Thread</h4>

<img class="image-center" src="images/Multithread_ThreadLifeCycle.png" alt="Multithread_ThreadLifeCycle.png" />

<p>The thread is in the &quot;new&quot; state, once it is constructed.  In this state, it is merely an object in the heap, without any system resources allocated for execution.  From the &quot;new&quot; state, the only thing you can do is to invoke the <code>start()</code> method, which puts the thread into the &quot;runnable&quot; state.  Calling any method besides the <code>start()</code> will trigger an <code>IllegalThreadStateException</code>.</p>

<p>The <code>start()</code> method allocates the system resources necessary to execute the thread, schedules the thread to be run, and calls back the <code>run()</code> once it is scheduled.  This put the thread into the &quot;runnable&quot; state.  However, most computers have a single CPU and <em>time-slice</em> the CPU to support multithreading.  Hence, in the &quot;runnable&quot; state, the thread may be running or waiting for its turn of the CPU time.</p>
<p>A thread cannot be started twice, which triggers a runtime <code>IllegalThreadStateException</code>.</p>

<p>The thread enters the &quot;not-runnable&quot; state when one of these events occurs:</p>
<ol>
<li>The <code>sleep()</code> method is called to suspend the thread for a specified amount of time to yield control to the other threads. You can also invoke the <code>yield()</code> to hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is, however, free to ignore this hint.</li>

<li>The <code>wait()</code> method is called to wait for a specific condition to be satisfied.</li>
<li>The thread is <em>blocked</em> and waiting for an I/O operation to be completed.</li>
</ol>

<p>For the &quot;non-runnable&quot; state, the thread becomes &quot;runnable&quot; again:</p>
<ol>
<li>If the thread was put to sleep, the specified sleep-time expired or the sleep was interrupted via a call to the <code>interrupt()</code> method.</li>
<li>If the thread was put to wait via <code>wait()</code>, its <code>notify()</code> or <code>notifyAll()</code> method was invoked to inform the waiting thread that the specified condition had been fulfilled and the wait was over.</li>
<li>If the thread was blocked for an I/O operation, the I/O operation has been completed.</li>
</ol>

<p>A thread is in a &quot;terminated&quot; state, only when the <code>run()</code> method terminates naturally and exits.</p>

<p>The method <code>isAlive()</code> can be used to test whether the thread is alive. The <code>isAlive()</code> returns <code>false</code> if the thread is &quot;new&quot; or &quot;terminated&quot;.  It returns <code>true</code> if the thread is &quot;runnable&quot; or &quot;not-runnable&quot;.</p>

<p>JDK 1.5 introduces a new <code>getState()</code> method.  This method returns an (nested) <code>enum</code> of type <code>Thread.State</code>, which takes a constant of <code>{NEW, BLOCKED, RUNNABLE, TERMINATED, WAITING}</code>.</p>

<ul>
<li><code>NEW</code>: the thread has not yet started.</li>
<li><code>RUNNABLE</code>: </li>
<li><code>WAITING</code>: </li>
<li><code>BLOCKED</code>: the thread is blocked waiting for a monitor lock.</li>
<li><code>TIMED_WAITING</code>: the thread is waiting with a specified waiting time.</li>
<li><code>TERMINATED</code>:</li>
</ul>

<h3>Thread Scheduling and Priority</h3>
<p>JVM implements a fixed priority thread-scheduling scheme.  Each thread is assigned a priority number (between the <code>Thread.MIN_PRIORITY</code> and <code>Thread.MAX_PRIORITY</code>).  The higher the number, the higher is the priority for the thread.  When a new thread is created, it inherits the priority number from the thread that created it.  You can used the method <code>setPriority()</code> to change the priority number of a thread as follows:</p>

<pre class="color-syntax">
public void setPriority(int priority);</pre>

<p>The <code>int priority</code> is JVM dependent.  It may take a value between 1 (lowest priority) to 10.</p>

<p>JVM chooses the highest-priority thread for execution.  If there is more than one thread with the same highest-priority, JVM schedules them in a round-robin manner.</p>

<p>JVM also implements a preemptive scheduling scheme.  In a preemptive environment, if at any time a higher priority thread becomes &quot;runnable&quot;, the current lower priority thread will yield control to the higher priority thread immediately.</p>

<p>If there are more than one equal-priority runnable threads, one thread may run until the completion without yielding control to other equal-priority threads.  This is known as <em>starvation</em>.  Therefore, it is a good practice to yield control to other equal-priority thread via the <code>sleep()</code> or <code>yield()</code> method.  However, you can never yield control to a lower-priority thread.</p>

<p>In some operating systems such as Windows, each of the running thread is given a specific amount of CPU time.  It is known as time slicing to prevent a thread from starving the other equal-priority threads.  However, do not rely on time slicing, as it is implementation dependent.</p>

<p>Hence, a running thread will continue running until:</p>
<ul>
<li>A higher priority thread becomes &quot;runnable&quot;.</li>
<li>The running thread yields control voluntarily by calling methods such as <code>sleep()</code>, <code>yield()</code>, and <code>wait()</code>.</li>
<li>The running thread terminates, i.e., its <code>run()</code> method exits.</li>
<li>On system that implements time slicing, the running thread consumes its CPU time quota.</li>
</ul>

<p>An important point to note is the thread scheduling and priority is JVM dependent.  This is natural as JVM is a virtual machine and requires the native operating system resources to support multithreading.  Most JVM does not guarantee that the highest-priority thread is being run at all times.  It may choose to dispatch a lower-priority thread for some reasons such as to prevent starvation.  Therefore, you should not rely on the priority in your algorithm.</p>

<h3>Monitor Lock &amp;  Synchronization</h3>
<p>A <code>monitor</code> is an object that can be used to block and revive thread. It is supported in the <code>java.lang.Object</code> root class, via these mechanisms:</p>
<ol>
<li>A lock for each object.</li>
<li>The keyword <code>synchronized</code> for accessing object's lock.</li>
<li>The <code>wait()</code>, <code>notify()</code> and <code>notifyAll()</code> methods in <code>java.lang.Object</code> for controlling threads.</li>
</ol>

<p>Each Java object has a lock. At any time, the lock is controlled by, at most, a single thread. You could mark a method or a block of the codes with keyword <code>synchronized</code>. A thread that wants to execute an object's synchronized code must first attempt to acquire its lock. If the lock is under the control of another thread, then the attempting thread goes into the <em>Seeking Lock</em> state and becomes ready only when the lock becomes available. When a thread that owns a lock completes the synchronized code, it gives up the lock.</p>

<h4>Keyword &quot;<span class="font-code">synchronized</span>&quot;</h4>
<p>For example,</p>
<pre class="color-example">
public synchronized void methodA() { ...... }  <span class="color-comment">// synchronized a method based on this object</span>
 
public void methodB() {
   synchronized(this) {      <span class="color-comment">// synchronized a block of codes based on this object</span>
      ......
   }
 
   synchronized(anObject) {  <span class="color-comment">// synchronized a block of codes based on another object</span>
      ......
   }
   ......
}</pre>

<p>Synchronization can be controlled at method level or block level. Variables cannot be synchronized. You need to synchronized the ALL the methods that access the variables.</p>

<pre class="color-example">
private static int counter = 0;

public static <span class="color-new">synchronized</span> void increment() {
   ++counter;
}

public static <span class="color-new">synchronized</span> void decrement() {
   --counter;
}</pre>

<p>You can also <code>synchronized</code> on <code>static</code> methods. In this case, the <em>class lock</em> (instead of the instance lock) needs to be acquired in order to execute the method.</p>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td>
<pre>
public class SynchronizedCounter {
   private static int count = 0;
 
   public synchronized static void increment() {
      ++count;
      System.out.println(&quot;Count is &quot; + count + &quot; @ &quot; + System.nanoTime());
   }
 
   public synchronized static void decrement() {
      --count;
      System.out.println(&quot;Count is &quot; + count + &quot; @ &quot; + System.nanoTime());
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td>
<pre>
public class TestSynchronizedCounter {
   public static void main(String[] args) {
      Thread threadIncrement = new Thread() {
         @Override
         public void run() {
            for (int i = 0; i &lt; 10; ++i) {
               SynchronizedCounter.increment();
               try {
                  sleep(1);
               } catch (InterruptedException e) {}
            }
         }
      };
 
      Thread threadDecrement = new Thread() {
         @Override
         public void run() {
            for (int i = 0; i &lt; 10; ++i) {
               SynchronizedCounter.decrement();
               try {
                  sleep(1);
               } catch (InterruptedException e) {}
            }
         }
      };
 
      threadIncrement.start();
      threadDecrement.start();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Count is -1 @ 71585106672577
Count is 0 @ 71585107040916
Count is -1 @ 71585107580661
Count is 0 @ 71585107720865
Count is 1 @ 71585108577488
Count is 0 @ 71585108715261
Count is 1 @ 71585109590928
Count is 0 @ 71585111400613
Count is 1 @ 71585111640095
Count is 0 @ 71585112581002
Count is 1 @ 71585112748760
Count is 2 @ 71585113580259
Count is 1 @ 71585113729378
Count is 2 @ 71585114579922
Count is 1 @ 71585114712832
Count is 2 @ 71585115578775
Count is 1 @ 71585115722626
Count is 2 @ 71585116578843
Count is 1 @ 71585116719452
Count is 0 @ 71585117583368</pre>

<p>It is important to note that while the object is locked, <code>synchronized</code> methods and codes are blocked. However, non-<code>synchronized</code> methods can proceed without acquiring the lock.  Hence, it is necessary to synchronize all the methods involved the shared resources.  For example, if <code>synchronized</code> access to a variable is desired, all the methods to that variable should be <code>synchronized</code>.  Otherwise, a non-<code>synchronized</code> method can proceed without first obtaining the lock, which may corrupt the state of the variable.</p>

<h4><span class="font-code">wait()</span>, <span class="font-code">notify()</span> &amp; <span class="font-code">notifyAll()</span> for Inter-Thread Synchronization</h4>
<p>These methods are defined in the <code>java.lang.Object</code> class (instead of <code>java.land.Thread</code> class). These methods can only be called in the <em>synchronous</em> codes.</p>

<p>The <code>wait()</code> and <code>notify()</code> methods provide a way for a shared object to pause a thread when
it becomes unavailable to that thread and to allow the thread to continue when appropriate.</p>

<h5>Example: Consumer and Producer</h5>

<p>In this example, a producer produces a message (via <code>putMessage()</code> method) that is to be consumed by the consumer (via <code>getMessage()</code> method), before it can produce the next message. In a so-called producer-consumer pattern, one thread can suspend itself using <code>wait()</code> (and release the lock) until such time when another thread awaken it using <code>notify()</code> or <code>notifyAll()</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre>
</td>
<td>
<pre>
<span class="color-comment">// Testing wait() and notify()</span>
public class MessageBox {
   private String message;
   private boolean hasMessage;
 
   <span class="color-comment">// producer</span>
   public synchronized void putMessage(String message) {
      while (hasMessage) {
         <span class="color-comment">// no room for new message</span>
         try {
            wait();  <span class="color-comment">// release the lock of this object</span>
         } catch (InterruptedException e) { }
      }
      <span class="color-comment">// acquire the lock and continue</span>
      hasMessage = true;
      this.message = message + &quot; Put @ &quot; + System.nanoTime();
      notify();
   }
 
   <span class="color-comment">// consumer</span>
   public synchronized String getMessage() {
      while (!hasMessage) {
         <span class="color-comment">// no new message</span>
         try {
            wait();  <span class="color-comment">// release the lock of this object</span>
         } catch (InterruptedException e) { }
      }
      <span class="color-comment">// acquire the lock and continue</span>
      hasMessage = false;
      notify();
      return message + &quot; Get @ &quot; + System.nanoTime();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre>
</td>
<td>
<pre>
public class TestMessageBox {
   public static void main(String[] args) {
      final MessageBox box = new MessageBox();
 
      Thread producerThread = new Thread() {
         @Override
         public void run() {
            System.out.println(&quot;Producer thread started...&quot;);
            for (int i = 1; i &lt;= 6; ++i) {
               box.putMessage(&quot;message &quot; + i);
               System.out.println(&quot;Put message &quot; + i);
            }
         }
      };
 
      Thread consumerThread1 = new Thread() {
         @Override
         public void run() {
            System.out.println(&quot;Consumer thread 1 started...&quot;);
            for (int i = 1; i &lt;= 3; ++i) {
               System.out.println(&quot;Consumer thread 1 Get &quot; + box.getMessage());
            }
         }
      };
 
      Thread consumerThread2 = new Thread() {
         @Override
         public void run() {
            System.out.println(&quot;Consumer thread 2 started...&quot;);
            for (int i = 1; i &lt;= 3; ++i) {
               System.out.println(&quot;Consumer thread 2 Get &quot; + box.getMessage());
            }
         }
      };
 
      consumerThread1.start();
      consumerThread2.start();
      producerThread.start();
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<pre class="output">
Consumer thread 1 started...
Producer thread started...
Consumer thread 2 started...
Consumer thread 1 Get message 1 Put @ 70191223637589 Get @ 70191223680947
Put message 1
Put message 2
Consumer thread 2 Get message 2 Put @ 70191224046855 Get @ 70191224064279
Consumer thread 1 Get message 3 Put @ 70191224164772 Get @ 70191224193543
Put message 3
Put message 4
Consumer thread 2 Get message 4 Put @ 70191224647382 Get @ 70191224664401
Put message 5
Consumer thread 2 Get message 5 Put @ 70191224939136 Get @ 70191224965070
Consumer thread 1 Get message 6 Put @ 70191225071236 Get @ 70191225101222
Put message 6</pre>

<p>The output messages (on <code>System.out</code>) may appear out-of-order. But closer inspection on the put/get timestamp confirms the correct sequence of operations.</p>

<p>The <code>synchronized</code> producer method <code>putMessage()</code> acquires the lock of this object, check if the previous message has been cleared.  Otherwise, it calls <code>wait()</code>, releases the lock of this object, goes into <code>WAITING</code> state and places this thread on this object's &quot;wait&quot; set. On the other hand, the <code>synchronized</code> consumer's method <code>getMessage()</code> acquires the lock of this object and checks for new message. If there is a new message, it clears the message and issues <code>notify()</code>, which arbitrarily picks a thread on this object's &quot;wait&quot; set (which happens to be the producer thread in this case) and place it on <code>BLOCKED</code> state. The consumer thread, in turn, goes into the <code>WAITING</code> state and placed itself in the &quot;wait&quot; set of this object (after the <code>wait()</code> method). The producer thread then acquires the thread and continue its operations.</p>

<img class="image-center" src="images/Multithread_Waiting.png" alt="Multithread_Waiting.png" />

<p>The difference between <code>notify()</code> and <code>notifyAll()</code> is <code>notify()</code>  arbitrarily picks a thread from this object's waiting pool and places it on the Seeking-lock state; while <code>notifyAll()</code> awakens all the threads in this object's waiting pool. The awaken threads then compete for execution in the normal manner.</p>

<p>It is interesting to point out that multithreading is built into the Java language right at the root class <code>java.lang.Object</code>. The synchronization lock is kept in the <code>Object</code>.  Methods <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> used for coordinating threads are right in the class <code>Object</code>.</p>

<h5><span class="font-code">wait()</span> with timeout</h5>

<p>There are variations of <code>wait()</code> which takes in a timeout value:</p>
<pre class="color-syntax">
public final void wait() throws InterruptedException
public final void wait(long timeout) throws InterruptedException
public final void wait(long timeout, int nanos) throws InterruptedException</pre>

<p>The thread will ALSO go to <code>BLOCKED</code> state after the timeout expired.</p>
<img class="image-center" src="images/Multithread_TimedWaiting.png" alt="Multithread_TimedWaiting.png" />

<h4>Starvation &amp; Deadlock</h4>
<p><em>Starvation</em> is the state where one (or more) thread is deprived of a chance to access an object. The problem can be resolved by setting the correct priorities to all the threads.</p>

<p>Deadlock refers to the situation where a thread is waiting for a condition, but somewhere else in the program prevented the condition from being fulfilled, thus, prevented the thread from executing. A classical example, known as &quot;deadly embrace&quot; is as follow: 
thread 1 is holding the lock to object A and thread 2 is holding the lock to object B. Thread 1 is waiting to acquire the lock to object B and thread 2 is waiting to acquire the lock to object A. Both threads are in deadlock and cannot proceed. If both threads seek the lock in the same order, the situation will not arise. But it is complex to program this arrangement. Alternatively, you could synchronize on another object, instead of object A and B; or synchronize only a portion of a method instead of the entire method. Deadlock can be complicated which may involves many threads and objects and can be hard to detect.</p>

<h3>Multithreading issues in Swing Applications</h3>

<p><span class="line-heading">References:</span></p>
<ol>
<li>Swing Tutorial's &quot;<a href="http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html">Concurrency in Swing</a>&quot;.</li>
<li>John O'Conner, &quot;Improve Application Performance With SwingWorker in Java SE 6&quot; @ <a href="http://java.sun.com/developer/technicalArticles/javase/swingworker/">http://java.sun.com/developer/technicalArticles/javase/swingworker/</a>.</li>
</ol>

<br />
<p>A Swing application runs on multiple threads. Specifically, It has three types of threads:</p>
<ol>
<li>An initial thread, or the Main thread, which runs the <code>main()</code> method, starts the building of GUI, and exits.</li>
<li>An Event-Dispatching Thread (EDT)</li>
<li>Some Background Worker threads for compute-intensive task and IO.</li>
</ol>

<p>All the event-handling, painting and screen refreshing codes runs in a single thread, called the <em>event-dispatching thread</em>.  This is to ensure that one event handler finishes execution before the next handler starts, and that painting is not interrupted by events.  If the event-dispatching thread is starved by another compute-intensive task, the user interface &quot;freezes&quot;, and the program becomes unresponsive to user interaction. &quot;Ideally, any task that requires more than 30 to 100 milliseconds should not run on the EDT. Otherwise, users will sense a pause between their input and the UI response.&quot;</p>
<p>Furthermore, all codes accessing the GUI components should be run on the event-dispatching thread as many of these components are not guaranteed to be thread-safe. Accessing them from the same thread avoids the multithreading issues.</p>
<p>In summary,</p>

<ol>
<li>Time-consuming and blocking-IO tasks should not be run on the event-dispatching thread, so as not to starve the event-dispatching thread to response to events triggered through user's interaction and repainting the screen.</li>
<li>Swing components should be accessed on the event-dispatching thread only for thread safety.</li></ol>

<h4><span class="font-code">javax.Swing.SwingUtilities.invokeLater()</span> and <span class="font-code">invokeAndWait()</span></h4>


<p>The <code>invokeLater(Runnable)</code> and <code>invokeAndWait(Runnable)</code> methods schedule the <code>Runnable</code> task in the event-dispatching thread.</p>
<p>To avoid threading issues between the main thread (which runs the <code>main()</code> method) and the event-dispatching thread, it is recommended that you use <code>javax.swing.SwingUtilities.invokeLater(Runnable)</code> to create the GUI components on the event-dispatching thread, instead of using the main thread. Recall that Swing components are not guaranteed to be thread-safe and their access shall be confined to a single thread, the EDT. For example,</p>

<pre class="color-example">
<span class="color-comment">/** The entry main() method */</span>
public static void main(String args[]) {
   <span class="color-comment">// Run the GUI codes on the event-dispatching thread for thread-safety</span>
   SwingUtilities.invokeLater(new Runnable() {
      @Override
      public void run() {
         JFrame frame = new JFrame(&quot;My Swing Application&quot;);
         frame.setContentPane(new MyMainPanel());
         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         frame.pack();
         frame.setLocationRelativeTo(null); <span class="color-comment">// center on screen</span>
         frame.setVisible(true);            <span class="color-comment">// show it</span>
      }
   });
}</pre>
<p>The <code>static</code> method <code>SwingUtilities.invokelater()</code> takes a <code>Runnable</code> object (implemented as an anonymous inner class) as its argument, and schedules the task (specified in the <code>run()</code> method) on the event-dispatching thread. You can call <code>invokeLater()</code> from any thread to request the event-dispatching thread to run certain codes, as specified in the <code>run()</code> method of the <code>Runnable</code> argument.  The <code>invokeLater()</code> returns immediately, without waiting for the event-dispatching thread to execute the code.  </p>
<p>If needed, you can use <code>invokeAndWait()</code>, which waits until the event-dispatching thread has executed the specified codes, and returns. For applet, it is recommended to run the GUI construction codes (in <code>init()</code>) via <code>invokeAndWait()</code>. This is  to avoid problems caused by <code>init()</code> exits before the completion of GUI construction. For example,</p>

<pre class="color-example">
public class SwingTemplateJApplet extends JApplet {
   <span class="color-comment">/** init() to setup the GUI components */</span>
   @Override
   public void init() {
      <span class="color-comment">// Run GUI codes in the Event-Dispatching thread for thread safety</span>
      try {
         <span class="color-comment">// Use invokeAndWait() to ensure that init() exits after GUI construction</span>
         SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
               <span class="color-comment">// Set the content-pane of JApplet to an instance of main JPanel</span>
               setContentPane(new SwingTemplateJPanel());
            }
         });
      } catch (Exception ex) {
         ex.printStackTrace();
      }
   }
}</pre>

<p>You can also <code>java.awt.EventQueue.invokeLater()</code> in place of the <code>javax.swing.SwingUtilities.invokeLater()</code>. The <code>javax.swing.SwingUtilities.invokeLater()</code> is just a cover for <code>java.awt.EventQueue.invokeLater()</code>.</p>

<p>The traces in the earlier examples show that if <code>SwingUtilities.invokeLater()</code> is not used, the event-dispatching thread is started after the <code>setVisible()</code> method. On the other hand, the <code>invokerLater()</code> starts the event-dispatching thread.</p>


<h4><span class="font-code">javax.swing.Timer</span> (JDK 1.2)</h4>

<p>If you need to update a component after a certain time delay or at a regular time interval, use a timer class, such as <code>javax.swing.Timer</code> (JDK 1.2) or <code>java.util.Timer</code> (JDK 1.3).</p>
<p>For <code>javax.swing.Timer</code>, read &quot;<a href="J4b_CustomGraphics.html#swingtimer">animation using <code>javax.swing.Timer</code></a>&quot;.</p>
<p>[TODO] <code>java.util.Timer</code> (JDK 1.3)</p>

<h4><span class="font-code">javax.swing.SwingWorker&lt;T,V&gt;</span> (JDK 1.6)</h4>

<p>As mentioned, in a Swing application:</p>
<ol>
<li>Compute-intensive task should not be run on the event-dispatching thread (EDT), so as not to starve the EDT from processing events and repaints.</li>
<li>Swing components shall be accessed in the EDT only for thread safety.</li>
</ol>

<p>The <code>javax.swing.SwingWorkder&lt;T,V&gt;</code> class helps to manage the interaction between the only EDT and several background worker threads. It can be used to schedule a compute-intensive task in a background thread and return the final result or intermediate results in the EDT.</p>

<p>The signature of the <code>SwingWorker</code> class is as follow:</p>

<pre class="color-syntax">
public abstract class <strong>SwingWorker&lt;T,V&gt;</strong> implements RunnableFuture</pre>

<p> <code>SwingWorker&lt;T,V&gt;</code> is an <code>abstract</code> class with two type parameters: where <code>T</code> specifies the <em>final</em> result type of the <code>doInBackground()</code> and <code>get()</code> methods, and <code>V</code> specifies the type of the <em>intermediate</em> results of the <code>publish()</code> and <code>process()</code> methods.</p>
<p>The <code>RunnableFuture</code> interface is the combination of two interfaces: <code>Runnable</code> and <code>Future</code>. The interface <code>Runnable</code> declares an abstract method <code>run()</code>; while <code>Future</code> declares <code>get()</code>, <code>cancel()</code>, <code>isDone()</code>, and <code>isCancelled()</code>.</p>

<h5>Scheduling a Background Task</h5>

<pre class="color-syntax">
protected abstract T <strong>doInBackground</strong>() throws Exception
   <span class="color-comment">// Do this task in a background thread</span>
protected void <strong>done</strong>()
   <span class="color-comment">// Executes on the Event-Dispatching thread after the doInBackground() method finishes.</span>
public final T <strong>get</strong>() throws InterruptedException, ExecutionException
   <span class="color-comment">// Waits for doInBackground() to complete and gets the result.
   // Calling get() on the Event-Dispatching thread blocks all events, including repaints,
   //  until the SwingWorker completes.</span>
public final void <strong>execute</strong>()
   <span class="color-comment">// Schedules this SwingWorker for execution on one of the worker thread.</span>
public final boolean <strong>cancel</strong>(boolean <em>mayInterruptIfRunning</em>)
   <span class="color-comment">// Attempts to cancel execution of this task.</span>
public final boolean <strong>isDone</strong>()
   <span class="color-comment">// Returns true if this task has completed (normally or exception)</span>
public final boolean <strong>isCancelled</strong>()
   <span class="color-comment">// Returns true if this task was cancelled before it completed normally</span></pre>

<p>To schedule a task in a worker thread, extend a subclass of <code>SwingWorker&lt;T,V&gt;</code> (typically an inner class) and override:</p>
<ol>
<li>the <code>doInBackground()</code> to specify the task behavior, which will be scheduled in one of the worker thread and returns a result of type <code>T</code>.</li>
<li>the <code>done()</code> methods, which will be run in the EDT after <code>doInBackground()</code> completes. In <code>done()</code>, use the <code>get()</code> method to retrieve the result of <code>doInBackground()</code> (of the type <code>T</code>).</li>
</ol>

<h5>Example</h5>
<p>This example includes a compute-intensive task into the counter application. The compute-intensive task is scheduled to run in one of the worker thread, and hence will not starve the event-dispatching thread to run the counter and repaints.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import java.util.concurrent.ExecutionException;
import javax.swing.*;
 
<span class="color-comment">/** Test SwingWorker on the counter application with a compute-intensive task */</span>
@SuppressWarnings(&quot;serial&quot;)
public class SwingWorkerCounter extends JPanel {
   <span class="color-comment">// For counter</span>
   private JTextField tfCount;
   private int count = 0;
   <span class="color-comment">// For SwingWorker</span>
   JButton btnStartWorker;   <span class="color-comment">// to start the worker</span>
   private JLabel lblWorker; <span class="color-comment">// for displaying the result</span>
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public SwingWorkerCounter () {
      setLayout(new FlowLayout());
 
      add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      JButton btnCount = new JButton(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">/** Create a SwingWorker instance to run a compute-intensive task 
          Final result is String, no intermediate result (Void) */</span>
      final SwingWorker&lt;String, Void&gt; worker = new SwingWorker&lt;String, Void&gt;() {
         <span class="color-comment">/** Schedule a compute-intensive task in a background thread */</span>
         @Override
         protected String doInBackground() throws Exception {
            <span class="color-comment">// Sum from 1 to a large n</span>
            long sum = 0;
            for (int number = 1; number &lt; 1000000000; ++number) {
               sum += number;
            }
            return sum + &quot;&quot;;
         }
 
         <span class="color-comment">/** Run in event-dispatching thread after doInBackground() completes */</span>
         @Override
         protected void done() {
            try {
               <span class="color-comment">// Use get() to get the result of doInBackground()</span>
               String result = get();
               <span class="color-comment">// Display the result in the label (run in EDT)</span>
               lblWorker.setText(&quot;Result is &quot; + result);
            } catch (InterruptedException e) {
               e.printStackTrace();
            } catch (ExecutionException e) {
               e.printStackTrace();
            }
         }
      };
 
      btnStartWorker = new JButton(&quot;Start Worker&quot;);
      add(btnStartWorker);
      btnStartWorker.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            worker.execute();                 <span class="color-comment">// start the worker thread</span>
            lblWorker.setText(&quot;  Running...&quot;);
            btnStartWorker.setEnabled(false); <span class="color-comment">// Each instance of SwingWorker run once</span>
         }
      });
      lblWorker = new JLabel(&quot;  Not started...&quot;);
      add(lblWorker);
 
   }
 
   <span class="color-comment">/** The entry main() method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(&quot;SwingWorker Test&quot;);
            frame.setContentPane(new SwingWorkerCounter());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(300, 150);
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>A instance of <code>SwingWorker</code> is designed to run only once. You cannot restart the instance. You need to create a new instance for run the task again.</p>

<p><span class="line-heading">More Example:</span> &quot;<code>TumbleItem</code>&quot; demo of the Swing Tutorial.</p>

<h5>Publishing and Processing Intermediate Results</h5>

<p>Other than processing the final result in <code>done()</code>, you can <code>publish()</code> and <code>process()</code> intermediate results as the need arises.</p>

<pre class="color-syntax">
@SafeVarargs
protected final void <strong>publish</strong>(V... <em>chunks</em>)
   <span class="color-comment">// Sends data chunks to the process(java.util.List&lt;V&gt;) method.
   // This method shall be called inside the doInBackground() to deliver intermediate results
   //  for processing on the Event-Dispatching thread inside the process() method.</span>
protected void <strong>process</strong>(List&lt;V&gt; <em>chunks</em>)
   <span class="color-comment">// Receives data chunks from publish() asynchronously on the Event-Dispatching thread.</span></pre>
   
<p>In <code>doInBackground()</code>, use <code>publish(V...)</code> to publish one or more intermediate result(s) of type <code>V</code>. Override the <code>process(List&lt;V&gt;)</code> method to process the results published so far in a <code>List&lt;V&gt;</code>. The <code>process()</code> method runs in the event-dispatching thread.</p>
   
<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import java.util.concurrent.ExecutionException;
import javax.swing.*;
 
<span class="color-comment">/** Test SwingWorker on the counter application with a compute-intensive task */</span>
@SuppressWarnings(&quot;serial&quot;)
public class SwingWorkerCounterIntermediateResult extends JPanel {
   <span class="color-comment">// For counter</span>
   private JTextField tfCount;
   private int count = 0;
   <span class="color-comment">// For SwingWorker</span>
   JButton btnStartWorker;   <span class="color-comment">// to start the worker</span>
   private JLabel lblWorker; <span class="color-comment">// for displaying the result</span>
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public SwingWorkerCounterIntermediateResult () {
      setLayout(new FlowLayout());
 
      add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      JButton btnCount = new JButton(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">/** Create a SwingWorker instance to run a compute-intensive task */</span>
      final SwingWorker&lt;String, String&gt; worker = new SwingWorker&lt;String, String&gt;() {
 
         <span class="color-comment">/** Schedule a compute-intensive task in a background thread */</span>
         @Override
         protected String doInBackground() throws Exception {
            long sum = 0;
            for (int number = 0; number &lt; 10000000; ++number) {
               sum += number;
               <span class="color-new">publish(sum + &quot;&quot;);</span> <span class="color-comment">// Send &quot;every&quot; intermediate result to process()
                                  // You might not publish every intermediate result</span>
            }
            return sum + &quot;&quot;;
         }
 
         <span class="color-comment">/** Run in event-dispatching thread after doInBackground() completes */</span>
         @Override
         protected void done() {
            try {
               <span class="color-comment">// Use get() to get the result of doInBackground()</span>
               String finalResult = get();
               <span class="color-comment">// Display the result in the label (run in EDT)</span>
               lblWorker.setText(&quot;Final Result is &quot; + finalResult);
            } catch (InterruptedException e) {
               e.printStackTrace();
            } catch (ExecutionException e) {
               e.printStackTrace();
            }
         }
 
         <span class="color-comment">/** Run in event-dispatching thread to process intermediate results
              send from publish(). */</span>
         <span class="color-new">@Override
         protected void process(java.util.List&lt;String&gt; chunks) {</span>
            <span class="color-comment">// Get the latest result from the list</span>
            <span class="color-new">String latestResult = chunks.get(chunks.size() - 1);
            lblWorker.setText(&quot;Result is &quot; + latestResult);
         }</span>
      };
 
      btnStartWorker = new JButton(&quot;Start Worker&quot;);
      add(btnStartWorker);
      btnStartWorker.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            worker.execute();  <span class="color-comment">// start the worker thread</span>
            lblWorker.setText(&quot;  Running...&quot;);
            btnStartWorker.setEnabled(false);  <span class="color-comment">// SwingWorker can only run once</span>
         }
      });
      lblWorker = new JLabel(&quot;  Not started...&quot;);
      add(lblWorker);
 
   }
 
   <span class="color-comment">/** The entry main() method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(&quot;SwingWorker Test&quot;);
            frame.setContentPane(new SwingWorkerCounterIntermediateResult());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(300, 150);
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p><span class="line-heading">More Example:</span> &quot;<code>IconDemoApp</code>&quot; demo of Swing Tutorial.</p>

<h5>Property Change Event</h5>

<p>The <code>doInBackground()</code>  fires <code>PropertyChangeEvent</code> to all its <code>PropertyChangeListeners</code> about bound properties changes. There are two bound properties: <code>&quot;state</code>&quot; and &quot;<code>progress</code>&quot;. &quot;<code>state</code>&quot; is defined in the nested <code>enum</code> <code>SwingWorker.StateValue</code>, with value of <code>PENDING</code> (<code>SwingWorker</code> instance created), <code>START</code> (<code>doInBackground</code> started) and <code>DONE</code> (<code>doInBackground</code> completed). &quot;<code>progress</code>&quot; is an <code>int</code>, in the range of 0 to 100. You can change the <code>progress</code> value via <code>setProgress()</code> method inside the <code>doInBackground()</code> to fire a <code>PropertyChangeEvent</code> to all its <code>PropertyChangeListeners</code>.</p>

<h5>Example</h5>
<p>In this example, inside the <code>doInBackground()</code>, we invoke <code>setProgess()</code> to change the <code>progress</code> bound-property value (between 0 to 100), which in turn fires a <code>PropertyChangeEvent</code>. A <code>PropertyChangeListener</code> is defined and registered with this <code>SwingWorker</code>, which shows the <code>progress</code> value on a progress bar. The event-handler runs in the EDT.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.concurrent.ExecutionException;
import javax.swing.*;
 
<span class="color-comment">/** Test SwingWorker on the counter application with a compute-intensive task */</span>
@SuppressWarnings(&quot;serial&quot;)
public class SwingWorkerCounterProgress extends JPanel {
   <span class="color-comment">// For counter</span>
   private JTextField tfCount;
   private int count = 0;
   <span class="color-comment">// For SwingWorker</span>
   JButton btnStartWorker;   <span class="color-comment">// to start the worker</span>
   private JLabel lblWorker; <span class="color-comment">// for displaying the result</span>
   JProgressBar pbWorker;    <span class="color-comment">// progress bar for the worker task</span>
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public SwingWorkerCounterProgress () {
      setLayout(new FlowLayout());
 
      add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      JButton btnCount = new JButton(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">/** Create a SwingWorker instance to run a compute-intensive task */</span>
      final SwingWorker&lt;String, String&gt; worker = new SwingWorker&lt;String, String&gt;() {
 
         <span class="color-comment">/** Schedule a compute-intensive task in a background thread */</span>
         @Override
         protected String doInBackground() throws Exception {
            long sum = 0;
            int maxNumber = 10000000;
            for (int number = 0; number &lt; maxNumber; ++number) {
               sum += number;
               publish(sum + &quot;&quot;); <span class="color-comment">// send intermediate result to process()</span>
               <span class="color-comment">// Fire PropertyChangeEvent for the bound-property &quot;progress&quot;</span>
               <span class="color-new">setProgress(100 * (number + 1) / maxNumber);</span>
            }
            return sum + &quot;&quot;;
         }
 
         <span class="color-comment">/** Run in event-dispatching thread after doInBackground() completes */</span>
         @Override
         protected void done() {
            try {
               <span class="color-comment">// Use get() to get the result of doInBackground()</span>
               String finalResult = get();
               <span class="color-comment">// Display the result in the label (run in EDT)</span>
               lblWorker.setText(&quot;Final Result is &quot; + finalResult);
            } catch (InterruptedException e) {
               e.printStackTrace();
            } catch (ExecutionException e) {
               e.printStackTrace();
            }
         }
 
         <span class="color-comment">/** Run in event-dispatching thread to process intermediate results
              send from publish(). */</span>
         @Override
         protected void process(java.util.List&lt;String&gt; chunks) {
            <span class="color-comment">// Get the latest result from the list</span>
            String latestResult = chunks.get(chunks.size() - 1);
            lblWorker.setText(&quot;Result is &quot; + latestResult);
         }
      };
 
      <span class="color-comment">/** Event handler for the PropertyChangeEvent of property &quot;progress&quot; */</span>
      <span class="color-new">worker.addPropertyChangeListener(new PropertyChangeListener() {
         @Override
         public void propertyChange(PropertyChangeEvent evt) {
            if (evt.getPropertyName().equals(&quot;progress&quot;)) {</span>  <span class="color-comment">// check the property name</span>
               <span class="color-new">pbWorker.setValue((Integer)evt.getNewValue());</span>  <span class="color-comment">// update progress bar</span>
            <span class="color-new">}
         }
      });</span>
 
      btnStartWorker = new JButton(&quot;Start Worker&quot;);
      add(btnStartWorker);
      btnStartWorker.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            worker.execute();  <span class="color-comment">// start the worker thread</span>
            lblWorker.setText(&quot;  Running...&quot;);
            btnStartWorker.setEnabled(false);  <span class="color-comment">// SwingWorker can only run once</span>
         }
      });
      lblWorker = new JLabel(&quot;  Not started...&quot;);
      add(lblWorker);
      pbWorker = new JProgressBar();
      add(pbWorker);
   }
 
   <span class="color-comment">/** The entry main() method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(&quot;SwingWorker Test&quot;);
            frame.setContentPane(new SwingWorkerCounterProgress());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(300, 150);
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<h4>Summary</h4>

<p>Threads are essential to build a responsive graphical user interface.  These are the typical situations where a new thread should be used:</p>
<ul>
<li>To fork out a new thread for a time-consuming initialization task (such as disk I/O) in the main thread, so that the GUI comes up faster.</li>
<li>To fork out a new thread for a time-consuming task (within an event handler) in the event dispatch thread, so that the GUI remains responsive.</li>
<li>Use timer for a repetitive task, which runs at regular time interval or after a certain time delay.</li>
<li>To fork out a new thread if the operations need to wait for a message from another thread or program.</li>
</ul>
<p>In addition, the compute-intensive threads must be co-operative and yield control to others.</p>

<h3>Thread Pool, Executor, Callable/Future (JDK 1.5)</h3>

<p>The thread pool supporting classes are introduced in package <code>java.lang.concurrent</code>, in JDK 1.5.</p>

<img class="image-center" src="images/Multithread_ThreadPool.gif" alt="Multithread_ThreadPool.gif" />

<h4>Thread Pool</h4>
<p>A <em>thread pool</em> is a managed collection of threads that are available to execute tasks.  When a large number of tasks is executed using a thread pool, the performance improves as the threads are re-cycled to execute the tasks, which reduces the per-task invocation overhead.</p>

<p>To use a thread pool, you can use an implementation of the interface <code>ExecutorService</code>, such as <code>ThreadPoolExecutor</code> or <code>ScheduledThreadPoolExecutor</code>.  However, more convenient factory methods are provided in the <code>Executors</code> class as follows:</p>
<ul>
<li><code>Executors.newSingleThreadExecutor()</code>: creates a single background thread.</li>
<li><code>Executors.newFixedThreadPool(int numThreads)</code>: creates a fixed size thread pool.</li>
<li><code>Executors.newCachedThreadPool()</code>: create a unbounded thread pool, with automatic thread reclamation.</li>
</ul>

<p>The steps of using thread pool are:</p>
<ol>
<li>Write you worker thread class which implements <code>Runnable</code> interface.  The <code>run()</code> method specifies the behavior of the running thread.</li>
<li>Create a thread pool (<code>ExecutorService</code>) using one the factory methods provided by the <code>Executors</code> class.  The thread pool could have a single thread, a fixed number of threads, or an unbounded number of threads.</li>
<li>Create instances of your worker thread class.  Use <code>execute(Runnable r)</code> method of the thread pool to add a <code>Runnable</code> task into the thread pool.  The task will be scheduled and executes if there is an available thread in the pool.</li>
</ol>

<h4>Interface <span class="font-code">java.util.concurrent.Executor</span></h4>

<p>An <code>Executor</code> object can execute <code>Runnable</code> tasks submitted.  The interface declares an <code>abstract</code> method:</p>
<pre class="color-syntax">
public void execute(Runnable r)
</pre>

<p>It executes the given task at some time in the future.  The task may be executed in a new thread, in a thread pool, or in the calling thread, depending on the implementation of <code>Executor</code> (e.g. single thread or thread pool)</p>

<h4>Interface <span class="font-code">java.util.concurrent.ExecutorService</span></h4>
<p>Interface <code>ExecutorService</code> declares many <code>abstract</code> methods.  The important ones are:</p>

<pre class="color-syntax">
public void shutdown();
   <span class="color-comment">// Initiates an orderly shutdown of the thread pool.
   // The previously executed/submitted tasks are allowed to complete,
   // but no new tasks will be scheduled.</span>
public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
   <span class="color-comment">// Submit or schedule the callable task for execution, which returns a Future object.</span>
</pre>

<h4>Class <span class="font-code">java.util.concurrent.Executors</span></h4>
<p>The class <code>Executors</code> provides factory methods for creating <code>Executor</code> object.  For example:</p>

<pre class="color-syntax">
static ExecutorService newSingleThreadExecutor()
static ExecutorService newFixedThreadPool(int nThreads)
static ExecutorService newCachedThreadPool()
static ScheduledExecutorService newSingleThreadScheduledExecutor()
static ScheduledExecutorService newScheduledThreadPool(int size)
</pre>

<h5>Example</h5>

<pre class="color-example">
public class WorkerThread implements Runnable {
   private int workerNumber;

   WorkerThread(int workerNumber) {
      this.workerNumber = workerNumber;
   }

   public void run() {
      <span class="color-comment">// The thread simply prints 1 to 5</span>
      for (int i = 1; i &lt;= 5; ++i) {
         System.out.printf(&quot;Worker %d: %d\n&quot;, workerNumber, i);
         try {
            <span class="color-comment">// sleep for 0 to 0.5 second</span>
            Thread.sleep((int)(Math.random() * 500));
         } catch (InterruptedException e) {}
      }
   }
}
</pre>

<pre class="color-example">
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolTest {
   public static void main(String[] args) {
      int numWorkers = Integer.parseInt(args[0]);
      int threadPoolSize = Integer.parseInt(args[1]);

      ExecutorService pool = 
            Executors.newFixedThreadPool(threadPoolSize);
      WorkerThread[] workers = new WorkerThread[numWorkers];
      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new WorkerThread(i+1);
         pool.execute(workers[i]);
      }
      pool.shutdown();
   }
}
</pre>


<pre class="output">
<span class="color-comment">//2 threads, 5 workers</span>
&gt; java ThreadPoolTest 5 2
Worker 1: 1
Worker 2: 1
Worker 1: 2
Worker 1: 3
Worker 2: 2
Worker 1: 4
Worker 2: 3
Worker 1: 5
Worker 3: 1
Worker 3: 2
Worker 2: 4
Worker 3: 3
Worker 2: 5
Worker 3: 4
Worker 3: 5
Worker 4: 1
Worker 4: 2
Worker 5: 1
Worker 4: 3
Worker 5: 2
Worker 5: 3
Worker 4: 4
Worker 5: 4
Worker 5: 5
Worker 4: 5</pre>

<p>Worker 1 and 2 were first scheduled for execution using the 2 threads in the pool, followed by worker 3, 4 and 5.  After the task using the thread completes, the thread is returned to the pool.  Another task can then be scheduled and begin execution.</p>

<p>You can use <code>pool.shutdown()</code> to shutdown all the threads in the pool.</p>

<h4>Interface <span class="font-code">java.util.concurrent.Callable&lt;V&gt;</span> and <span class="font-code">Future&lt;V&gt;</span></h4>

<p>A <code>Callable</code> is similar to a <code>Runnable</code>.  However, <code>Callable</code> provides a way to return a result or <code>Exception</code> to the thread that spin this <code>Callable</code>.  <code>Callable</code> declares an <code>abstract</code> method <code>call()</code> (instead of <code>run()</code> in the <code>Runnable</code>).</p>

<pre class="color-syntax">
public V call()
   <span class="color-comment">// Call() returns a result of type &lt;V&gt;, or throws an exception if unable to do so.</span>
</pre>

<p>In the thread pool, instead of using <code>execute(Runnable r)</code>, you use <code>submit(Callable r)</code>, which returns a <code>Future&lt;V&gt;</code> object (declared in the <code>ExecutorService</code> interface).  When the result is required, you can retrieve using <code>get()</code> method on the <code>Future</code> object.  If the result is ready, it is returned, otherwise, the calling thread is blocked until the result is available.</p>

<p>The interface <code>Future&lt;V&gt;</code> declares the following <code>abstract</code> methods:</p>
<pre class="color-syntax">
V get()           <span class="color-comment">// wait if necessary, retrieve result</span>
V get(long timeout, TimeUnit unit)
boolean cancel(boolean mayInterruptIfRunning)
boolean isCancelled()
boolean isDone()  <span class="color-comment">// return true if this task completed</span>
</pre>

<h5>Example</h5>

<pre class="color-example">
import java.util.concurrent.Callable;

public class CallableWorkerThread implements Callable&lt;String&gt; {
   private int workerNumber;

   CallableWorkerThread(int workerNumber) {
      this.workerNumber = workerNumber;
   }

   public String call() {    <span class="color-comment">// use call() instead of run()</span>
      for (int i = 1; i &lt;= 5; ++i) {    <span class="color-comment">// just print 1 to 5</span>
         System.out.printf(&quot;Worker %d: %d\n&quot;, workerNumber, i);
         try {
            Thread.sleep((int)(Math.random() * 1000));
         } catch (InterruptedException e) {}
      }
      return &quot;worker &quot; + workerNumber;
   }
}
</pre>

<pre class="color-example">
import java.util.concurrent.*;

public class CallableThreadPoolTest {
   public static void main(String[] args) {
      int numWorkers = Integer.parseInt(args[0]);

      ExecutorService pool = Executors.newCachedThreadPool();
      CallableWorkerThread workers[] = new CallableWorkerThread[numWorkers];
      Future[] futures = new Future[numWorkers];

      for (int i = 0; i &lt; numWorkers; ++i) {
         workers[i] = new CallableWorkerThread(i + 1);
         futures[i] = pool.submit(workers[i]);
      }
      for (int i = 0; i &lt; numWorkers; ++i) {
         try {
            System.out.println(futures[i].get() + &quot; ended&quot;);
         } catch (InterruptedException ex) {
            ex.printStackTrace();
         } catch (ExecutionException ex) {
            ex.printStackTrace();
         }
      }
   }
}
</pre>

<p>Output with 3 workers, unbound number of threads is as follows:</p>
<pre class="output">
&gt; java CallableThreadPoolTest 3
Worker 1: 1
Worker 3: 1
Worker 2: 1
Worker 3: 2
Worker 1: 2
Worker 2: 2
Worker 2: 3
Worker 2: 4
Worker 2: 5
Worker 1: 3
Worker 3: 3
Worker 3: 4
Worker 3: 5
Worker 1: 4
Worker 1: 5
worker 1 ended
worker 2 ended
worker 3 ended</pre>

<h4>Other New Thread Features in JDK 1.5</h4>
<ul>
<li>Lock</li>
<li>ReadWriteLock</li>
<li>Semaphores</li>
<li>Atomics</li>
<li>Blocking Queue</li>
</ul>

<p>[TODO]</p>

<a class="references" href="../howto/References.html#java">LINK TO JAVA REFERENCES &amp; RESOURCES</a>

<p class="references">MORE REFERENCES &amp; RESOURCES</p>
<ol>
<li>Swing Tutorial's &quot;<a href="http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html">Concurrency in Swing</a>&quot;.</li>
<li>John O'Conner, &quot;Improve Application Performance With SwingWorker in Java SE 6&quot; @ <a href="http://java.sun.com/developer/technicalArticles/javase/swingworker/">http://java.sun.com/developer/technicalArticles/javase/swingworker/</a>.</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 1.7<br />
Last modified: April, 2012</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
