<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Java Basics - Java Programming Tutorial</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Java Basics</h2>
</div>

<div id="content-main">

<p>This chapter explains the basic syntaxes of the Java programming language. I shall assume that you could write some simple Java programs. (Otherwise, read &quot;<a href="J1a_Introduction.html">Introduction To Java Programming for First-time Programmers</a>&quot;.)</p>

<p>To be a proficient programmer, you need to master two things: (1) the syntax of the programming language, and (2) the <acronym title="Application Program Interface">API</acronym> libraries associated with the language.</p>

<p>You may also try the &quot;<a href="J2a_BasicsExercises.html">Exercises on Java Basics</a>&quot;.</p>


<h3>Basic Syntaxes</h3>

<h4>Revision</h4>

<p>The steps in writing a Java program is illustrated as follows:</p>
<img class="image-center" src="images/JavaBasics_Process.png" alt="JavaBasics_Process.png" />

<p><span class="line-heading">Step 1:</span> Write the source codes (<code>.java</code>) using a programming text editor (such as Notepad++, Textpad, gEdit) or an <acronym title="Integrated Development Environment">IDE</acronym> (such as Eclipse or NetBeans).</p>

<p><span class="line-heading">Step 2:</span> Compile the source codes (<code>.java</code>) into Java portable bytecode (<code>.class</code>) using the JDK compiler (&quot;<code>javac</code>&quot;).</p>

<p><span class="line-heading">Step 3:</span> Run the compiled bytecode (<code>.class</code>) with the input to produce the desired output, using the Java Runtime (&quot;<code>java</code>&quot;).</p>

<p class="float-clear">Below is a simple Java program that demonstrates the three basic programming constructs: <em>sequential</em>, <em>loop</em>, and <em>conditional</em>. Read &quot;<a href="J1a_Introduction.html">Introduction To Java Programming for First-time Programmers</a>&quot; if you need help in understanding this program.</p>
 
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Sum the odd numbers and the even numbers from a lowerbound to an upperbound
 */</span>
public class <strong>OddEvenSum</strong> {  <span class="color-comment">// Save as &quot;OddEvenSum.java&quot;</span>
   public static void main(String[] args) {
      int lowerbound = 1, upperbound = 1000;
      int sumOdd  = 0;    <span class="color-comment">// For accumulating odd numbers, init to 0</span>
      int sumEven = 0;    <span class="color-comment">// For accumulating even numbers, init to 0</span>
      int number = lowerbound;
      while (number &lt;= upperbound) {
         if (number % 2 == 0) {  <span class="color-comment">// Even</span>
            sumEven += number;   <span class="color-comment">// Same as sumEven = sumEven + number</span>
         } else {                <span class="color-comment">// Odd</span>
            sumOdd += number;    <span class="color-comment">// Same as sumOdd = sumOdd + number</span>
         }
         ++number;  <span class="color-comment">// Next number</span>
      } 
      <span class="color-comment">// Print the result</span>
      System.out.println(&quot;The sum of odd numbers from &quot; + lowerbound + &quot; to &quot; + upperbound + &quot; is &quot; + sumOdd);
      System.out.println(&quot;The sum of even numbers from &quot; + lowerbound + &quot; to &quot; + upperbound + &quot;  is &quot; + sumEven);
      System.out.println(&quot;The difference between the two sums is &quot; + (sumOdd - sumEven));
   }
}</pre></td>
</tr>
</tbody>
</table>

<p>The expected outputs are:</p>
<pre class="output">The sum of odd numbers from 1 to 1000 is 250000
The sum of even numbers from 1 to 1000  is 250500
The difference between the two sums is -500</pre>

<h4>Comments</h4>
<p>Comments are used to document and explain your codes and your program logic.  Comments are not programming statements. They are  ignored by the compiler and have no consequences to the program execution. Nevertheless, comments are VERY IMPORTANT for providing documentation and explanation for others to understand your programs (and also for yourself three days later).</p>

<p>There are two kinds of comments in Java:</p>
<ol>
<li><em>Multi-Line Comment</em>: begins with a <code>/*</code> and ends with a <code>*/</code>, and can span multiple lines.</li>
<li><em>End-of-Line (Single-Line) Comment</em>: begins with <code>//</code> and lasts till the end of the current line.</li>
</ol>

<p>I recommend that you use comments <em>liberally</em> to explain and document your codes.  During program development, instead of deleting a chunk of statements irrevocably, you could <em>comment-out</em> these statements so that you could get them back later, if needed.</p>

<h4>Statements and Blocks</h4>

<p><span class="line-heading">Statement</span>: A programming <em>statement</em> is the smallest independent unit in a program, just like a sentence in the English language. It performs <em>a piece of programming action</em>. A programming statement must be terminated by a semi-colon (<code>;</code>), just like an English sentence ends with a period. (Why not ends with a period like an English sentence? This is because period crashes with decimal point - it is hard for the dumb computer to differentiate between period and decimal point in the early days of computing!)</p>

<p>For examples,</p>

<pre class="color-example">
<span class="color-comment">// Each of the following lines is a programming statement, which ends with a semi-colon (;)</span>
int number1 = 10;
int number2, number3=99;
int product;
product = number1 * number2 * number3;
System.out.println(&quot;Hello&quot;);
</pre>

<p><span class="line-heading">Block</span>: A <em>block</em> is a group of  statements surrounded by a pair of curly braces <code>{ }</code>. All the statements inside the block is treated as one single unit. Blocks are used as the <em>body</em> in constructs like class, method, if-else and for-loop, which may contain multiple statements but are treated as one unit (one body). There is no need to put a semi-colon after the closing brace to end a compound statement. Empty block (i.e., no statement inside the braces) is permitted. For examples,</p>

<pre class="color-example">
<span class="color-comment">// Each of the followings is a &quot;complex&quot; statement comprising one or more blocks of statements.
// No terminating semi-colon needed after the closing brace to end the &quot;complex&quot; statement.
// Take note that a &quot;complex&quot; statement is usually written over a few lines for readability.</span>
if (mark &gt;= 50) {
   System.out.println(&quot;PASS&quot;);
   System.out.println(&quot;Well Done!&quot;);
   System.out.println(&quot;Keep it Up!&quot;);
}
 
if (number == 88) {
   System.out.println(&quot;Got it!&quot;); 
} else { 
   System.out.println(&quot;Try Again!&quot;); 
}
 
i = 1;
while (i &lt; 8) {
   System.out.print(i + &quot; &quot;);
   ++i; 
}
 
public static void main(String[] args) {
   ...<em>statements...</em> 
}</pre>

<h4>White Spaces and Formatting Source Codes</h4>
<p><span class="line-heading">White Spaces</span>: <em>Blank</em>, <em>tab</em> and <em>newline</em> are collectively called <em>white spaces</em>. Java, like most of the computing languages, ignores <em>extra</em> white spaces.  That is, multiple contiguous white spaces are treated as a <em>single</em> white space.</p>
<p>You need to use a white space to separate two keywords or tokens to avoid ambiguity, e.g.,</p>
<pre class="color-example">
int sum=0;       <span class="color-comment">// Cannot write intsum=0. Need at least one white space between &quot;int&quot; and &quot;sum&quot;</span>
double average;  <span class="color-comment">// Again, need at least a white space between &quot;double&quot; and &quot;average&quot;</span></pre>
<p>Additional white spaces and extra lines are, however, ignored, e.g.,</p>
<pre class="color-example">
<span class="color-comment">// same as above</span>
int  sum 
 =  0      ;

   double  average  ;</pre>

<p><span class="line-heading">Formatting Source Codes</span>: As mentioned, extra white spaces are ignored and have no computational significance. However, proper indentation (with tabs and  blanks) and extra empty lines greatly improves the readability of the program. This is extremely important for others (and yourself three days later) to understand your programs. </p>

<p>For example, the following one-line hello-world program works. But can you read and understand the program?</p>

<pre class="color-example">
public class Hello{public static void main(String[] args){System.out.println(&quot;Hello, world!&quot;);}}
</pre>

<p><span class="line-heading">Braces</span>: Java's convention is to place the beginning brace at the end of the line, and align the ending brace with the start of the statement.</p>

<p><span class="line-heading">Indentation</span>: Indent each <em>level</em> of the body of a block by an extra 3 (or 4) spaces.</p>


<pre class="color-example">
<span class="color-comment">/*
 * Recommended Java programming style
 */</span>
public class <em><strong>ClassName</strong></em> {      <span class="color-comment">// Place the beginning brace at the end of the current line</span>
   public static void main(String[] args) {  <span class="color-comment">// Indent the body by an extra 3 or 4 spaces for each level</span>
   
      <span class="color-comment">// Use empty line liberally to improve readability</span>
      <span class="color-comment">// Sequential statements</span>
      <em>statement</em>;
      <em>statement</em>;
   
      <span class="color-comment">// Conditional statement</span>
      if (<em>test</em>) {
         <em>statements</em>;
      } else {
         <em>statements</em>;
      }
      
      <span class="color-comment">// loop</span>
      <em>init</em>;
      while (<em>test</em>) {
         <em>statements</em>;
         <em>update</em>;
      }
   }
}   <span class="color-comment">// ending brace aligned with the start of the statement</span></pre>


<h3>Variables and Types</h3>

<h4>Variables</h4>

<p>Computer programs manipulate (or process) data. A <em>variable</em> is used to <em>store a piece of data</em> for processing. It is called <em>variable</em> because you can change the value stored.</p>

<p>More precisely, a <em>variable</em> is a <em>named</em> storage location, that stores a <em>value</em> of a particular data <em>type</em>. In other words, a <em>variable</em> has a <em>name</em>, a <em>type</em> and stores a <em>value</em>.</p>

<ul>

<li>A variable has a <em>name</em> (aka <em>identifier</em>), e.g., <code>radius</code>, <code>area</code>, <code>age</code>, and <code>height</code>. The name is needed to uniquely identify each variable, so as to assign a value to the variable (e.g., <code>radius=1.2</code>), as well as to retrieve the value stored (e.g., <code>radius*radius*3.1419265</code>).</li>

<li>A variable has a <em>type</em>. Examples of Java <em>type</em> are:
  <ul>
<li><code>int</code>: meant for integers (whole numbers) such as <code>123</code> and <code>-456</code>.</li>

<li><code>double</code>: meant for floating-point (real numbers), such as <code>3.1416</code>, <code>-55.66</code>, <code>1.2e3</code>, <code>-4.5E-6</code>, having a optional decimal point and fractional part.</li>

<li><code>String</code>: meant for texts such as <code>&quot;Hello&quot;</code>, <code>&quot;Good Morning!&quot;</code>. Strings are enclosed within a pair of double quotes.</li>

<li><code>char</code>: meant for a single character, such as <code>'a'</code>, <code>'8'</code>. A char is enclosed by a pair of single quotes.</li>
</ul></li>

<li>A variable can store a <em>value</em> of that particular data <em>type</em>. It is important to take note that a variable in most programming languages is associated with a type, and can only store value of the particular type. For example, a <code>int</code> variable can store an integer value such as <code>123</code>, but NOT real number such as <code>12.34</code>, nor string such as <code>&quot;Hello&quot;</code>.</li>

<li>The concept of <em>type</em> was introduced in the early programming languages to simplify interpretation of data made up of binary numbers (<code>0</code>'s and <code>1</code>'s). The type determines the size and layout of the data, the range of its values, and the set of operations that can be applied.</li>
</ul>

<p>The following diagram illustrates three types of variables: <code>int</code>, <code>double</code> and <code>String</code>. An <code>int</code> variable stores an integer (or whole number or fixed-point number); a <code>double</code> variable stores a floating-point number or real number; a <code>String</code> variable stores texts.</p>

<img class="image-center" src="images/JavaBasics_Variable.png" alt="variable" />

<h4>Identifiers (or Names)</h4>

<p>An <em>identifier</em> is needed to <em>name</em> a variable (or any other entity such as a method or a class). Java imposes the following <em>rules on identifiers</em>:</p>

<ul>
<li>An identifier is a sequence of characters, of any length, comprising uppercase and lowercase letters <code>(a-z, A-Z)</code>, digits <code>(0-9)</code>, underscore <code>&quot;_&quot;</code>, and dollar sign <code>&quot;$&quot;</code>.</li>

<li>White space (blank, tab, newline) and other special characters (such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,  <code>@</code>, <code>&amp;</code>, commas, etc.) are not allowed. Take note that blank and dash (<code>-</code>) are not allowed, i.e., &quot;<code>max value</code>&quot; and &quot;<code>max-value</code>&quot; are not valid names. (This is because blank creates two tokens and dash crashes with minus sign!)</li>

<li>An identifier must begin with a letter  <code>(a-z, A-Z)</code> or underscore (<code>_</code>). It cannot begin with a digit <code>(0-9)</code> (because that could confuse with a number). Identifiers begin with dollar sign (<code>$</code>) are reserved for system-generated entities.</li>

<li>An identifier cannot be a reserved keyword or a reserved literal (e.g., <code>class</code>, <code>int</code>, <code>double</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>true</code>, <code>false</code>, <code>null</code>).</li>

<li>Identifiers are case-sensitive. A <code>rose</code> is NOT a <code>Rose</code>, and is NOT a <code>ROSE</code>.</li>
</ul>

<p><span class="line-heading color-error">Caution</span>: Programmers don't use <em>blank</em> character in names. It is either not supported (e.g., in Java and C/C++), or will pose you many more challenges.</p>

<h5>Variable Naming Convention</h5>

<p>A variable name is a noun, or a noun phrase made up of several  words with no spaces between words. The first word is in lowercase, while the remaining words are initial-capitalized. For example, <code>thefontSize</code>, <code>roomNumber</code>, <code>xMax</code>, <code>yMin</code>,  <code>xTopLeft</code> and <code>thisIsAVeryLongVariableName</code>. This convention is also known as <em>camel-case</em>.</p>

<h5>Recommendations</h5>

<ol>
<li>It is important to choose a name that is <em>self-descriptive</em> and closely reflects the meaning of the variable, e.g., <code>numberOfStudents</code> or <code>numStudents</code>, but not <code>n</code> or <code>x</code>, to store the number of students. It is okay to use long names!</li>

<li>Do not use <em>meaningless</em> names like <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>i</code>, <code>j</code>, <code>k</code>, <code>i1</code>, <code>j99</code>.</li>

<li>Avoid <em>single-letter</em> names like <code>i</code>, <code>j</code>, <code>k</code>, <code>a</code>, <code>b</code>, <code>c</code>, which is easier to type but often meaningless. Exception are common names like <code>x</code>, <code>y</code>, <code>z</code> for coordinates, <code>i</code> for index. Long names are harder to type, but self-document your program. (I suggest you spend sometimes practicing your typing.)</li>

<li>Use <em>singular</em> and <em>plural</em> nouns  prudently to differentiate between singular and plural variables.  For example, you may use the variable <code>row</code> to refer to a single row number and the variable <code>rows</code>  to refer to many rows (such as an array of rows - to be discussed later).</li>
</ol>

<h4>Variable Declaration</h4>

<p>To use a variable in your program, you need to first &quot;introduce&quot; it by <em>declaring</em> its <em>name</em> and <em>type</em>, in one of the following syntaxes. The act of declaring a variable allocates a storage (of size capable of holding a value of the type).</p>

<table class="table-program">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>
<tr>
<td>
<pre class="color-syntax"><span class="color-comment">// Declare a variable of a specified type</span>
<em>type identifier</em><strong>;</strong>
<span class="color-comment">// Declare multiple variables of the same type, separated by commas</span>
<em>type identifier1</em><strong>,</strong> <em>identifier2</em><strong>,</strong> ...<strong>,</strong> <em>identifierN</em><strong>;</strong>
<span class="color-comment">// Declare a variable and assign an initial value</span>
<em>type identifier</em> <strong>=</strong> <em>initialValue</em><strong>;</strong>
<span class="color-comment">// Declare multiple variables with initial values</span>
<em>type identifier1</em> <strong>=</strong> <em>initValue1</em><strong>,</strong> ...<strong>,</strong> <em>identifierN</em> <strong>=</strong> <em>initValueN</em><strong>;</strong>
</pre>
</td>
<td>
<pre class="color-explanation">&nbsp;
int option;
&nbsp;
double sum, difference, product, quotient;
&nbsp;
int magicNumber = 88;
&nbsp;
String greetingMsg = &quot;Hi!&quot;, quitMsg = &quot;Bye!&quot;;
</pre>
</td>
</tr>
</table>

<p>Take note that:</p>

<ul>
<li>Java is a &quot;strongly type&quot; language. A variable is declared with a  <em>type</em>. Once the <em>type</em> of a variable is declared, it can only store a value belonging to this particular type. For example, an <code>int</code> variable can hold only integer such as <code>123</code>, and NOT floating-point number such as <code>-2.17</code> or text string such as <code>&quot;Hello&quot;</code>.</li>

<li>Each variable can only be declared once.</li>

<li>You can declare a variable anywhere inside the program, as long as it is declared before used.</li>

<li> The type of a variable cannot be changed inside the program, after it is declared.</li>
<li>A variable declaration statement begins with a <em>type</em>, and works for only that type. In other words, you cannot declare variables of two different type in a single declaration statement.</li>
</ul>

<h4>Constants (<span class="font-code">final</span> Variables)</h4>

<p>Constants are <em>non-modifiable</em> variables, declared with keyword <code>final</code>. Their values cannot be changed during program execution. Also,  constants must be initialized during declaration. For examples:</p>
<pre class="color-example">
<strong>final</strong> double PI = 3.1415926;  <span class="color-comment">// Need to initialize</span></pre>

<p><span class="line-heading">Constant Naming Convention:</span> Use uppercase words, joined with underscore. For example, <code>MIN_VALUE</code>, <code>MAX_SIZE</code>.</p>

<h4>Expressions</h4>

<p>An <em>expression</em> is a combination of <em>operators</em> (such as addition <code>'+'</code>, subtraction <code>'-'</code>, multiplication <code>'*'</code>, division <code>'/'</code>) and <em>operands</em> (variables or literals), that can be <em>evaluated to yield a single value of a certain type</em>. For example,</p>

<pre class="color-example">
<span class="color-comment"></span>1 + 2 * 3           <span class="color-comment">// evaluated to int 7</span>
 
int sum, number;
sum + number        <span class="color-comment">// evaluated to an int value</span>
 
double principal, interestRate;
principal * (1 + interestRate)  <span class="color-comment">// Evaluated to a double value</span></pre>

<h4>Assignment</h4>

<p>An <em>assignment statement</em>:</p>

<ol>
<li>assigns a literal value (of the <acronym title="Right-Hand Sdie">RHS</acronym>) to a variable (of the <acronym title="Left-Hand Sdie">LHS</acronym>), e.g., <code>x = 1</code>; or</li>

<li>evaluates an expression (of the RHS) and assign the resultant value to a variable (of the LHS), e.g., <code>x = (y + z) / 2</code>.</li>
</ol>

<p>The syntax for assignment statement is:</p>

<table class="table-program">
<col style="width:60%" />
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>
<tr>
<td>
<pre class="color-syntax"><span class="color-comment">// Assign the literal value (of the RHS) to the variable (of the LHS)</span>
<em>variable</em> <strong>=</strong> <em>literalValue</em><strong>;</strong>
<span class="color-comment">// Evaluate the expression (RHS) and assign the result to the variable (LHS)</span>
<em>variable</em> <strong>=</strong> <em>expression</em><strong>;</strong></pre>
</td>
<td>
<pre class="color-explanation">&nbsp;
number = 88;
&nbsp;
sum = sum + number;</pre>
</td>
</tr>
</table>

<p>The assignment statement should be interpreted this way: The <em>expression</em> on the right-hand-side (RHS) is first evaluated to produce a resultant value (called <em>r-value</em> or right-value). The <em>r-value</em> is then assigned to the variable on the left-hand-side (LHS) or <em>l-value</em>. Take note that you have to first evaluate the RHS, before assigning the resultant value to the LHS. For examples,</p>

<pre class="color-example">
number = 8;           <span class="color-comment">// Assign literal value of 8 to the variable number</span>
number = number + 1;  <span class="color-comment">// Evaluate the expression of number + 1,
                      //  and assign the resultant value back to the variable number</span>
8 = number;           <span class="color-error">// INVALID</span>
number + 1 = sum;     <span class="color-error">// INVALID</span></pre>

<p>In Java, the equal symbol <code>'='</code> is known as the <em>assignment operator</em>. The meaning of <code>'='</code> in programming is different from Mathematics. It denotes <em>assignment of the LHS value to the RHS variable</em>, instead of <em>equality of the RHS and LHS</em>. The RHS shall be a literal value or an expression that evaluates to a value; while the LHS must be a variable. </p>

<p>Note that <code>x = x + 1</code> is valid (and often used) in programming. It evaluates <code>x + 1</code> and assign the resultant value to the variable <code>x</code>. <code>x = x + 1</code> illegal in Mathematics.</p>
<p> While <code>x + y = 1</code> is allowed in Mathematics, it is invalid in programming (because the LHS of an assignment statement must be a variable).</p>
<p> Some programming languages use symbol &quot;<code>:=</code>&quot;,  &quot;<code>-&gt;</code>&quot; or &quot;<code>&lt;-</code>&quot; as the assignment operator to avoid confusion with equality.</p>

<h4>Primitive Types</h4>

<p>In Java, there are two broad categories of <em>types</em>: <em>primitive types</em> (e.g., <code>int</code>, <code>double</code>) and <em>reference types</em> (e.g., objects and arrays<em>)</em>. We shall describe the primitive types here and the reference types (classes and objects) in the later chapters on &quot;Object-Oriented Programming&quot;.</p>

<table class="table-zebra">
<tr>
  <th>TYPE</th>
  <th colspan="2">DESCRIPTION</th>
</tr>
<tr>
  <td><span class="font-code"><strong>byte</strong></span></td>
  <td rowspan="4">Integer</td>
  <td>8-bit signed integer<br />
  The range is <code>[-2^7, 2^7-1] = [-128, 127]</code></td>
</tr>
<tr class="tr-alt">
  <td><span class="font-code"><strong>short</strong></span></td>
  <td>16-bit signed integer<br />
  The range is <code>[-2^15, 2^15-1] = [-32768, 32767]</code></td>
</tr>
<tr>
  <td><span class="font-code"><strong>int</strong></span></td>
  <td>32-bit signed integer<br />
  The range is <code>[-2^31, 2^31-1] = [-2147483648, 2147483647]</code> (&asymp;9 digits)</td>
</tr>
<tr class="tr-alt">
  <td><span class="font-code"><strong>long</strong></span></td>
  <td>64-bit signed integer<br />
  The range is <code>[-2^63, 2^63-1] = [-9223372036854775808, +9223372036854775807]</code> (&asymp;19 digits)</td>
</tr>
<tr>
  <td><span class="font-code"><strong>float</strong></span></td>
  <td rowspan="2">Floating-Point<br />Number</td>
  <td>32-bit single precision floating-point number<br />
  (<code>&asymp;</code>6-7 significant decimal digits, in the range of <code>&plusmn;[&asymp;10^-45, &asymp;10^38]</code>)</td>
</tr>
<tr class="tr-alt">
  <td><span class="font-code"><strong>double</strong></span></td>
  <td>64-bit double precision floating-point number<br />
  (<code>&asymp;</code>14-15 significant decimal digits, in the range of <code>&plusmn;[&asymp;10^-324, &asymp;10^308]</code>)</td>
</tr>
<tr>
  <td><span class="font-code"><strong>char</strong></span></td>
  <td colspan="2">Character<br />
  Represented in 16-bit Unicode <code>'\u0000'</code> to <code>'\uFFFF'</code>.<br />Can be treated as 16-bit unsigned integers in the range of <code>[0, 65535]</code> in arithmetic operations.</td>
</tr>
<tr class="tr-alt">
  <td><span class="font-code"><strong>boolean</strong></span></td>
  <td colspan="2">Binary<br />
  Takes a  value of either <code>true</code> or <code>false</code>.<br />The size of <code>boolean</code> is not defined in the Java specification, but requires at least one bit.</td>
</tr>
</table>

<img class="image-float-right" src="images/Type_Primitive.gif" alt="primitive types" />

<h5>Built-in Primitive Types</h5>

<p>Primitive type are built-in to the languages. Java has eight <em>primitive types</em>, as listed in the above table:</p>

<ul>
<li>There are four integer types: 8-bit <code>byte</code>, 16-bit <code>short</code>, 32-bit <code>int</code>  and 64-bit <code>long</code>. They are <em>signed integers</em> in <em>2's complement representation</em>, and can hold an integer value of the various ranges as shown in the table.</li>

<li>There are two floating-point types: 32-bit single-precision <code>float</code> and 64-bit double-precision <code>double</code>, represented as specified by IEEE 754 standard. A  <code>float</code> can represent a number between <code>&plusmn;1.40239846&times;10^-45</code> and <code>&plusmn;3.40282347&times;10^38</code>, approximated. A <code>double</code> can represented a number between <code>&plusmn;4.94065645841246544&times;10^-324</code> and <code>&plusmn;1.79769313486231570&times;10^308</code>, approximated. Take note that not all real numbers can be represented by <code>float</code> and <code>double</code>. This is  because there are infinite real numbers even in a small range of say <code>[1.1, 2.2]</code>, but there is a finite number of patterns in a n-bit representation. Most of the floating-point values are approximated to their nearest representation.</li>

<li>The type <code>char</code> represents a single character, such as <code>'0'</code>, <code>'A'</code>, <code>'a'</code>. In Java, char is represented using 16-bit Unicode (in UCS-2 format) to support internationalization (<em>i18n</em>). A <code>char</code> can be treated as a <em>16-bit unsigned integer</em> (in the range of <code>[0, 65535]</code>) in arithmetic operations. For example, character <code>'0'</code> is <code>48</code> (decimal) or <code>30H</code> (hexadecimal); character <code>'A'</code> is <code>65</code> (decimal) or <code>41H</code> (hexadecimal); character <code>'a'</code> is <code>97</code> (decimal) or <code>61H</code> (hexadecimal).</li>

<li>Java introduces a new <em>binary </em>type called &quot;<code>boolean</code>&quot;, which takes a  value of either <code>true</code> or <code>false</code>.</li>
</ul>

<p><span class="line-heading">Example</span>: The following program can be used to print the <em>maximum</em>, <em>minimum</em> and <em>bit-length</em> of the primitive types. The maximum, minimum and bit-size of <code>int</code> are kept in constants <code>INTERER.MIN_VALUE</code>, <code>INTEGER.MAX_VALUE</code>, <code>INTEGER.SIZE</code>.</p>

<pre class="color-example">
<span class="color-comment">/* 
 * Print the minimum, maximum and bit-length for primitive types
 */</span>
public class <strong>PrimitiveTypesMinMax</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// int (32-bit signed integer)</span>
      System.out.println(&quot;int(min) = &quot; + Integer.MIN_VALUE);
      System.out.println(&quot;int(max) = &quot; + Integer.MAX_VALUE);
      System.out.println(&quot;int(bit-length) = &quot; + Integer.SIZE);
      <span class="color-comment">// byte (8-bit signed integer)</span>
      System.out.println(&quot;byte(min) = &quot; + Byte.MIN_VALUE);
      System.out.println(&quot;byte(max) = &quot; + Byte.MAX_VALUE);
      System.out.println(&quot;byte(bit-length)=&quot; + Byte.SIZE); 
      <span class="color-comment">// short (16-bit signed integer)</span>
      System.out.println(&quot;short(min) = &quot; + Short.MIN_VALUE);
      System.out.println(&quot;short(max) = &quot; + Short.MAX_VALUE);
      System.out.println(&quot;short(bit-length) = &quot; + Short.SIZE);
      <span class="color-comment">// long (64-bit signed integer)</span>
      System.out.println(&quot;long(min) = &quot; + Long.MIN_VALUE); 
      System.out.println(&quot;long(max) = &quot; + Long.MAX_VALUE);
      System.out.println(&quot;long(bit-length) = &quot; + Long.SIZE);
      <span class="color-comment">// char (16-bit character or 16-bit unsigned integer)</span>
      System.out.println(&quot;char(min) = &quot; + (int)Character.MIN_VALUE);
      System.out.println(&quot;char(max) = &quot; + (int)Character.MAX_VALUE);
      System.out.println(&quot;char(bit-length) = &quot; + Character.SIZE);
      <span class="color-comment">// float (32-bit floating-point)</span>
      System.out.println(&quot;float(min) = &quot; + Float.MIN_VALUE);
      System.out.println(&quot;float(max) = &quot; + Float.MAX_VALUE);
      System.out.println(&quot;float(bit-length) = &quot; + Float.SIZE);
      <span class="color-comment">// double (64-bit floating-point)</span>
      System.out.println(&quot;double(min) = &quot; + Double.MIN_VALUE);
      System.out.println(&quot;double(max) = &quot; + Double.MAX_VALUE);
      System.out.println(&quot;double(bit-length) = &quot; + Double.SIZE);
   }
}</pre>

<p>The expected outputs are:</p>
<pre class="output">
int(min) = -2147483648
int(max) = 2147483647
int(bit-length) = 32
byte(min) = -128
byte(max) = 127
byte(bit-length)=8
short(min) = -32768
short(max) = 32767
short(bit-length) = 16
long(min) = -9223372036854775808
long(max) = 9223372036854775807
long(bit-length) = 64
char(min) = 0
char(max) = 65535
char(bit-length) = 16
float(min) = 1.4E-45
float(max) = 3.4028235E38
float(bit-length) = 32
double(min) = 4.9E-324
double(max) = 1.7976931348623157E308
double(bit-length) = 64</pre>

<h5>String</h5>

<p>Another commonly-used type is <code>String</code>, which represents texts (a sequence of characters) such as <code>&quot;Hello, world&quot;</code>. <code>String</code> is not a primitive type, and will be further elaborated later. In Java, a <code>char</code> is enclosed by single quotes (e.g., <code>'A'</code>, <code>'0'</code>), while a <code>String</code> is enclosed by double quotes (e.g., <code>&quot;Hello&quot;</code>). For example,</p>

<pre class="color-example">
String message = &quot;Hello, world!&quot;; <span class="color-comment">// strings are enclosed in double-quotes</span>
char gender = 'm';                <span class="color-comment">// char is enclosed in single-quotes</span></pre>

<h5>Choice of Data Types for Variables</h5>
<p>As a programmer, you need to choose variables and decide on the type of the variables to be used in your programs. Most of the times, the decision is intuitive. For example, use an integer type for counting and whole number; a floating-point type for number with fractional part, <code>String</code> for text message, <code>char</code> for a single character, and <code>boolean</code> for binary outcomes.</p>

<h5>Rules of Thumb</h5>

<ul>
<li>Use <code>int</code> for integer and <code>double</code> for floating point numbers. Use <code>byte</code>, <code>short</code>, <code>long</code> and <code>float</code> only if you have a good reason to choose that specific precision.</li>

<li>Use <code>int</code> for <em>counting</em> and <em>indexing</em>, NOT floating-point type (<code>float</code> or <code>double</code>). This is because integer type are precise and more efficient in operations.</li>

<li>Use an integer type if possible. Use a floating-point type only if the number contains a fractional part.</li>
</ul>

<h5>Data Representation</h5>

<p>Read &quot;<a href="DataRepresentation.html">Data Representation</a>&quot; if you wish to understand how the numbers and characters are represented inside the computer memory. In brief,  It is important to take note that char <code>'1'</code> is different from <code>int</code> <code>1</code>, <code>byte</code> <code>1</code>, <code>short</code> <code>1</code>, <code>float</code> <code>1.0</code>, <code>double</code> <code>1.0</code>, and <code>String</code> <code>&quot;1&quot;</code>. They are represented differently in the computer memory, with different precision and interpretation. For example, <code>byte</code> <code>1</code> is <code>&quot;00000001&quot;</code>, <code>short</code> <code>1</code> is <code>&quot;00000000 00000001&quot;</code>, <code>int</code> <code>1</code> is <code>&quot;00000000 00000000 00000000 00000001&quot;</code>, <code>long</code> <code>1</code> is <code>&quot;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001&quot;</code>, <code>float</code> <code>1.0</code> is <code>&quot;0 01111111 0000000 00000000 00000000&quot;</code>, <code>double</code> <code>1.0</code> is <code>&quot;0 01111111111 0000 00000000 00000000 00000000 00000000 00000000 00000000&quot;</code>, <code>char</code> <code>'1'</code> is <code>&quot;00000000 00110001&quot;</code>, and <code>String</code> <code>&quot;1&quot;</code> is a complex object.</p>

<p> There is a subtle difference between <code>int</code> <code>0</code> and <code>double</code> <code>0.0</code>.</p>

<p>Furthermore, you MUST know the type of a value before you can interpret a value. For example, this value <code>&quot;00000000 00000000 00000000 00000001&quot;</code> cannot be interpreted unless you know its type (or its representation).</p>

<p><span class="line-heading">Example (Variable Names and Types):</span> Paul has bought a new notebook of &quot;abc&quot; brand, with a processor speed of 3.2GHz, 4 GB of RAM, 500GB hard disk, with a 15-inch monitor, for $1650.45. He has chosen service plan 'B' among plans 'A', 'B' and 'C', plus on-site servicing. Identify the data types and name the variables.</p>

<p>The possible variable names and types are:</p>

<pre class="color-example">
String name = &quot;Paul&quot;;
String brand = &quot;abc&quot;;
double processorSpeedInGHz = 3.2;  <span class="color-comment">// or float</span>
double ramSizeInGB = 4;      <span class="color-comment">// or float</span>
int harddiskSizeInGB = 500;  <span class="color-comment">// or short</span>
int monitorInInch = 15;      <span class="color-comment">// or byte</span>
double price = 1650.45;
char servicePlan = 'B';
boolean onSiteService = true;</pre>

<p><span class="line-heading">Exercise (Variable Names and Types):</span> You are asked to develop a software for a college. The system shall maintain information about students. This includes name, address, phone number, gender, date of birth, height, weight, degree pursued (e.g., B.Sc., B.A.), year of study, average GPA, with/without tuition grant, is/is not a scholar. Each student is assigned a unique 8-digit number as id. Identify the variables. Assign a suitable name to each variable and choose an appropriate type. Write the variable declaration statements.</p>

<h4>Literals for Primitive Types and String</h4>

<p>A <em>literal</em>, or <em>literal constant</em>, is a <em>specific constant value</em>, such as <code>123</code>, <code>-456</code>, <code>3.14</code>, <code>-1.2e3</code>, <code>'a'</code>, <code>&quot;Hello&quot;</code>, that is used in the program source. It can be assigned directly to a variable; or used  as part of an expression. They are called <em>literals</em> because they literally and explicitly identify their values. We call it <em>literal</em> to distinguish it from a <em>variable</em>.</p>

<h5>Integer (<code>int</code>, <code>long</code>, <code>short</code>, <code>byte</code>) literals</h5>

<p>A whole number, such as <code>123</code> and <code>-456</code>, is treated as an <code>int</code> by default. In Java, the range of 32-bit <code>int</code>  literals is <code>-2,147,483,628</code> (<code>-2^31</code>) to <code>2,147,483,627</code> (<code>2^31-1</code>). For example,</p>

<pre class="color-example">
int number = -123;
int sum = 1234567890;     <span class="color-comment">// This value is within the range of int</span>
<span class="color-error">int bigSum = 8234567890;</span>  <span class="color-comment">// ERROR: this value is outside the range of int</span></pre>

<p>An <code>int</code> literal may precede with a plus (<code>+</code>) or minus (<code>-</code>) sign, followed by digits. No commas or special symbols (e.g., <code>$</code> or space) is allowed (e.g., <code>1,234</code> and <code>$123</code> are invalid). No preceding <code>0</code> is allowed too (e.g., <code>007</code> is invalid).</p>

<p>You can use a prefix <code>'0'</code> (zero) to denote a value in octal, and prefix <code>'0x'</code> (or <code>'0X'</code>) for a value in hexadecimal, e.g.,</p>

<pre class="color-example">
int number = 1234;   <span class="color-comment">// Decimal</span>
int number = 01234;  <span class="color-comment">// Octal 1234, Decimal 2322</span>
int number = 0x1abc; <span class="color-comment">// hexadecimal 1ABC, decimal 15274</span></pre>

<p><span class="line-heading">(JDK 1.7)</span> From JDK 7, you can use prefix '<code>0b</code>' or '<code>0B</code>' to specify a value in binary. You are also permitted to use underscore (<code>_</code>) to break the digits into groups to improve the readability. But you must start and end the literal with a digit. For example,</p>

<pre class="color-example">
int number1 = 0b01010000101000101101000010100010;
int number2 = 0b0101_0000_1010_0010_1101_0000_1010_0010;  <span class="color-comment">// break the digits with underscore (JDK 1.7)</span>
int number3 = 2_123_456;  <span class="color-comment">// break the digits with underscore (JDK 1.7)</span></pre>

<p>A <code>long</code> literal above the <code>int</code> range requires a suffix <code>'L'</code> or <code>'l'</code> (avoid lowercase, which confuses with the number one), e.g., <code>123456789012L</code>, <code>-9876543210l</code>. In Java, the range of 64-bit <code>long</code> literals is <code>-9,223,372,036,854,775,808L</code> (<code>-2^63</code>) to <code>9,223,372,036,854,775,807L</code> (<code>2^63-1</code>). For example,</p>

<pre class="color-example">
long bigNumber = 1234567890123L;  <span class="color-comment">// Suffix 'L' needed</span>
long sum = 123;                   <span class="color-comment">// int 123 auto-casts to long 123L</span>
</pre>

<p>No suffix is needed for <code>byte</code> and <code>short</code> literals. But you can only use integer values in the permitted range. For example,</p>

<pre class="color-example">
<span class="color-error">byte smallNumber = 12345;</span>    <span class="color-comment"> // ERROR: this value is outside the range of byte.</span>
byte smallNumber = 123;       <span class="color-comment">// This is within the range of byte</span>
short midSizeNumber = -12345;</pre>

<h5>Floating-point (<code>double</code>, <code>float</code>) literals</h5>

<p>A number with a decimal point, such as <code>55.66</code> and <code>-33.44</code>, is treated as a <code>double</code> by default. You can also express them in scientific notation, e.g., <code>1.2e3</code>, <code>-5.5E-6</code>, where <code>e</code> or <code>E</code> denotes the exponent in base of 10. You could precede the fractional part or exponent with a plus (<code>+</code>) or minus (<code>-</code>) sign. Exponent values are restricted to integer. There should be no space or other characters in the number.</p>

<p>You can <em>optionally</em> use suffix <code>'d'</code> or <code>'D'</code> to denote <code>double</code> literals.</p>

<p>You MUST use a suffix of <code>'f'</code> or <code>'F'</code> for <code>float</code> literals, e.g., <code>-1.2345F</code>. For example,</p>

<pre class="color-example">
<span class="color-error">float average = 55.66;</span>      <span class="color-comment">// Error! RHS is a double. Need suffix 'f' for float.</span>
float average = 55.66f;</pre>

<h5>Character (<code>char</code>) Literals and Escape Sequences</h5>

<p>A printable <code>char</code> literal is written by enclosing the character with a pair of <em>single quotes</em>, e.g., <code>'z'</code>, <code>'$'</code>, and <code>'9'</code>. In Java, characters are represented using 16-bit Unicode, and can be treated as a 16-bit <em>unsigned integer</em>s in arithmetic operations. In other words, <code>char</code> and 16-bit unsigned integer are interchangeable. You can also assign an integer in the range of <code>[0, 65535]</code> to a <code>char</code> variable.</p>

<p>For example,</p>

<pre class="color-example">
char letter = 'a';                 <span class="color-comment">// Same as 97</span>
char anotherLetter = 98;           <span class="color-comment">// Same as the letter 'b'</span>
System.out.println(letter);        <span class="color-comment">// 'a' printed</span>
System.out.println(anotherLetter); <span class="color-comment">// 'b' printed instead of the number</span>
anotherLetter += 2;                <span class="color-comment">// 100 or 'd'</span>
System.out.println(anotherLetter); <span class="color-comment">// 'd' printed</span></pre>

<p>Non-printable and control characters can be represented by a so-called <em>escape sequence</em>, which begins with a back-slash (<code>\</code>) followed by a pattern. The commonly-used escape sequences are:</p>

<table class="table-zebra" style="width:70%">
  <tr>
    <th>Escape Sequence</th>
    <th>Description</th>
    <th>Unicode in Hex (Decimal)</th>
  </tr>
  <tr>
    <td class="text-center"><span class="font-code">\n</span></td>
    <td>Newline (or Line-feed)</td>
    <td class="text-center"><span class="font-code">000AH (10D)</span></td>
  </tr>
  <tr class="tr-alt">
    <td class="text-center"><span class="font-code">\r</span></td>
    <td>Carriage-return</td>
    <td class="text-center"><span class="font-code">000DH (13D)</span></td>
  </tr>
  <tr>
    <td class="text-center"><span class="font-code">\t</span></td>
    <td>Tab</td>
    <td class="text-center"><span class="font-code">0009H (9D)</span></td>
  </tr>
  <tr class="tr-alt">
    <td class="text-center"><span class="font-code">\&quot;</span></td>
    <td>Double-quote</td>
    <td class="text-center"><span class="font-code">0022H (34D)</span></td>
  </tr>
  <tr>
    <td class="text-center"><span class="font-code">\'</span></td>
    <td>Single-quote</td>
    <td class="text-center"><span class="font-code">0027H (39D)</span></td>
  </tr>
  <tr class="tr-alt">
    <td class="text-center"><span class="font-code">\\</span></td>
    <td>Back-slash</td>
    <td class="text-center"><span class="font-code">005CH (92D)</span></td>
  </tr>
  <tr>
    <td class="text-center"><span class="font-code">\u<em>hhhh</em></span></td>
    <td>Unicode number <span class="font-code"><em>hhhh</em></span> (in hex),<br  />
    e.g., <span class="font-code">\u000a</span> is newline, <span class="font-code">\u60a8</span> is 您, <span class="font-code">\u597d</span> is 好</td>
    <td class="text-center"><span class="font-code"><em>hhhh</em>H</span></td>
  </tr>
</table>

<p>Notes:</p>

<ul>
<li>Newline (<code>000AH</code>) and Carriage-Return (<code>000DH</code>), represented by the escape sequence <code>\n</code>, and <code>\r</code> respectively, are used as <em>line delimiter</em> (or <em>end-of-line</em>, or <em>EOL</em>). Take note that Unixes and Mac use <code>\n</code> (<code>0AH</code>) as EOL, while Windows use <code>\r\n</code> (<code>0D0AH</code>).</li>

<li>Horizontal Tab (<code>0009H</code>) is represented as <code>\t</code>.</li>

<li>To resolve <em>ambiguity</em>, characters back-slash (<code>\</code>), single-quote (<code>'</code>) and double-quote (<code>&quot;</code>) are represented using escape sequences <code>\\</code>, <code>\'</code> and <code>\&quot;</code>, respectively. E.g.,
<ul>
<li>To represent a back-slash <code>char</code>, you need to write <code>'\\'</code>, instead of <code>'\'</code>, as a back-slash begins an escape sequence. Similarly, to include a back-slash in a double-quoted string, you need to write <code>\\</code>.</li>
<li>To represent a single-quote <code>char</code>, you need to write <code>'\''</code> to distinguish it from the closing single-quote. But you can write double-quote directly, i.e., <code>'&quot;'</code>.</li>
<li>To place a double-quote in a double-quoted string, you need to use <code>\&quot;</code> to distinguish it from the closing double-quote, e.g., <code>&quot;\&quot;hello\&quot;&quot;</code>. But you can write single-quote directly, e,g, <code>&quot;'hello'&quot;</code>.</li>

</ul></li>
<li>Other less commonly-used escape sequences are: <code>\a</code> for alert or bell, <code>\b</code> for backspace, <code>\f</code> for form-feed, <code>\v</code> for vertical tab. These may not be supported in some consoles.</li>
</ul>

<h5>String Literals</h5>

<p>A <code>String</code> literal is composed of zero of more characters surrounded by a pair of <em>double quotes</em>, e.g., <code>&quot;Hello, world!&quot;</code>, <code>&quot;The sum is: &quot;</code>. For example,</p>

<pre class="color-example">
String directionMsg = &quot;Turn Right&quot;;
String greetingMsg = &quot;Hello&quot;;
String statusMsg = &quot;&quot;;   <span class="color-comment">// an empty string</span></pre>

<p>String literals may contains escape sequences. Inside a <code>String</code>, you need to use <code>\&quot;</code> for double-quote to distinguish it from the ending double-quote, e.g. <code>&quot;\&quot;quoted\&quot;&quot;</code>. Single-quote inside a <code>String</code> does not require escape sequence. For example,</p>

<pre class="color-example">
System.out.println(&quot;Use \\\&quot; to place\n a \&quot; within\ta\tstring&quot;);</pre>

<pre class="output">
Use \&quot; to place
 a &quot; within	a	string</pre>

<p><span class="line-heading">Exercise:</span> Write a program to print the following animal picture using multiple <code>System.out.println()</code>. Take note that you need to use escape sequences to print special characters.</p>

<pre class="output">
          '__'
          (oo)
  +========\/
 / || %%% ||
*  ||-----||
   &quot;&quot;     &quot;&quot;</pre>

<h5><span class="font-code">boolean</span> Literals</h5>

<p>There are only two <code>boolean</code> literals, i.e., <code>true</code> and <code>false</code>. For example,</p>

<pre class="color-example">
boolean done = true;
boolean gameOver = false;</pre> 

<h5>Example on Literals</h5>

<pre class="color-example">
<span class="color-comment">/*
 * Test literals for various primitive types
 */</span>
public class <strong>LiteralTest</strong> {
   public static void main(String[] args) {
      String name = &quot;Tan Ah Teck&quot;; <span class="color-comment">// String is double-quoted</span>
      char gender = 'm';           <span class="color-comment">// char is single-quoted</span>
      boolean isMarried = true;    <span class="color-comment">// true or false</span>
      byte numChildren = 8;        <span class="color-comment">// Range of byte is [-127, 128]</span>
      short yearOfBirth = 1945;    <span class="color-comment">// Range of short is [-32767, 32768]. Beyond byte</span>
      int salary = 88000;          <span class="color-comment">// Beyond the ranges of byte and short</span>
      long netAsset = 8234567890L; <span class="color-comment">// Need suffix 'L' for long. Beyond int</span>
      double weight = 88.88;       <span class="color-comment">// With fractional part</span>
      float gpa = 3.88f;           <span class="color-comment">// Need suffix 'f' for float</span>
   
      <span class="color-comment">// println() can be used to print value of any type</span>
      System.out.println(&quot;Name is &quot; + name);
      System.out.println(&quot;Gender is &quot; + gender);
      System.out.println(&quot;Is married is &quot; + isMarried);
      System.out.println(&quot;Number of children is &quot; + numChildren);
      System.out.println(&quot;Year of birth is &quot; + yearOfBirth);
      System.out.println(&quot;Salary is &quot; + salary);
      System.out.println(&quot;Net Asset is &quot; + netAsset);
      System.out.println(&quot;Weight is &quot; + weight);
      System.out.println(&quot;GPA is &quot; + gpa);
   }
}</pre>

<p>The expected outputs are:</p>
<pre class="output">
Name is Tan Ah Teck
Gender is m
Is married is true
Number of children is 8
Year of birth is 1945
Salary is 88000
Net Asset is 1234567890
Weight is 88.88
Height is 188.8</pre>


<h3>Operations</h3>

<h4>Arithmetic Operators</h4>

<p>Java supports the following arithmetic operators:</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Description</th>
  <th>Usage</th>
  <th>Examples</th>
</tr>

<tr class="tr-alt">
  <td class="text-center"><span class="font-code">*</span></td>
  <td>Multiplication</td>
  <td><span class="font-code"><em>expr1</em> * <em>expr2</em></span></td>
  <td><span class="font-code">2 * 3 &rarr; 6<br />3.3 * 1.0 &rarr; 3.3</span></td>
</tr>

<tr>
  <td class="text-center"><span class="font-code">/</span></td>
  <td>Division</td>
  <td><span class="font-code"><em>expr1</em> / <em>expr2</em></span></td>
  <td><span class="font-code">1 / 2 &rarr; 0<br />1.0 / 2.0 &rarr; 0.5</span></td>
</tr>

<tr class="tr-alt">
  <td class="text-center"><span class="font-code">%</span></td>
  <td>Remainder (Modulus)</td>
  <td><span class="font-code"><em>expr1</em> % <em>expr2</em></span></td>
  <td><span class="font-code">5 % 2 &rarr; 1<br /> -5 % 2 &rarr; -1<br />5.5 % 2.2 &rarr; 1.1</span></td>
</tr>

<tr>
  <td class="text-center"><span class="font-code">+</span></td>
  <td>Addition<br />
  (or unary positive)</td>
  <td><span class="font-code"><em>expr1</em> + <em>expr2</em><br />+expr</span></td>
  <td><span class="font-code">1 + 2 &rarr; 3<br />1.1 + 2.2 &rarr; 3.3</span></td>
</tr>

<tr class="tr-alt">
  <td class="text-center"><span class="font-code">-</span></td>
  <td>Subtraction<br />(or unary negate)</td>
  <td><span class="font-code"><em>expr1</em> - <em>expr2</em><br />-expr</span></td>
  <td><span class="font-code">1 - 2 &rarr; -1<br />1.1 - 2.2 &rarr; -1.1</span></td>
</tr>
</table>

<p>All these operators are <em>binary</em> operators, i.e., they take two operands. However, '+' and '-' can also be interpreted as <em>unary</em> &quot;positive&quot; and &quot;negative&quot; operators. For example,</p>

<pre class="color-example">
int number = -88;  <span class="color-comment">// negate</span>
int x = +5;        <span class="color-comment">// '+' optional</span></pre>

<h4>Arithmetic Expressions</h4>

<p>In programming, the following arithmetic expression:</p>

<img class="image-left" src="images/JavaBasics_ArithmeticExpression.png" alt="JavaBasics_ArithmeticExpression.png" />

<p>must be written as <code>(1+2*a)/3 + (4*(b+c)*(5-d-e))/f - 6*(7/g+h)</code>. You cannot omit the multiplication symbol (<code>*</code>), as in Mathematics.</p>

<h5>Rules on Precedence</h5>
<p>Like Mathematics:</p>

<ol>
<li>The multiplication (<code>*</code>), division (<code>/</code>) and remainder (<code>%</code>) take precedence over addition (<code>+</code>) and subtraction (<code>-</code>). For example, <code>1+2*3-4/2</code> is interpreted as <code>1+(2*3)-(4/2)</code>.</li>
<li>Unary <code>'+'</code> (positive) and <code>'-'</code> (negate) have higher precedence.</li>
<li>Parentheses <code>()</code> have the highest precedence and can be used to change the order of evaluation.</li>
<li>Within the same precedence level (e.g., addition and subtraction), the expression is evaluated from left to right (called <em>left-associative</em>). For example, <code>1+2-3+4</code> is evaluated as <code>((1+2)-3)+4</code> and <code>1*2%3/4</code> is <code>((1*2)%3)/4</code>.</li>
</ol>

<h4>Mixed-Type Operations</h4>

<p>The arithmetic operators are only applicable to <em>primitive numeric types</em>: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, and <code>char</code>.<code> </code>These operators do not apply to <code>boolean</code>.</p>

<p>If both operands are <code>int</code>, <code>long</code>, <code>float</code> or <code>double</code>, the arithmetic operations are carried in that type, and evaluated to a value of that type, i.e., <code>int 5 + int 6 &rarr; int 11</code>; <code>double 2.1 + double 1.2 &rarr; double 3.3</code>.</p>

<p>It is important to take note <code>int</code> division produces an <code>int</code>, i.e., <code>int/int &rarr;</code><code> int</code>, with the result <em>truncated</em>, e.g., <code>1/2 &rarr; 0</code>, instead of <code>0.5</code>?!</p>

<p>If both operand are <code>byte</code>, <code>short</code> or <code>char</code>, the operations are carried out in <code>int</code>, and evaluated to a value of <code>int</code>. A <code>char</code> is treated as a 16-bit <em>unsigned</em> integer in the range of <code>[0, 65535]</code>. For example, <code>byte 127 + byte 1 &rarr; int 127 + int 1 &rarr; int 128</code>.</p>

<p>If the two operands belong to <em>different types</em>, the value of the <em>smaller</em> type is promoted automatically to the <em>larger</em> type (known as <em>implicit type-casting</em>). The operation is then carried out in the <em>larger</em> type, and evaluated to a value in the <em>larger</em> type.</p>

<ul>
<li><code>byte</code>, <code>short</code> or <code>char</code> is first promoted to <code>int</code> before comparing with the type of the other operand.</li>

<li>The order of promotion is: <code>int &rarr; long &rarr; float &rarr; double</code>.</li>
</ul>

<p>For examples,</p>

<ol>
<li><code>int/double &rarr; double/double &rarr; double</code>. Hence, <code>1/2 &rarr; 0, 1.0/2.0 &rarr; 0.5, 1.0/2 &rarr; 0.5, 1/2.0 &rarr; 0.5</code>.</li>

<li><code>char + float &rarr; int + float &rarr; float + float &rarr; float</code>.</li>

<li><code>9 / 5 * 20.1 &rarr; (9 / 5) * 20.1 &rarr; 1 * 20.1 &rarr; 1.0 * 20.1 &rarr; 20.1</code> (You probably don't expect this answer!)</li>

<li><code>byte 1 + byte 2 &rarr; int 1 + int 2 &rarr; int 3</code> (The result is an <code>int</code>, NOT <code>byte</code>!)

<pre class="color-example">
byte b1 = 1, b2 = 2;
byte b3 = b1 + b2;  <span class="color-comment">// Compilation Error: possible loss of precision
                    // b1+b2 returns an int, cannot be assigned to byte</span></pre>

</li>
</ol>

<p>The type-promotion rules for <em>binary</em> operations can be summarized as follows:</p>

<ol>
<li>If one of the operand is <code>double</code>, the other operand is promoted to <code>double</code>;</li>

<li>Else If one of the operand is <code>float</code>, the other operand is promoted to <code>float</code>;</li>

<li>Else If one of the operand is <code>long</code>, the other operand is promoted to <code>long</code>;</li>

<li>Else both operands are promoted to <code>int</code>.</li>
</ol>

<p>The type-promotion rules for <em>unary</em> operations (e.g., negate <code>'-'</code>) can be summarized as follows:</p>

<ol>
<li>If the operand is <code>double</code>, <code>float</code>, <code>long</code> or <code>int</code>, there is no promotion.</li>

<li>Else (the operand is <code>byte</code>, <code>short</code>, <code>char</code>), the operand is promoted to <code>int</code>.</li>
</ol>

<p>For example,</p>

<pre class="color-example">
byte b1 = 1;
byte b2 = -b1;  <span class="color-comment">// Compilation Error: possible loss of precision
                // -b1 returns an int, cannot be assigned to byte</span></pre>

<h5>Remainder (Modulus) Operator</h5>

<p>To evaluate the remainder (for negative and floating-point operands), perform repeated subtraction until the <em>absolute</em> value of the remainder is less than the <em>absolute</em> value of the second operand.</p>

<p>For example,</p>

<ul>
<li><code>-5 % 2 ⇒ -3 % 2 ⇒ -1</code></li>
<li><code>5.5 % 2.2 ⇒ 3.3 % 2.2 ⇒ 1.1</code></li>
</ul>

<h5>Exponent?</h5>
<p>Java does not have an exponent operator. (The <code>'^'</code> operator is for exclusive-or, NOT exponent). You need to use method <code>Math.exp(x, y)</code> to evaluate <code>x</code> raises to power <code>y</code>.</p>

<h4>Overflow/Underflow</h4>

<p>Study the output of the following program:</p>

<pre class="color-example">
<span class="color-comment">/*
 * Illustrate &quot;int&quot; overflow
 */</span>
public class <strong>Overflow<strong>Test</strong></strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Range of int is [-2147483648, 2147483647]</span>
      int i1 = 2147483647;  <span class="color-comment">// maximum int</span>
      System.out.println(i1 + 1);   <span class="color-comment">// -2147483648 (overflow!)</span>
      System.out.println(i1 + 2);   <span class="color-comment">// -2147483647</span>
      System.out.println(i1 * i1);  <span class="color-comment">// 1</span>
      
      int i2 = -2147483648;  <span class="color-comment">// minimum int</span>
      System.out.println(i2 - 1);   <span class="color-comment">// 2147483647 (overflow!)</span>
      System.out.println(i2 - 2);   <span class="color-comment">// 2147483646</span>
      System.out.println(i2 * i2);  <span class="color-comment">// 0</span>
   }
}</pre>

<p>In arithmetic operations, the resultant value <em>wraps around</em> if it exceeds its range (i.e., overflow). Java runtime does NOT issue an error/warning message but produces an <em>incorrect</em> result.</p>

<p>On the other hand, integer division produces an truncated integer and results in so-called <em>underflow</em>. For example, <code>1/2</code> gives <code>0</code>, instead of <code>0.5</code>. Again, Java runtime does NOT issue an error/warning message, but produces an <em>imprecise</em> result.</p>

<p>It is important to take note that <em>checking of overflow/underflow is the programmer's responsibility</em>. i.e., your job!!!</p>

<p>Why computer does not flag overflow/underflow as an error? This is due to the legacy design when the processors were very slow. Checking for overflow/underflow consumes computation power. Today, processors are fast. It is better to ask the computer to check for overflow/underflow (if you design a new language), because few humans expect such results.</p>

<p>To check for arithmetic overflow (known as <em>secure coding</em>) is tedious. Google for &quot;INT32-C. Ensure that operations on signed integers do not result in overflow&quot; @ www.securecoding.cert.org.</p>

<h4 id="typecasting">Type-Casting</h4>

<p>In Java, you will get a <em>compilation error</em> if you try to assign a <code>double</code> or <code>float</code> value of to an <code>int</code> variable. This is because the fractional part would be lost. The compiler issues an error &quot;possible loss in precision&quot;. For example,</p>

<pre class="color-example">
double d = 3.5;
int i;
<span class="color-error">i = d;</span>            <span class="color-comment">// Compilation Error: possible loss of precision (assigning a double value to an int variable)</span>
<span class="color-error">int sum = 55.66f;</span> <span class="color-comment">// Compilation Error: possible loss of precision (assigning a float value to an int variable)</span></pre>

<h5>Explicit Type-Casting and Type-Casting Operator</h5>

<p>To assign the a <code>double</code> value to an <code>int</code> variable, you need to<em> </em>invoke the so-called <em>type-casting operator</em> - in the form of <code>(int)<em>value</em></code> - to operate on the <code>double</code> operand and return a <em>truncated</em> value in <code>int</code>. In other words, you tell the compiler you concisely perform the truncation and you are aware of the possible loss of precision. You can then assign the truncated <code>int</code> value to the <code>int</code> variable. For example,</p>

<pre class="color-example">
double d = 3.5;
int i;
i = (int) d;    <span class="color-comment">// Cast double value of 3.5 to int 3. Assign the resultant value 3 to i</span>
                <span class="color-comment">// Casting from double to int <em>truncates</em>.</span></pre>

<p>Type-casting is an operation which takes one operand. It operates on its operand, and returns an equivalent value in the specified type.</p>

<p>There are two kinds of type-casting in Java:</p>

<ol>
<li>Explicit type-casting via a type-casting operator in the prefix form of <code>(<em>new-type</em>)<em>operand</em></code>, as described above, and</li>

<li>Implicit type-casting performed by the compiler automatically, if there is no  loss of precision.</li>
</ol>

<h5>Implicit Type-Casting in Assignment</h5>

<p>Explicit type-casting is not required if you assign an <code>int</code> value to a <code>double</code> variable, because there is no   loss of precision. The compiler will perform the type-casting automatically (i.e., implicit type-casting). For example,,</p>

<pre class="color-example">
int i = 3;
double d;
d = i;           <span class="color-comment">// OK, no explicit type casting required</span>
                 <span class="color-comment">// d = 3.0</span>
d = (double) i;  <span class="color-comment">// Explicit type casting operator used here</span>
double aDouble = 55;   <span class="color-comment">// Compiler auto-casts int 55 to double 55.0</span>
double nought = 0;     <span class="color-comment">// Compiler auto-casts int 0 to double 0.0
                       // int 0 and double 0.0 are different.</span></pre>

<p>The following diagram shows the order of implicit type-casting performed by compiler. The rule is to promote the smaller type to a bigger type to prevent loss of precision, known as widening conversion. Narrowing conversion requires explicit type-cast to inform the compiler that you are aware of the possible loss of precision. Take note that <code>char</code> is treated as an 16-bit unsigned integer in the range of <code>[0, 65535]</code>. <code>boolean</code> value cannot be type-casted (i.e., converted to non-<code>boolean</code>).</p>

<img class="image-center" src="images/JavaBasics_ImplicitTypeCastingPrimitives.png" alt="JavaBasics_ImplicitTypeCastingPrimitives.png" />

<p><span class="line-heading">Example</span>: Suppose that you want to find the average (in <code>double</code>) of the integers between <code>1</code> and <code>100</code>. Study the following codes:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td>
<pre>
public class Sum1To100 {
   public static void main(String[] args) {
      int sum = 0;
      double average;
      int number = 1;
      while (number &lt;= 100) {
         sum += number;     <span class="color-comment"> // Final sum is int 5050</span>
         ++number;
      }
      average = sum / 100;  <span class="color-comment"> // Won't work (average = 50.0 instead of 50.5)</span>
      System.out.println(&quot;Average is &quot; + average); <span class="color-comment"> // Average is 50.0</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This is because both the <code>sum</code> and <code>100</code> are <code>int</code>. The result of division is an <code>int</code>, which is then implicitly casted to <code>double</code> and assign to the <code>double</code> variable <code>average</code>.  To get the correct answer, you can do either:</p>

<pre class="color-example" >
average = (double)sum / 100;     <span class="color-comment">// Cast sum from int to double before division</span>
average = sum / (double)100;     <span class="color-comment">// Cast 100 from int to double before division</span>
average = sum / 100.0;
average = (double)(sum / 100);   <span class="color-comment">// Won't work. why?</span></pre>

<h4>Compound Assignment Operators</h4>

<p>Besides the usual simple assignment operator (<code>=</code>) described earlier, Java also provides the so-called <em>compound assignment operator</em>s as listed:</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operation</th>
  <th>Description</th>
  <th>Usage</th>
  <th>Example</th>
  </tr>
<tr>
  <td class="text-center"><span class="font-code">=</span></td>
  <td>Assignment<br />Assign the value of the LHS to the variable at the RHS</td>
  <td><span class="font-code"><em>var</em> = <em>expr</em></span></td>
  <td><span class="font-code">x = 5;</span></td>
  </tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">+=</span></td>
  <td>Compound addition and assignment</td>
  <td><span class="font-code"><em>var</em> += <em>expr</em></span><br />same as<span class="font-code"> <em>var</em> = <em>var</em> + <em>expr</em></span></td>
  <td><span class="font-code">x += 5;<br /></span> same as <span class="font-code">x = x + 5</span></td>
  </tr>
<tr>
  <td class="text-center"><span class="font-code">-=</span></td>
  <td>Compound subtraction and assignment</td>
  <td><span class="font-code"><em>var</em> -= <em>expr</em></span><br />
    same as<span class="font-code"> <em>var</em> = <em>var</em> - <em>expr</em></span></td>
  <td><span class="font-code">x -= 5;<br /></span> same as <span class="font-code">x = x - 5</span></td>
  </tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">*=</span></td>
  <td>Compound multiplication and assignment</td>
  <td><span class="font-code"><em>var</em> *= <em>expr</em></span><br />
    same as<span class="font-code"> <em>var</em> = <em>var</em> * <em>expr</em></span></td>
  <td><span class="font-code">x *= 5;<br /></span> same as <span class="font-code">x = x * 5</span></td>
  </tr>
<tr>
  <td class="text-center"><span class="font-code">/=</span></td>
  <td>Compound division and assignment</td>
  <td><span class="font-code"><em>var</em> /= <em>expr</em></span><br />
    same as<span class="font-code"> <em>var</em> = <em>var</em> / <em>expr</em></span></td>
  <td><span class="font-code">x /= 5;<br /></span> same as <span class="font-code">x = x / 5</span></td>
  </tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">%=</span></td>
  <td>Compound remainder (modulus) and assignment</td>
  <td><span class="font-code"><em>var</em> %= <em>expr</em></span><br />
    same as<span class="font-code"> <em>var</em> = <em>var</em> % <em>expr</em></span></td>
  <td><span class="font-code">x %= 5;<br /></span> same as <span class="font-code">x = x % 5</span></td>
  </tr>
</table>

<h4>Increment/Decrement</h4>

<p>Java supports these <em>unary</em> arithmetic operators: increment (<code>++</code>) and decrement (<code>--</code>) for all numeric primitive types (<code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code> and <code>double</code>, except <code>boolean</code>).</p>
<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Description</th>
  <th>Example</th>
  </tr>
<tr>
  <td class="text-center"><span class="font-code">++</span></td>
  <td>Increment the value of the variable by 1.<br />
    <span class="font-code">x++</span> or <span class="font-code">++x</span> is the same as <span class="font-code">x += 1</span> or <span class="font-code">x = x + 1</span></td>
  <td><span class="font-code">int x = 5;<br />
  x++; <span class="color-comment">// x is 6</span><br />
      ++x; <span class="color-comment">// x is 7</span></span></td>
  </tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">--</span></td>
  <td>Decrement the value of the variable by 1.<br />
    <span class="font-code">x--</span> or <span class="font-code">--x</span> is the same as <span class="font-code">x -= 1</span> or <span class="font-code">x = x - 1</span></td>
  <td><span class="font-code">int y = 6;<br />
  y--; <span class="color-comment">// y is 5</span><br />
  --y; <span class="color-comment">// y is 4</span></span></td>
  </tr>
</table>

<p>The increment (<code>++</code>) and decrement (<code>--</code>) operate on its operand and store the result back to its operand. For example, <code>x++</code> retrieves x, increment and stores the result back to x. Writing <code>x = x++</code> is a logical error!!!</p>

<p>Unlike other unary operator (such as negate (<code>-</code>)) which promotes <code>byte</code>, <code>short</code> and <code>char</code> to <code>int</code>,  the increment and decrement do not promote its operand (because there is no such need).</p>

<p>The increment/decrement unary operator can be placed before the operand (prefix), or after the operands (postfix), which affects its <em>resultant value</em>.</p>

<ul>
<li>If these operators are used by themselves (e.g., <code>x++</code> or <code>++x</code>), the outcomes are the same for pre- and post-operators, because the resultant values are discarded.</li>

<li>If '++' or '--' involves another operation (e.g., <code>y=x++</code> or <code>y=++x</code>), then pre- or post-order is important to specify the order of the two operations:</li>
</ul>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Description</th>
  <th>Example</th>
  </tr>
<tr>
  <td class="text-center"><span class="font-code">++var</span></td>
  <td>Pre-Increment<br />Increment <em>var</em>, then use the new value of <em>var</em></td>
  <td><span class="font-code">y = ++x;</span><br />same as<span class="font-code"> x=x+1; y=x;</span></td>
  </tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">var++</span></td>
  <td>Post-Increment<br />
  Use the old value of <em>var</em>, then increment <em>var</em></td>
  <td><span class="font-code">y = x++;<br />same as<span class="font-code"> oldX=x; x=x+1; y=oldX;</span></span></td>
  </tr>
<tr>
  <td class="text-center"><span class="font-code">--var</span></td>
  <td>Pre-Decrement</td>
  <td><span class="font-code">y = --x;<br />same as x=x-1; y=x;</span></td>
  </tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">var--</span></td>
  <td>Post-Decrement</td>
  <td><span class="font-code">y = x--;<br />same as oldX=x; x=x-1; y=oldX;</span></td>
  </tr>
</table>

<p>For examples,</p>

<pre class="color-example">
x = 5;
System.out.println(x++);  <span class="color-comment">// Print x (5), then increment x (=6). Output is 5. (x++ returns the oldX.)</span>
x = 5;
System.out.println(++x);  <span class="color-comment">// Increment x (=6), then print x (6). Output is 6. (++x returns x+1.)</span></pre>

<p>Prefix operator (e.g, <code>++i</code>) could be more efficient than postfix operator (e.g., <code>i++</code>)?!</p>

<h4>Relational and Logical Operators</h4>
<p>Very often, you need to compare two values before deciding on the action to be taken, e.g. if mark is more than or equals to 50, print &quot;PASS!&quot;.</p>
<p>Java provides six <em>comparison operators</em> (or <em>relational operators</em>):</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Description</th>
  <th>Usage</th>
  <th>Example (x=5, y=8)</th>
</tr>
<tr>
  <td class="text-center"><span class="font-code"><strong>==</strong></span></td>
  <td>Equal to</td>
  <td><span class="font-code"><em>expr1</em> == <em>expr2</em></span></td>
  <td><span class="font-code">(x == y) &rarr; false</span></td>  
</tr>

<tr class="tr-alt">
  <td class="text-center"><span class="font-code"><strong>!=</strong></span></td>
  <td>Not Equal to</td>
  <td><span class="font-code"><em>expr1</em> != <em>expr2</em></span></td>
  <td><span class="font-code">(x != y) &rarr; true</span></td>  
</tr>

<tr>
  <td class="text-center"><span class="font-code"><strong>&gt;</strong></span></td>
  <td>Greater than</td>
  <td><span class="font-code"><em>expr1</em> &gt; <em>expr2</em></span></td>
  <td><span class="font-code">(x &gt; y) &rarr; false</span></td>  
</tr>

<tr class="tr-alt">
  <td class="text-center"><span class="font-code"><strong>&gt;=</strong></span></td>
  <td>Greater than or equal to</td>
  <td><span class="font-code"><em>expr1</em> &gt;= <em>expr2</em></span></td>
  <td><span class="font-code">(x &gt;= 5) &rarr; true</span></td>  
</tr>

<tr>
  <td class="text-center"><span class="font-code"><strong>&lt;</strong></span></td>
  <td>Less than</td>
  <td><span class="font-code"><em>expr1</em> &lt; <em>expr2</em></span></td>
  <td><span class="font-code">(y &lt; 8) &rarr; false</span></td>  
</tr>

<tr>
  <td class="text-center"><span class="font-code"><strong>&lt;=</strong></span></td>
  <td>Less than or equal to</td>
  <td><span class="font-code"><em>expr1</em> &gt;= <em>expr2</em></span></td>
  <td><span class="font-code">(y &lt;= 8) &rarr; true</span></td>  
</tr>
</table>

<p>In Java, these comparison operations returns a <code>boolean</code>  value of either <code>true</code> or <code>false</code>.</p>

<p>Each comparison operation involves two operands, e.g., <code>x &lt;= 100</code>. It is invalid to write <code>1 &lt; x &lt; 100</code> in programming. Instead, you need to break out the two comparison operations <code>x &gt; 1</code>, <code>x &lt; 100</code>, and join with with a logical AND operator, i.e., <code>(x &gt; 1) &amp;&amp; (x &lt; 100)</code>, where <code>&amp;&amp;</code> denotes AND operator.</p>
<p>Java provides four logical operators, which operate on <code>boolean</code> operands only, in descending order of precedences, as follows:</p>

<table class="table-zebra" style="width:60%">
  <tr>
    <th>Operator</th>
    <th>Description</th>
    <th>Usage</th>
    </tr>
  <tr>
    <td class="text-center"><span class="font-code">!</span></td>
    <td>Logical NOT</td>
    <td><span class="font-code">!<em>booleanExpr</em></span></td>
    </tr>
  <tr class="tr-alt">
    <td class="text-center"><span class="font-code">^</span></td>
    <td>Logical XOR</td>
    <td><span class="font-code"><em>booleanExpr1</em> ^ <em>booleanExpr2</em></span></td>
    </tr>
  <tr>
    <td class="text-center"><span class="font-code">&amp;&amp;</span></td>
    <td>Logical AND</td>
    <td><span class="font-code"><em>booleanExpr1</em> &amp;&amp; <em>booleanExpr2</em></span></td>
  </tr>
  <tr class="tr-alt">
    <td class="text-center"><span class="font-code">||</span></td>
    <td>Logical OR</td>
    <td><span class="font-code"><em>booleanExpr1</em> || <em>booleanExpr2</em></span></td>
    </tr>
</table>

<p> The truth tables are as follows:</p>

<table class="table-zebra" style="width:30%">
<tr>
<th>AND <span class="font-code">(&amp;&amp;)</span></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<th>true</th>
<td class="text-center">true</td>
<td class="text-center">false</td>
</tr>
<tr>
<th>false</th>
<td class="text-center">false</td>
<td class="text-center">false</td>
</tr>
</table>
<br />

<table class="table-zebra" style="width:30%">
<tr>
<th>OR <span class="font-code">(||)</span></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<th>true</th>
<td class="text-center">true</td>
<td class="text-center">true</td>
</tr>
<tr>
<th>false</th>
<td class="text-center">true</td>
<td class="text-center">false</td>
</tr>
</table>

<br />

<table class="table-zebra" style="width:30%">
<tr>
<th>NOT <span class="font-code">(!)</span></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<td class="text-center">Result</td>
<td class="text-center">false</td>
<td class="text-center">true</td>
</tr>
</table>

<br />

<table class="table-zebra" style="width:30%">
<tr>
<th>XOR <span class="font-code">(^)</span></th>
<th>true</th>
<th>false</th>
</tr>
<tr>
<th>true</th>
<td class="text-center">false</td>
<td class="text-center">true</td>
</tr>
<tr>
<th>false</th>
<td class="text-center">true</td>
<td class="text-center">false</td>
</tr>
</table>

<p><span class="line-heading">Example:</span></p>

<pre class="color-example">
<span class="color-comment">// Return true if x is between 0 and 100 (inclusive)</span>
(x &gt;= 0) &amp;&amp; (x &lt;= 100)
<span class="color-comment">// wrong to use 0 &lt;= x &lt;= 100</span>
&nbsp; 
<span class="color-comment">// Return true if x is outside 0 and 100 (inclusive)</span>
(x &lt; 0) || (x &gt; 100)   <span class="color-comment">//or</span>
!((x &gt;= 0) &amp;&amp; (x &lt;= 100))
&nbsp;
<span class="color-comment">// Return true if year is a leap year</span>
<span class="color-comment">// A year is a leap year if it is divisible by 4 but not by 100, or it is divisible by 400.</span>
((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0)</pre>

<p><span class="line-heading">Exercise:</span> Study the following program, and explain its output.</p>
<pre class="color-example">
<span class="color-comment">/*
 * Test relational and logical operators
 */</span>
public class <strong>RelationalLogicalOpTest</strong> {
   public static void main(String[] args) {
      int age = 18;
      double weight = 71.23;
      int height = 191;
      boolean married = false;
      boolean attached = false;
      char gender = 'm';
      
      System.out.println(!married &amp;&amp; !attached &amp;&amp; (gender == 'm')); 
      System.out.println(married &amp;&amp; (gender == 'f'));
      System.out.println((height &gt;= 180) &amp;&amp; (weight &gt;= 65) &amp;&amp; (weight &lt;= 80));
      System.out.println((height &gt;= 180) || (weight &gt;= 90));
   }
}</pre>

<p>Write an expression for all unmarried male, age between 21 and 35, with height above 180, and weight between 70 and 80.</p>

<p><span class="line-heading">Exercise:</span> Given the year, month (1-12), and day (1-31), write a boolean expression which returns true for dates before October 15, 1582 (Gregorian calendar cut over date).</p>
<p>Ans: <code>(year &lt; 1582) || (year == 1582 &amp;&amp; month &lt; 10) || (year == 1582 &amp;&amp; month == 10 &amp;&amp; day &lt; 15)</code></p>

<h5>Operator Precedence</h5>

<p>The precedence from highest to lowest is: <code>'!'</code> (unary), <code>'^'</code>, <code>'&amp;&amp;'</code>, <code>'||</code>'. But when in doubt, use parentheses!</p>

<pre class="color-example">
System.out.println(true || true &amp;&amp; false);    <span class="color-comment">// true (same as below)</span>
System.out.println(true || (true &amp;&amp; false));  <span class="color-comment">// true</span>
System.out.println((true || true) &amp;&amp; false);  <span class="color-comment">// false</span>
 
System.out.println(false &amp;&amp; true ^ true);     <span class="color-comment">// false (same as below)</span>
System.out.println(false &amp;&amp; (true ^ true));   <span class="color-comment">// false</span>
System.out.println((false &amp;&amp; true) ^ true);   <span class="color-comment">// true</span></pre>

<h5>Short-Circuit Operation</h5>

<p>The logical AND (<code>&amp;&amp;</code>) and OR (<code>||</code>) operators are known as short-circuit operators, meaning that the right operand will not be evaluated if the result can be determined by the left operand. For example, <code>false &amp;&amp; ...</code> gives <code>false</code>; <code>true || ...</code> give <code>true</code> without evaluating the right operand. This may have adverse consequences if you rely on the right operand to perform certain operations, e.g. <code>false &amp;&amp; (++i &lt; 5)</code> but <code>++i</code> will not be evaluated.</p>

<h3><span class="font-code">String</span>s</h3>

<p>A <code>String</code> is a sequence of characters. A string literal is surrounded by a pair of double quotes, e.g.,</p>

<pre class="color-example">
String s1 = &quot;Hi, This is a string!&quot;  <span class="color-comment">// String literals are enclosed in double quotes</span>
String s2 = &quot;&quot;                       <span class="color-comment">// An empty string</span></pre>

<p>You need to use an escape sequence for special control characters (such as newline <code>\n</code> and tab <code>\t</code>), double-quote <code>\&quot;</code> and backslash <code>\\</code> (due to conflict) and Unicode character <code>\u<em>hhhh</em></code> (if your editor does not support Unicode input), e.g.,</p>

<pre class="color-example">
String s3 = &quot;A \&quot;string\&quot; nested \\inside\\ a string&quot;
String s4 = &quot;Hello, \u60a8\u597d!&quot;   <span class="color-comment">// &quot;Hello, 您好!&quot;</span></pre>

<p>Single-quote (<code>'</code>) does not require an escape sign.</p>

<pre class="color-example">
String s5 = &quot;Hi, I'm a string!&quot;      <span class="color-comment">// Single quote OK</span></pre>

<h4><span class="font-code">String</span> and <span class="font-code">'+'</span> Operator</h4>

<p>In Java, <code>'+'</code> is a special operator. It is <em>overloaded</em>. <em>Overloading</em> means that it carries out different operations depending on the types of its two operands.</p>

<ul>
<li>If both operands are numbers (<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>), <code>'+'</code> performs the usual <em>addition</em>, e.g.,

<pre class="color-example">
1 + 2 &rarr; 3
1.2 + 2.2 &rarr; 3.4
1 + 2.2 &rarr; 1.0 + 2.2 &rarr; 3.2</pre></li>

<li>If both operands are <code>String</code>s, <code>'+'</code> <em>concatenates</em> the two Strings and returns the concatenated <code>String</code>. E.g.,

<pre class="color-example">
&quot;Hello&quot; + &quot;world&quot; &rarr; &quot;Helloworld&quot;
&quot;Hi&quot; + &quot;, &quot; + &quot;world&quot; + &quot;!&quot; &rarr; &quot;Hi, world!&quot;</pre></li>

<li>If one of the operand is a <code>String</code> and the other is numeric, the numeric operand will be converted to <code>String</code> and the two <code>String</code>s concatenated, e.g.,

<pre class="color-example">
&quot;The number is &quot; + 5 &rarr; &quot;The number is &quot; + &quot;5&quot; &rarr; &quot;The number is 5&quot;
&quot;The average is &quot; + average + &quot;!&quot; (suppose average=5.5) &rarr; &quot;The average is &quot; + &quot;5.5&quot; + &quot;!&quot; &rarr; &quot;The average is 5.5!&quot;
&quot;How about &quot; + a + b (suppose a=1, b=1) &rarr; &quot;How about 11&quot;</pre></li>
</ul>

<h4><span class="font-code">String</span> Operations</h4>

<p>The most commonly-used <code>String</code> methods are:</p>

<ul>
<li><code>length()</code>: return the length of the string.</li>

<li><code>charAt(int index)</code>: return the <code>char</code> at the <code>index</code> position (index begins at <code>0</code> to <code>length()-1</code>).</li>

<li><code>equals()</code>: for comparing the contents of two strings. Take note that you cannot use <code>&quot;==&quot;</code> to compare two strings.</li>
</ul>

<p>For examples,</p>

<pre class="color-example">
String str = &quot;Java is cool!&quot;;
System.out.println(str.length());       <span class="color-comment">// return int 13</span>
System.out.println(str.charAt(2));      <span class="color-comment">// return char 'v'</span>
System.out.println(str.charAt(5));      <span class="color-comment">// return char 'i'</span>
&nbsp;
<span class="color-comment">// Comparing two Strings</span>
String anotherStr = &quot;Java is COOL!&quot;;
<span class="color-comment"></span>System.out.println(str.equals(anotherStr));           <span class="color-comment">// return boolean false</span>
System.out.println(str.equalsIgnoreCase(anotherStr)); <span class="color-comment">// return boolean true</span>
System.out.println(anotherStr.equals(str));           <span class="color-comment">// return boolean false</span>
System.out.println(anotherStr.equalsIgnoreCase(str)); <span class="color-comment">// return boolean true</span>
<span class="color-comment">// (str == anotherStr) to compare two Strings is WRONG!!!</span></pre>

<p>To check all the available methods for <code>String</code>, open JDK API documentation &rArr; select <em>package</em> &quot;<code>java.lang</code>&quot; &rArr; select <em>class</em> &quot;<code>String</code>&quot; &rArr; choose <em>method</em>. For examples,</p>

<pre class="color-example">
String str = &quot;Java is cool!&quot;;
System.out.println(str.length());            <span class="color-comment">// return int 13</span>
System.out.println(str.charAt(2));           <span class="color-comment">// return char 'v'</span>
System.out.println(str.substring(0, 3));     <span class="color-comment">// return String &quot;Jav&quot;</span>
System.out.println(str.indexOf('a'));        <span class="color-comment">// return int 1</span>
System.out.println(str.lastIndexOf('a'));    <span class="color-comment">// return int 3</span>
System.out.println(str.endsWith(&quot;cool!&quot;));   <span class="color-comment">// return boolean true</span>
System.out.println(str.toUpperCase());       <span class="color-comment">// return a new String &quot;JAVA IS COOL!&quot;</span>
System.out.println(str.toLowerCase());       <span class="color-comment">// return a new String &quot;java is cool!&quot;</span></pre>

<h4><span class="font-code">String</span>/Primitive Conversion</h4>

<p><span class="line-heading">&quot;<span class="font-code">String</span>&quot; to &quot;<span class="font-code">int/byte/short/long</span>&quot;</span>: You could use the JDK built-in methods <code>Integer.parseInt(<em>anIntStr</em>)</code> to convert a <code>String</code> containing a valid integer literal (e.g., &quot;<code>1234</code>&quot;) into an <code>int</code> (e.g., <code>1234</code>). The runtime triggers a <code>NumberFormatException</code> if the input string does not contain a valid integer literal (e.g., &quot;<code>abc</code>&quot;). For example,</p>

<pre class="color-example">
String inStr = &quot;5566&quot;;
int number = Integer.parseInt(inStr);   <span class="color-comment">// number &lt;- 5566</span>
<span class="color-comment">// Input to Integer.parseInt() must be a valid integer literal</span>
<span class="color-error">number = Integer.parseInt(&quot;abc&quot;);</span>       <span class="color-comment">// Runtime Error: NumberFormatException</span></pre>

<p>Similarly, you could use methods <code>Byte.parseByte(<em>aByteStr</em>)</code>, <code>Short.parseShort(<em>aShortStr</em>)</code>, <code>Long.parseLong(<em>aLongStr</em>)</code> to convert a string containing a valid <code>byte</code>, <code>short</code> or <code>long</code> literal to the primitive type.</p>

<p><span class="line-heading">&quot;<span class="font-code">String</span>&quot; to &quot;<span class="font-code">double</span>/<span class="font-code">float</span>&quot;</span>: You could use <code>Double.parseDouble(<em>aDoubleStr</em>)</code> or <code>Float.parseFloat(<em>aFloatStr</em>)</code> to convert a <code>String</code> (containing a floating-point literal) into a <code>double</code> or <code>float</code>, e.g.</p>

<pre class="color-example">
String inStr = &quot;55.66&quot;;
float aFloat = Float.parseFloat(inStr);         <span class="color-comment">// aFloat &lt;- 55.66f</span>
double aDouble = Double.parseDouble(&quot;1.2345&quot;);  <span class="color-comment">// aDouble &lt;- 1.2345</span>
<span class="color-error">aDouble = Double.parseDouble(&quot;abc&quot;);</span>            <span class="color-comment">// Runtime Error: NumberFormatException</span></pre>

<p><span class="line-heading">&quot;<span class="font-code">String</span>&quot; to &quot;<span class="font-code">char</span>&quot;</span>: You can use <code><em>aStr</em>.charAt(<em>index</em>)</code> to extract individual character from a <code>String</code>, e.g.,</p>

<pre class="color-example">
<span class="color-comment">// Converting from binary to decimal</span>
String msg = &quot;101100111001!&quot;;
int pos = 0;
while (pos &lt; msg.length()) {
   char binChar = msg.charAt(pos);   <span class="color-comment">// Extract character at pos</span>
   <span class="color-comment">// Do something about the character</span>
   .......
   ++pos;
}</pre>

<p><span class="line-heading">&quot;<span class="font-code">String</span>&quot; to &quot;<span class="font-code">boolean</span>&quot;</span>: You can use method <code>Boolean.parseBoolean(<em>aBooleanStr</em>)</code> to convert string of &quot;<code>true</code>&quot; or &quot;<code>false</code>&quot; to <code>boolean</code> <code>true</code> or <code>false</code>, e.g.,</p>

<pre class="color-example">
String boolStr = &quot;true&quot;;
boolean done = Boolean.parseBoolean(boolStr);  <span class="color-comment">// done &lt;- true</span>
boolean valid = Boolean.parseBoolean(&quot;false&quot;); <span class="color-comment">// valid &lt;- false</span></pre>

<p><span class="line-heading">Primitive (<span class="font-code">int/double/float/byte/short/long/char/boolean</span>) to &quot;<span class="font-code">String</span>&quot;</span>: To convert a primitive to a <code>String</code>, you can use the '+' operator to concatenate the primitive with an <em>empty</em> <code>String (&quot;&quot;)</code>, or use the JDK built-in methods <code>String.valueOf(<em>aPrimitve</em>)</code>, <code>Integer.toString(<em>anInt</em>)</code>, <code>Double.toString(<em>aDouble</em>)</code>, <code>Character.toString(<em>aChar</em>)</code>, <code>Boolean.toString(<em>aBoolean</em>)</code>, etc. For example,</p>

<pre class="color-example">
<span class="color-comment">// String concatenation operator '+' (applicable to ALL primitive types)</span>
String s1 = 123 + &quot;&quot;;    <span class="color-comment">// int 123 -&gt; &quot;123&quot;</span>
String s2 = 12.34 + &quot;&quot;;  <span class="color-comment">// double 12.34 -&gt; &quot;12.34&quot;</span>
String s3 = 'c' + &quot;&quot;;    <span class="color-comment">// char 'c' -&gt; &quot;c&quot;</span>
String s4 = true + &quot;&quot;;   <span class="color-comment">// boolean true -&gt; &quot;true&quot;</span>
 
<span class="color-comment">// String.valueOf(<em>aPrimitive</em>) is applicable to ALL primitive types</span>
String s1 = String.valueOf(12345);   <span class="color-comment">// int 12345 -&gt; &quot;12345&quot;</span>
String s2 = String.valueof(true);    <span class="color-comment">// boolean true -&gt; &quot;true&quot;</span>
double d = 55.66;
String s3 = String.valueOf(d);       <span class="color-comment">// double 55.66 -&gt; &quot;55.66&quot;</span>
 
<span class="color-comment">// toString() for each primitive type</span>
String s4 = Integer.toString(1234);  <span class="color-comment">// int 1234 -&gt; &quot;1234&quot;</span>
String s5 = Double.toString(1.23);   <span class="color-comment">// double 1.23 -&gt; &quot;1.23&quot;</span>
char c1   = Character.toString('z'); <span class="color-comment">// char 'z' -&gt; &quot;z&quot;</span>
 
<span class="color-comment">// char to String</span>
char c = 'a';
String s5 = c;       <span class="color-comment">// Compilation Error: incompatible types</span>
String s6 = c + &quot;&quot;;  <span class="color-comment">// Convert the char to String</span>
 
<span class="color-comment">// boolean to String</span>
boolean done = false;
String s7 = done + &quot;&quot;;    <span class="color-comment">// boolean false -&gt; &quot;false&quot;</span>
String s8 = Boolean.toString(done);
String s9 = String.valueOf(done);</pre>

<p><span class="line-heading">&quot;<span class="font-code">char</span>&quot; to &quot;<span class="font-code">int</span>&quot;</span>: You can convert char <code>'0'</code> to <code>'9'</code> to <code>int</code> <code>0</code> to <code>9</code> by subtracting the <code>char</code> with <code>'0'</code> (e.g., <code>'8'-'0' &rarr; 8</code>).</p>

<h3>Flow Control</h3>

<p>There are three basic flow control constructs - <em>sequential</em>, <em>conditional</em> (or <em>decision</em>), and <em>loop</em> (or <em>iteration</em>), as illustrated below.</p>

<img class="image-center" src="images/Flowchart_FlowControl.png" alt="structure constructs" />

<h4>Sequential Flow Control</h4>

<p>A program is a sequence of instructions. <em>Sequential</em> flow is the most common and straight-forward, where programming statements are executed in the order that they are written - from top to bottom in a sequential manner.</p>

<h4>Conditional Flow Control</h4>

<p>There are a few types of conditionals, <em>if-then</em>, <em>if-then-else</em>, <em>nested-if</em> (<em>if-elseif-elseif-...-else</em>), <em>switch-case</em>, and <em>conditional expression</em>.</p>

<table class="table-program">
<tr>
<th>Syntax</th>
<th>Example</th>
<th>Flowchart</th>
</tr>

<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// if-then</span>
<strong>if (</strong> <em>booleanExpression</em><em></em> <strong>) {</strong>
   <em>true-block</em> <strong>;</strong>
<strong>}</strong>
</pre>
</td>
<td>
<pre class="color-explanation">if (mark &gt;= 50) {
   System.out.println(&quot;Congratulation!&quot;);
   System.out.println(&quot;Keep it up!&quot;);
}</pre>
</td>
<td>
<img src="images/Flowchart_IfThen.png" alt="Flowchart_IfThen.png" />
</td>
</tr>
<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// if-then-else</span>
<strong>if (</strong> <em>booleanExpression</em><em></em> <strong>) {</strong>
   <em>true-block</em> <strong>;</strong>
<strong>} else {</strong>
   <em>false-block</em> <strong>;</strong>
<strong>}</strong></pre>
</td>
<td>
<pre class="color-explanation">if (mark &gt;= 50) {
   System.out.println(&quot;Congratulation!&quot;);
   System.out.println(&quot;Keep it up!&quot;);
} else {
   System.out.println(&quot;Try Harder!&quot;);
}</pre>
</td>
<td>
<img src="images/Flowchart_IfElse.png" alt="Flowchart_IfElse.png" />
</td>
</tr>
<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// nested-if</span>
<strong>if (</strong> <em>booleanExpr-1</em> <strong>) {</strong>
   <em>block-1</em> <strong>;
} else if (</strong> <em>booleanExpr-2</em> <strong>) {</strong>
   <em>block-2</em> <strong>;
} else if (</strong> <em>booleanExpr-3</em> <strong>) {</strong>
   <em>block-3</em> <strong>;
} else if (</strong> <em>booleanExpr-4</em> <strong>) {</strong>
   ......<strong>
} else {</strong>
   <em>elseBlock</em> <strong>;
}</strong></pre>
</td>
<td>
<pre class="color-explanation">if (mark &gt;= 80) {
   System.out.println(&quot;A&quot;);
} else if (mark &gt;= 70) {
   System.out.println(&quot;B&quot;);
} else if (mark &gt;= 60) {
   System.out.println(&quot;C&quot;);
} else if (mark &gt;= 50) {
   System.out.println(&quot;D&quot;);
} else {
   System.out.println(&quot;F&quot;);
}
   </pre>
</td>
<td>
<img src="images/Flowchart_NestedIf.png" alt="Flowchart_NestedIf.png" />
</td>
</tr>
<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// switch-case-default</span>
<strong>switch (</strong> <em>selector</em><em></em> <strong>) {
   case</strong> <em>value-1</em><strong>:</strong>
      <em>block-1</em><strong>; break;
   case</strong> <em>value-2</em><strong>:</strong>
      <em>block-2</em><strong>; break;
   case</strong> <em>value-3</em><strong>:</strong>
      <em>block-3</em><strong>; break;</strong>
   ......
<strong>   case</strong> <em>value-n</em><strong>:</strong>
      <em>block-n</em><strong>; break;</strong>
<strong>   default:</strong>
      <em>default-block</em><strong>;
}</strong></pre>
</td>
<td>
<pre class="color-explanation">char oper; int num1, num2, result;
......
switch (oper) {
   case '+': 
      result = num1 + num2; break;
   case '-': 
      result = num1 - num2; break;
   case '*': 
      result = num1 * num2; break;
   case '/': 
      result = num1 / num2; break;
   default:
      System.err.println(&quot;Unknown operator);
}</pre>
</td>
<td>
<img src="images/Flowchart_SwitchCase.png" alt="Flowchart_SwitchCase.png" />
</td>
</tr>
</table>

<p><span class="line-heading">Braces:</span> You could omit the braces <code>{ }</code>, if there is only one statement inside the block. However, I recommend that you keep the braces to improve the readability of your program. For example,</p>

<pre class="color-example">
if (mark &gt;= 50) 
   System.out.println(&quot;PASS&quot;);   <span class="color-comment">// Only one statement, can omit { } but NOT recommended</span>
else {                           <span class="color-comment">// More than one statements, need { }</span>
   System.out.println(&quot;FAIL&quot;);
   System.out.println(&quot;Try Harder!&quot;);
}</pre>

<h5>&quot;<span class="font-code">switch-case-default</span>&quot;</h5>

<p>&quot;switch-case&quot; is an alternative to the &quot;nested-if&quot;. In a <em>switch-case</em> statement, a <code>break</code> statement is needed for each of the cases. If <code>break</code> is missing, execution will flow through the following case.  You can use an <code>int</code>, <code>byte</code>, <code>short</code>, or <code>char</code> variable as the case-<em>selector</em>, but NOT <code>long</code>, <code>float</code>, <code>double</code> and <code>boolean</code>. (JDK 1.7 supports <code>String</code> as the case-selector).</p>

<h4>Conditional Operator (<span class="font-code">? :</span>)</h4>

<p>A conditional operator is a ternary (3-operand) operator, in the form of <code><em>booleanExpr</em> ? <em>trueExpr</em> : <em>falseExpr</em></code>. Depending on the <code><em>booleanExpr</em></code>, it evaluates and returns the value of <em><code>trueExpr</code></em> or <code><em>falseExpr</em></code>.</p> 

<table class="table-program">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>

<tr>
<td>
<pre class="color-syntax">
<span class="color-comment"></span><em>booleanExpr</em> <strong>?</strong> <em>trueExpr</em> <strong>:</strong> <em>falseExpr</em>
 
 </pre>
</td>
<td>
<pre class="color-explanation">System.out.println((mark &gt;= 50) ? &quot;PASS&quot; : &quot;FAIL&quot;);
max = (a &gt; b) ? a : b;   <span class="color-comment">// RHS returns a or b</span>
abs = (a &gt; 0) ? a : -a;  <span class="color-comment">// RHS returns a or -a</span></pre>
</td>
</tr>
</table>


<h4>Exercises on Conditional</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseConditional">LINK TO EXERCISES ON CONDITIONAL FLOW CONTROL</a></p>

<h4>Loop Flow Control</h4>

<p>Again, there are a few types of loops: <em>for</em>, <em>while-do</em>, and <em>do-while</em>.</p>

<table class="table-program">

<tr>
<th>Syntax</th>
<th>Example</th>
<th>Flowchart</th>
</tr>

<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// for-loop</span>
<strong>for (</strong><em>initialization</em><strong>;</strong> <em>test</em><strong>;</strong> <em>post-processing</em><strong>) {</strong>
   <em>body</em><strong>;</strong>
<strong>}</strong>
&nbsp;</pre>
</td>
<td>
<pre class="color-explanation">
<span class="color-comment">// Sum from 1 to 1000</span>
int sum = 0;
for (int number = 1; number &lt;= 1000; ++number) {
   sum += number;
}</pre>
</td>
<td>
<img src="images/Flowchart_For.png" alt="Flowchart_For.png" />
</td>
</tr>
<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// while-do loop</span>
<strong>while (</strong> <em>test</em> <strong>) {</strong>
   <em>body</em><strong>;
}</strong>
&nbsp;</pre>
</td>
<td>
<pre class="color-explanation">int sum = 0, number = 1;
while (number &lt;= 1000) {
   sum += number;
   ++number;
}</pre>
</td>
<td>
<img src="images/Flowchart_While.png" alt="Flowchart_While.png" />
</td>
</tr>
<tr>
<td>
<pre class="color-syntax">
<span class="color-comment">// do-while loop</span>
<strong>do {</strong>
   <em>body</em><strong>;
}
while (</strong> <em>test</em> <strong>) ;</strong></pre>
</td>
<td>
<pre class="color-explanation">int sum = 0, number = 1;
do {
   sum += number;
   ++number;
} while (number &lt;= 1000);</pre>
</td>
<td>
<img src="images/Flowchart_DoWhile.png" alt="Flowchart_DoWhile.png" />
</td>
</tr>
</table>

<p>The difference between <em>while-do</em> and <em>do-while</em> lies in the order of the <em>body</em> and <em>condition</em>. In <em>while-do</em>, the <em>condition</em> is tested first. The body will be executed if the <em>condition</em> is true and the process repeats.  In <em>do-while</em>, the <em>body</em> is executed and then the <em>condition</em> is tested. Take note that the <em>body</em> of <em>do-while</em> will be executed at least once vs. possibly zero for <em>while-do</em>. Similarly, the for-loop's body could possibly not executed.</p>

<p><span class="line-heading">Example:</span> Suppose that your program prompts user for a number between <code>1</code> to <code>10</code>, and checks for valid input. A do-while loop with a <code>boolean</code> flag could be more appropriate as it prompts for input at least once, and repeat again and again if the input is invalid.</p>
<pre class="color-example">
<span class="color-comment">// Input with validity check</span>
boolean valid = false;
int number;
do {
  <span class="color-comment">// prompt user to enter an int between 1 and 10</span>
  ......
  <span class="color-comment">// if the number entered is valid, set done to exit the loop</span>
  if (number &gt;=1 &amp;&amp; number &lt;= 10) {
     valid = true;
  }
} while (!valid);   <span class="color-comment">// Need a semi-colon to terminate do-while</span></pre> 

<p><span class="line-heading">Example:</span> Below is an example of using while-do with a <code>boolean</code> flag. The <code>boolean</code> flag is initialized to <code>false</code> to ensure that the loop is entered.</p>

<pre class="color-example">
<span class="color-comment">// Game loop</span>
boolean gameOver = false;
while (!gameOver) {
   <span class="color-comment">// play the game</span>
   ......
   <span class="color-comment">// Update the game state 
   // Set gameOver to true if appropriate to exit the game loop</span>
   ......
}</pre>

<h5>Empty for-loop</h5>

<p><code>for ( ; ; ) { <em>body</em> }</code> is known as an <em>empty for-loop</em>, with empty statement for initialization, test and post-processing. The body of the empty for-loop will execute continuously (infinite loop). You need to use a <code>break</code> statement to break out the loop.</p>

<h5>for-loop with Comma Separator</h5>

<p>You could place more than one statement in the initialization and post-processing, separated with commas (instead of the usual semi-colon). For example,</p>

<pre class="color-example">
for (int row = 0, col = 0; row &lt; SIZE; ++row, ++col) {
   <span class="color-comment">// Process diagonal elements</span>
   ......
}</pre>

<h4>Exercises on Loops</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseLoop">LINK TO EXERCISES ON LOOP FLOW CONTROL</a></p>

<h4>&quot;<span class="font-code">break</span>&quot; and &quot;<span class="font-code">continue</span>&quot; - Interrupting Loop Flow</h4>

<p>The <code>break</code> statement breaks out and exits the current (innermost) loop.</p>

<p>The <code>continue</code> statement aborts the current iteration and continue to the next iteration of the current (innermost) loop.</p>

<p><code>break</code> and <code>continue</code> are poor structures as they are hard to read and hard to follow.  Use them only if absolutely necessary.</p>

<p><span class="line-heading">Example (<span class="font-code">break</span>):</span> The following program lists the non-prime numbers between 2 and an upperbound.</p>

<pre class="color-example">
<span class="color-comment">/*
 * List all non-prime numbers between 2 and an upperbound
 */</span>
public class <strong>NonPrimeList</strong> {
   public static void main(String[] args) {
      int upperbound = 100;
      for (int number = 2; number &lt;= upperbound; ++number) {
         <span class="color-comment">// Not a prime, if there is a factor between 2 and sqrt(number)</span>
         int maxFactor = (int)Math.sqrt(number);
         for (int factor = 2; factor &lt;= maxFactor; ++factor) {
            if (number % factor == 0) {   <span class="color-comment">// Factor?</span>
               System.out.println(number + &quot; is NOT a prime&quot;);
               break;   <span class="color-comment">// A factor found, no need to search for more factors</span>
            }
         }
      }
   }
}</pre>

<p>Let's rewrite the above program to list all the primes instead. A <code>boolean</code> flag called <code>isPrime</code> is used to indicate whether the current <code>number</code> is a prime. It is then used to control the printing.</p>

<pre class="color-example">
<span class="color-comment">/*
 * List all prime numbers between 2 and an upperbound
 */</span>
public class <strong>PrimeListWithBreak</strong> {
   public static void main(String[] args) {
      int upperbound = 100;
      for (int number = 2; number &lt;= upperbound; ++number) {
         <span class="color-comment">// Not a prime, if there is a factor between 2 and sqrt(number)</span>
         int maxFactor = (int)Math.sqrt(number);
         boolean isPrime = true;  <span class="color-comment">// boolean flag to indicate whether number is a prime</span>
         for (int factor = 2; factor &lt;= maxFactor; ++factor) {
            if (number % factor == 0) {   <span class="color-comment">// Factor?</span>
               isPrime = false;   <span class="color-comment">// number is not a prime</span>
               break;   <span class="color-comment">// A factor found, no need to search for more factors</span>
            }
         }
         if (isPrime) System.out.println(number + &quot; is a prime&quot;);
      }
   }
}</pre>

<p>Let's rewrite the above program without using <code>break</code> statement. A <code>while</code> loop is used (which is controlled by the <code>boolean</code> flag) instead of <code>for</code> loop with <code>break</code>.</p>

<pre class="color-example">
<span class="color-comment">/*
 * List all prime numbers between 2 and an upperbound
 */</span>
public class <strong>PrimeList</strong> {
   public static void main(String[] args) {
      int upperbound = 100;
      for (int number = 2; number &lt;= upperbound; ++number) {
         <span class="color-comment">// Not prime, if there is a factor between 2 and sqrt of number</span>
         int maxFactor = (int)Math.sqrt(number);
         boolean isPrime = true;
         int factor = 2;
         while (isPrime &amp;&amp; factor &lt;= maxFactor) {
            if (number % factor == 0) {   <span class="color-comment">// Factor of number?</span>
                isPrime = false;
            }
            ++factor;
         }
         if (isPrime) System.out.println(number + &quot; is a prime&quot;);
      }
   }
}</pre>

<p><span class="line-heading">Example (<span class="font-code">continue</span>):</span></p>

<pre class="color-example">
<span class="color-comment">/*
 * Sum 1 to upperbound, exclude 11, 22, 33,...
 */</span>
int upperbound = 100;
int sum = 0;
for (int number = 1; number &lt;= upperbound; ++number) {
   if (number % 11 == 0) continue;  <span class="color-comment">// Skip the rest of the loop body, continue to the next iteration
</span>   sum += number;
}
<span class="color-comment">// It is better to re-write the loop as:</span>
for (int number = 1; number &lt;= upperbound; ++number) {
   if (number % 11 != 0) sum += number;
}</pre>

<p><span class="line-heading">Example (<span class="font-code">break</span> and <span class="font-code">continue</span>):</span> Study the following program.</p>

<pre class="color-example">
<span class="color-comment">/*
 * A mystery series created using break and continue
 */</span>
public class <strong>MysterySeries</strong> {
   public static void main(String[] args) {
      int number = 1;
      while(true) {
         ++number;
         if ((number % 3) == 0) continue;
         if (number == 133) break;
         if ((number % 2) == 0) {
            number += 3;
         } else {
            number -= 3;
         }
         System.out.print(number + &quot; &quot;);
      }
   }
}</pre>

<h5>Labeled <span class="font-code">break</span></h5>

<p>In a nested loop, the <code>break</code> statement breaks out the innermost loop and continue into the outer loop. At times, there is a need to break out all the loops (or multiple loops). This is clumsy to achieve with <code>boolean</code> flag, but can be done easily via the so-called labeled <code>break</code>. You can add a <code>label</code> to a loop in the form of <code><em>labelName</em>: <em>loop</em></code>. For example,</p>

<pre class="color-example">
level1:          <span class="color-comment">// define a label for the level-1 loop</span>
for (.....) {
level2:          <span class="color-comment">// define a label for the level-2 loop</span>
   for (.....) {
      for (......) {  <span class="color-comment">// level-3 loop</span>
         if (...) break level1;  <span class="color-comment">// break all loops, continue after the loop</span>
         if (...) break level2:  <span class="color-comment">// continue into the next statement of level-1 loop</span>
         ......
      }
   }
}</pre>

<h5>Labeled <span class="font-code">continue</span></h5>

<p>In a nested loop, similar to labeled <code>break</code>, you can use labeled continue to continue into a specified loop. For example,</p>

<pre class="color-example">
level1:          <span class="color-comment">// define a label (with : suffix) for the level-1 loop</span>
for (.....) {
level2:          <span class="color-comment">// define a label (with : suffix) for the level-2 loop</span>
   for (.....) {
      for (......) {  <span class="color-comment">// level-3 loop</span>
         if (...) continue level1;  <span class="color-comment">// continue the next iteration of level-1 loop</span>
         if (...) continue level2:  <span class="color-comment">// continue the next iteration of level-2 loop</span>
         ......
      }
   }
}</pre>

<p>Again, labeled <code>break</code> and <code>continue</code> are not structured and hard to read. Use them only if absolutely necessary.</p>

<p><span class="line-heading">Example (Labeled <span class="font-code">break</span>):</span> Suppose that you are searching for a particular number in a 2D array.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
public class TestLabeledBreak {
   public static void main(String[] args) {
      int[][] testArray = {
         {1, 2, 3, 4},
         {4, 3, 1, 4},
         {9, 2, 3, 4}
      };
 
      int magicNumber = 8;
      boolean found = false;
      <span class="color-new">mainLoop:</span>
      for (int i = 0; i &lt; testArray.length; ++i) {
         for (int j = 0; j &lt; testArray[i].length; ++j) {
            if (testArray[i][j] == magicNumber) {
               found = true;
               <span class="color-new">break mainLoop;</span>
            }
         }
      }
      System.out.println(&quot;Magic number &quot; + (found ? &quot;found&quot; : &quot;NOT found&quot;));
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Terminating Program</h4>

<p><span class="line-heading"><span class="font-code">System.exit(int exitCode)</span></span>: You could invoke the method <code>System.exit(int exitCode)</code> to terminate the program and return the control to the Java runtime.  By convention, return code of zero indicates normal termination; while a non-zero <code>exitCode</code> indicates <em>abnormal termination</em>. For example,</p>

<pre class="color-example">
if (errorCount &gt; 10) {
   System.out.println(&quot;too many errors&quot;);
   System.exit(1);  <span class="color-comment">// Terminate the program</span>
}</pre>

<p><span class="line-heading">The <span class="font-code">return</span> statement</span>: You could also use a &quot;<code>return <em>returnValue</em></code>&quot; statement in the <code>main()</code> method to terminate the program and return control back to the Java Runtime.
 For example,</p>

<pre class="color-example">
public static void <strong>main</strong>(String[] args) {
   ...
   if (errorCount &gt; 10) {
      System.out.println(&quot;too many errors&quot;);
      return;  <span class="color-comment">// Terminate and return control to Java Runtime from main()</span>
   }
   ...
}</pre>

<h4>Nested Loops</h4>

<p>Try out the following program, which prints a 8-by-8 checker box pattern using <em>nested loops</em>, as follows:</p>

<pre class="output">
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #
# # # # # # # #</pre>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td>
<td>
<pre>
<span class="color-comment">/*
 * Print a square pattern
 */</span>
public class <strong>PrintSquarePattern</strong> {  <span class="color-comment">  // Save as &quot;PrintSaurePattern.java&quot;</span>
   public static void main(String[] args) {
      int size = 8;
      for (int row = 1; row &lt;= size; ++row) {   <span class="color-comment">  // Outer loop to print all the rows</span>
         for (int col = 1; col &lt;= size; ++col) {  <span class="color-comment">// Inner loop to print all the columns of each row</span>
            System.out.print(&quot;# &quot;);
         }
         System.out.println();   <span class="color-comment">// A row ended, bring the cursor to the next line</span>
      }
   }
}</pre></td>
</tr>
</tbody>
</table>

<p>This program contains two <em>nested</em> for-loops. The inner loop is used to print a row of eight &quot;<code># </code>&quot;, which is followed by printing a newline. The outer loop repeats the inner loop to print all the rows.</p>

<p>Suppose that you want to print this pattern  instead (in program called <code>PrintCheckerPattern</code>):</p>

<pre class="output">
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #
# # # # # # # #
 # # # # # # # #</pre>

<p>You need to print an additional space for even-number rows.  You could do so by adding the following statement before Line 8.</p>
<pre  class="color-example">
if ((row % 2) == 0) {   <span class="color-comment">// print a leading space for even-numbered rows</span>
   System.out.print(&quot; &quot;);
}</pre>

<p><span class="line-heading">TRY:</span></p>
<ol>

<li>Print these patterns using nested loop (in a program called <code>PrintPattern1x</code>). Use a variable called <code>size</code> for the size of the pattern and try out various sizes. You should use as few <code>print()</code> or <code>println()</code> statements as possible.
<pre class="output">
 # * # * # * # *    # # # # # # # #    # # # # # # # #    1                                1
# * # * # * # *     # # # # # # #        # # # # # # #    2 1                            1 2
 # * # * # * # *    # # # # # #            # # # # # #    3 2 1                        1 2 3
# * # * # * # *     # # # # #                # # # # #    4 3 2 1                    1 2 3 4
 # * # * # * # *    # # # #                    # # # #    5 4 3 2 1                1 2 3 4 5
# * # * # * # *     # # #                        # # #    6 5 4 3 2 1            1 2 3 4 5 6
 # * # * # * # *    # #                            # #    7 6 5 4 3 2 1        1 2 3 4 5 6 7
# * # * # * # *     #                                #    8 7 6 5 4 3 2 1    1 2 3 4 5 6 7 8
     (a)                  (b)                (c)                (d)                (e)</pre>
<em>Hints</em>:<br />
The equations for major and opposite diagonals are row = col and row + col = size + 1. Decide on what to print above and below the diagonal.
</li>

<li>Print the timetable of 1 to 9, as follows, using nested loop. (Hints: you need to use an <em>if-else</em> statement to check whether the product is single-digit or double-digit, and print an additional space if needed.)
<pre class="output">
 1  2  3  4  5  6  7  8  9
 2  4  6  8 10 12 14 16 18
 ...... </pre>
</li>

<li>Print these patterns using nested loop.
<pre class="output">
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
#           #        #                          #          #       #        # #       # #
#           #          #                      #              #   #          #   #   #   #
#           #            #                  #                  #            #     #     #
#           #              #              #                  #   #          #   #   #   #
#           #                #          #                  #       #        # #       # #
# # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #      # # # # # # #
     (a)                 (b)               (c)                (d)                (e)</pre>
</li>
</ol>

<h4>Exercises on Nested Loops</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseNestedLoop">LINK TO MORE NESTED-LOOP EXERCISES</a></p>

<h4>Some Issues in Flow Control</h4>

<p><span class="line-heading">Dangling Else</span><strong>:</strong> The &quot;dangling else&quot; problem can be illustrated as follows:</p>

<pre class="color-example">
if (i == 0)
   if (j == 0)
      System.out.println(&quot;i and j are zero&quot;);
else System.out.println(&quot;i is not zero&quot;);   <span class="color-comment">// intend for the outer-if</span></pre>

<p>The <code>else</code> clause in the above codes is syntactically applicable to both the outer-if and the inner-if.  Java compiler always associate the <code>else</code> clause with the innermost if (i.e., the nearest if).  Dangling else can be resolved by applying explicit parentheses. The above codes are logically incorrect and require explicit parentheses as shown below.</p>

<pre class="color-example">
if ( i == 0) {
   if (j == 0) System.out.println(&quot;i and j are zero&quot;);
} else {
   System.out.println(&quot;i is not zero&quot;);   <span class="color-comment">// non-ambiguous for outer-if</span>
}</pre>

<p><span class="line-heading">Endless loop</span><strong>:</strong> The following constructs:</p>

<pre class="color-example">
while (true) { ...... }</pre>

<p>is commonly used.  It seems to be an endless loop (or infinite loop), but it is usually terminated via a <code>break</code> or <code>return</code> statement inside the loop body. This kind of code is hard to read - avoid if possible by re-writing the condition.</p>

<h3>Writing Correct and Good Programs</h3>

<p>It is important to write programs that produce the correct results.  It is also important to write programs that others (and you yourself three days later) can understand, so that the programs can be maintained - I call these programs good programs - a good program is more than a correct program.</p>

<p>Here are the suggestions:</p>

<ul>
<li>Follow established convention so that everyone has the same basis of understanding. To program in Java, you MUTST read the &quot;<a href="http://www.oracle.com/technetwork/java/codeconv-138413.html">Code Convention for the Java Programming Language</a>&quot;.</li>

<li>Format and layout of the source code with appropriate indents, white spaces and white lines. Use 3 or 4 spaces for indent, and blank lines to separate sections of codes.</li>

<li>Choose good names that are self-descriptive and meaningful, e.g., <code>row</code>, <code>col</code>, <code>size</code>, <code>xMax</code>, <code>numStudents</code>. Do not use meaningless names, such as <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>. Avoid single-alphabet names (easier to type but often meaningless), except common names likes x, <code>y</code>, <code>z</code> for co-ordinates and <code>i</code> for index.</li>

<li>Provide comments to explain the important as well as salient concepts. Comment your codes liberally.</li>

<li>Write your program documentation while writing your programs.</li>

<li>Avoid <em>un-structured</em> constructs, such as <code>break</code> and <code>continue</code>, which are hard to follow.</li>

<li> Use &quot;mono-space&quot; fonts (such as Consolas, Courier New, Courier) for writing/displaying your program.</li>
</ul>

<p>It is estimated that over the lifetime of a program, 20 percent of the effort will go into the original creation and testing of the code, and 80 percent of the effort will go into the subsequent maintenance and enhancement. Writing good programs which follow standard conventions is critical in the subsequent maintenance and enhancement!!!</p>

<h4>Programming Errors</h4>

<p>There are generally three classes of programming errors:</p>

<ol>
<li><em>Compilation Error</em> (or <em>Syntax Error</em>): can be fixed easily.</li>

<li><em>Runtime Error</em>: program halts pre-maturely without producing the results - can also be fixed easily.</li>

<li><em>Logical Error</em>: program completes but produces incorrect results. It is easy to detect if the program always produces wrong result. It is extremely hard to fix if the program produces the correct result most of the times, but incorrect result sometimes. For example,

<pre class="color-example">
<span class="color-comment">// Can compile and execute, but give wrong result – sometimes!</span>
if (mark &gt; 50) {
   System.out.println(&quot;PASS&quot;);
} else {
   System.out.println(&quot;FAIL&quot;);
}</pre>
This kind of errors is very serious if it is not caught before production. Writing good programs helps in minimizing and detecting these errors. A good <em>testing strategy</em> is needed to ascertain the correctness of the program. <em>Software testing</em> is an advanced topics which is beyond our current scope.</li>
</ol>

<h4>Debugging Programs</h4>

<p>Here are the common debugging techniques:</p>

<ol>
<li>Stare at the screen! Unfortunately, errors usually won't pop-up even if you stare at it extremely hard.</li>

<li>Study the error messages! Do not close the console when error occurs and pretending that everything is fine. This helps most of the times.</li>

<li>Insert print statements at appropriate locations to display the intermediate results. It works for simple toy program, but it is neither effective nor efficient for complex program.</li>

<li>Use a graphic debugger. This is the most effective means. Trace program execution step-by-step and watch the value of variables and outputs.</li>

<li>Advanced tools such as profiler (needed for checking memory leak and method usage).</li>

<li>Proper program testing to wipe out the logical errors.</li>
</ol>

<h4>Testing Your Program for Correctness</h4>

<p>How to ensure that your program always produces correct result, 100% of the times? It is impossible to try out all the possible outcomes, even for a simple program. Program testing usually involves a set of representative test cases, which are designed to catch the major classes of errors.  Program testing is beyond the scope of this writing.</p>

<h3>Input/Output</h3>

<h4>Formatted Output via &quot;<span class="font-code">printf()</span>&quot; (JDK 1.5)</h4>

<p><code>System.out.print()</code> and <code>println()</code> do not provide output formatting, such as controlling the number of spaces to print an <code>int</code> and the number of decimal places for a <code>double</code>.</p>

<p>Java SE 5 introduced a new method called <code>printf()</code> for formatted output (which is modeled after C Language's <code>printf()</code>). <code>printf()</code> takes the following form:</p>

<pre class="color-syntax">printf(<em>formatting-string</em>, <em>arg1</em>, <em>arg2</em>, <em>arg3</em>, ... );</pre>

<p><em>Formatting-string</em> contains both <em>normal texts</em> and the so-called <em>Format Specifier</em>s. Normal texts (including white spaces) will be printed as they are. Format specifiers, in the form of &quot;<code>%[flags][width]conversion-code</code>&quot;, will be substituted by the arguments following the formatting-string, usually in a one-to-one and sequential manner. A format specifier begins with a <code>'%'</code> and ends with the conversion code, e.g., <code>%d</code> for integer, <code>%f</code> for floating-point number, <code>%c</code> for character and <code>%s</code> for string. Optional <code>[width]</code> can be inserted in between to specify the field-width. Similarly, optional <code>[flags]</code> can be used to control the alignment, padding and others. For examples,</p>

<ul>
<li><code>%&alpha;d</code>: integer printed in &alpha; spaces (&alpha; is optional).</li>

<li><code>%&alpha;s</code>: String printed in &alpha; spaces (&alpha; is optional). If &alpha; is omitted, the number of spaces is the length of the string (to fit the string).</li>

<li><code>%&alpha;.&beta;f</code>: Floating point number (<code>float</code> and <code>double</code>) printed in &alpha; spaces with &beta; decimal digits (&alpha; and &beta; are optional).</li>

<li><code>%n</code>: a system-specific new line (Windows uses <code>&quot;\r\n&quot;</code>, Unix and Mac <code>&quot;\n&quot;</code>).</li>
</ul>

<h5>Examples:</h5>

<pre class="color-command">
System.out.printf(&quot;Hello%2d and %6s&quot;, 8, &quot;HI!!!%n&quot;);</pre>

<pre class="output">
Hello*8 and ****HI!!!   <span class="color-comment">// * denotes white-spaces inserted by format specifier</span></pre>

<pre class="color-command">
System.out.printf(&quot;Hi,%s%4d%n&quot;, &quot;Hello&quot;, 88);</pre>

<pre class="output">
Hi,Hello**88</pre>

<pre class="color-command">
System.out.printf(&quot;Hi, %d %4.2f%n&quot;, 8, 5.556);</pre>

<pre class="output">
Hi, 8 5.56</pre>

<pre class="color-command">
System.out.printf(&quot;Hi,%-4s&amp;%6.2f%n&quot;, &quot;Hi&quot;, 5.5);  <span class="color-comment">// '%-ns' for left-align String</span></pre>

<pre class="output">
Hi,Hi**&amp;**5.50</pre>

<pre class="color-command">
System.out.printf(&quot;Hi, Hi, %.4f%n&quot;, 5.56);</pre>

<pre class="output">
Hi, Hi, 5.5600</pre>

<p>Take note that <code>printf()</code> does not advance the cursor to the next line after printing.  You need to explicitly print a newline character at the end of the formatting-string to advance the cursor to the next line, if desires. [In C program, we often use '\n' to print a newline, which results in non-portable program. You should use format specifier &quot;<code>%n</code>&quot; instead.]</p>

<p>There are many more format specifiers in Java. Refer to JDK Documentation for the detailed descriptions.</p>

<p>(Also take note that <code>printf()</code> take a variable number of arguments (or <em>varargs</em>), which is a new feature introduced in JDK 1.5 in order to support <code>printf()</code>)</p>

<h4>Input From Keyboard via &quot;<span class="font-code">Scanner</span>&quot; (JDK 1.5)</h4>

<p>Java, like all other languages, supports three standard input/output streams: <code>System.in</code> (standard input device), <code>System.out</code> (standard output device), and <code>System.err</code> (standard error device). The <code>System.in</code> is defaulted to be the keyboard; while <code>System.out</code> and <code>System.err</code> are defaulted to the console. They can be <em>re-directed</em>  to other devices, e.g., it is quite common to redirect <code>System.err</code> to a disk file to save these error message.</p>

<p>You can read input from keyboard via <code>System.in</code> (standard input device).</p>

<p>Java SE 5 introduced a new class called <code>Scanner</code> in package <code>java.util</code> to simplify <em>formatted input</em> (and a new method <code>printf()</code> for formatted output described earlier). 
You can construct a <code>Scanner</code> to <em>scan</em> input from <code>System.in</code> (keyboard), and use methods such as <code>nextInt()</code>, <code>nextDouble()</code>, <code>next()</code> to <em>parse</em> the next <code>int</code>, <code>double</code> and <code>String</code> token (delimited by white space of blank, tab and newline).</p>

<pre class="color-example">
<span class="color-comment">/*
 * Testing input scanner
 */</span>
<strong>import java.util.Scanner;</strong>    <span class="color-comment">// Needed to use the Scanner</span>
public class <strong>ScannerTest</strong> {
   public static void main(String[] args) {
      <span class="color-comment">// Declare variables</span>
      int num1;
      double num2;
      String str;
      <span class="color-comment">// Construct a Scanner named &quot;in&quot; for scanning System.in (keyboard)</span>
      <strong>Scanner in = new Scanner(System.in);</strong>

      <span class="color-comment">// Read inputs from keyboard </span>
      System.out.print(&quot;Enter an integer: &quot;);  <span class="color-comment">// Show prompting message</span>
      num1 = <strong>in.nextInt()</strong>;         <span class="color-comment">// Use nextInt() to read an int</span>
      System.out.print(&quot;Enter a floating point: &quot;);  <span class="color-comment">// Show prompting message</span>
      num2 = <strong>in.nextDouble()</strong>;      <span class="color-comment">// Use nextDouble() to read a double</span>
      System.out.print(&quot;Enter a string: &quot;);  <span class="color-comment">// Show prompting message</span>
      str  = <strong>in.next()</strong>;            <span class="color-comment">// Use next() to read a String token, up to white space</span>

      <span class="color-comment">// Formatted output via printf()</span>
      System.out.printf(&quot;%s, Sum of %d &amp; %.2f is %.2f%n&quot;, str, num1, num2, num1+num2);
 
      <span class="color-comment">// close the input</span>
      <strong>in.close();</strong>
   }
}</pre>

<p>You can also use method <code>nextLine()</code> to read in the entire line, including white spaces, but excluding the terminating newline.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Testing Scanner's nextLine()
 */</span>
import java.util.Scanner;    <span class="color-comment">// Needed to use the Scanner</span>
public class <strong>ScannerNextLineTest</strong> {
   public static void main(String[] args) {
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter a string (with space): &quot;);
      <span class="color-comment">// Use nextLine() to read entire line including white spaces, 
      //   but excluding the terminating newline.</span>
      String str  = <strong>in.nextLine()</strong>;        
      System.out.printf(&quot;%s%n&quot;, str);
      in.close();
   }
}</pre>

<p>Try not to mix <code>nextLine()</code> and <code>nextInt()|nextDouble()|next()</code> in a program (as you may need to flush the newline from the input buffer).</p>

<p>The <code>Scanner</code> supports many other input formats. Check the JDK documentation page, under package <code>java.util</code> &rArr; class <code>Scanner</code> &rArr; Method.</p>

<h4>Input from Text File via &quot;<span class="font-code">Scanner</span>&quot; (JDK 1.5)</h4>

<p>Other than  scanning <code>System.in</code> (keyboard), you can connect your <code>Scanner</code> to scan any input source, such as <em>a disk file</em> or <em>a network socket</em>, and use the same set of methods <code>nextInt()</code>, <code>nextDouble()</code>, <code>next()</code>, <code>nextLine()</code> to parse the next <code>int</code>, <code>double</code>, <code>String</code> and line.  For example,</p>

<pre class="color-example">
Scanner in = new Scanner(new File(&quot;in.txt&quot;));  <span class="color-comment">// Construct a Scanner to scan a text file</span>
<span class="color-comment">// Use the same set of methods</span>
int anInt = in.nextInt();         <span class="color-comment">// next String</span>
double aDouble = in.nextDouble(); <span class="color-comment">// next double</span>
String str = in.next();           <span class="color-comment">// next int</span>
String line = in.nextLine();      <span class="color-comment">// entire line</span></pre>

<p>To open a file via <code>new File(<em>filename</em>)</code>, you need to handle the so-called <code>FileNotFoundException</code>, i.e., the file that you are trying to open cannot be found. Otherwise, you cannot compile your program. There are two ways to handle this exception: <em>throws</em> or <em>try-catch</em>.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Input from File.
 * Technique 1: Declare &quot;throws FileNotFoundException&quot; in the enclosing main() method
 */</span>
import java.util.Scanner;               <span class="color-comment">// Needed for using Scanner</span>
<strong>import java.io.File;</strong>                    <span class="color-comment">// Needed for file operation</span>
<strong>import java.io.FileNotFoundException;</strong>   <span class="color-comment">// Needed for file operation</span>
public class <strong>TextFileScannerWithThrows</strong> {
   public static void main(String[] args)
          <strong>throws FileNotFoundException</strong> {  <span class="color-comment">// Declare &quot;throws&quot; here</span>
      int num1;
      double num2;
      String name;
      <strong>Scanner in = new Scanner(new File(&quot;in.txt&quot;));</strong>  <span class="color-comment">// Scan input from text file</span>
      num1 = in.nextInt();      <span class="color-comment">// Read int</span>
      num2 = in.nextDouble();   <span class="color-comment">// Read double</span>
      name = in.next();         <span class="color-comment">// Read String</span>
      System.out.printf(&quot;Hi %s, the sum of %d and %.2f is %.2f%n&quot;, name, num1, num2, num1+num2);
      in.close();
   }
}</pre>

<p>To run the above program, create a text file called <code>in.txt</code> containing:</p>

<pre class="output">
1234
55.66
Paul</pre>

<pre class="color-example">
<span class="color-comment">/*
 * Input from File.
 * Technique 2: Use try-catch to handle exception
 */</span>
import java.util.Scanner;               <span class="color-comment">// Needed for using Scanner</span>
import java.io.File;                    <span class="color-comment">// Needed for file operation</span>
import java.io.FileNotFoundException;   <span class="color-comment">// Needed for file operation</span>
public class <strong>TextFileScannerWithCatch</strong> {
   public static void main(String[] args) {
      int num1;
      double num2;
      String name;
      <strong>try {</strong>                                <span class="color-comment">// try these statements</span>
         Scanner in = new Scanner(new File(&quot;in.txt&quot;));
         num1 = in.nextInt();      <span class="color-comment">// Read int</span>
         num2 = in.nextDouble();   <span class="color-comment">// Read double</span>
         name = in.next();         <span class="color-comment">// Read String</span>
         System.out.printf(&quot;Hi %s, the sum of %d and %.2f is %.2f%n&quot;, name, num1, num2, num1+num2);
         in.close();
      <strong>} catch (FileNotFoundException ex) {</strong>  <span class="color-comment">// catch and handle the exception here</span>
         ex.printStackTrace();              <span class="color-comment">// print the stack trace</span>
      <strong>}</strong>
   }
}</pre>

<h4>Formatted Output to Text File</h4>

<p>Java SE 5.0 also introduced a so-called <code>Formatter</code> for formatted output (just like <code>Scanner</code> for formatted input). A <code>Formatter</code> has a method called <code>format()</code>. The <code>format()</code> method has the same syntax as <code>printf()</code>, i.e., it could use format specifiers to specify the format of the arguments. Again, you need to handle the <code>FileNotFoundException</code>.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Output to File.
 * Technique 1: Declare &quot;throws FileNotFoundException&quot; in the enclosing main() method
 */</span>
import java.io.File;
import java.util.Formatter;             <span class="color-comment">// &lt;== note</span>
import java.io.FileNotFoundException;   <span class="color-comment">// &lt;== note</span>
public class <strong>TextFileFormatterWithThrows</strong> {
  public static void main(String[] args)
      <strong>throws FileNotFoundException</strong> {   <span class="color-comment">// &lt;== note</span>
    <span class="color-comment">// Construct a Formatter to write formatted output to a text file</span> 
    <strong>Formatter out = new Formatter(new File(&quot;out.txt&quot;));</strong>
    <span class="color-comment">// Write to file with format() method (similar to printf())</span>
    int num1 = 1234;
    double num2 = 55.66;
    String name = &quot;Paul&quot;;
    <strong>out.format(&quot;Hi %s,%n&quot;, name);</strong>
<strong>    out.format(&quot;The sum of %d and %.2f is %.2f%n&quot;, num1, num2, num1 + num2);
    </strong><strong>out.close();</strong>                 <span class="color-comment">// Close the file</span>
    System.out.println(&quot;Done&quot;);  <span class="color-comment">// Print to console</span>
  }
}</pre>

<p>Run the above program, and check the outputs in text file &quot;<code>out.txt</code>&quot;.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Output to File.
 * Technique 2: Use try-catch to handle exception
 */</span>
import java.io.File;
import java.util.Formatter;           <span class="color-comment">// &lt;== note</span>
import java.io.FileNotFoundException; <span class="color-comment">// &lt;== note</span>

public class TextFileFormatterWithCatch {
   public static void main(String[] args) {
      <strong>try {</strong>    <span class="color-comment">// try the following statements</span>
         <span class="color-comment">// Construct a Formatter to write formatted output to a text file</span>
         <strong>Formatter out = new Formatter(new File(&quot;out.txt&quot;));</strong>
         <span class="color-comment">// Write to file with format() method (similar to printf())</span>
         int num1 = 1234;
         double num2 = 55.66;
         String name = &quot;Pauline&quot;;
         <strong>out.format(&quot;Hi %s,%n&quot;, name);
         out.format(&quot;The sum of %d and %.2f is %.2f%n&quot;, num1, num2, num1 + num2);
         out.close();</strong>                <span class="color-comment">// Close the file</span>
         System.out.println(&quot;Done&quot;); <span class="color-comment">// Print to console</span>
      <strong>} catch (FileNotFoundException ex) {</strong>  <span class="color-comment">// catch the exception here</span>
         ex.printStackTrace();       <span class="color-comment">// Print the stack trace</span>
      <strong>}</strong>
   }
}</pre>


<h4>Input via a Dialog Box</h4>

<img class="image-float-right" src="images/JavaBasics_InputViaJOptionPane.gif" alt="Input via JOptionPane" />

<p>You can also get inputs from users via a graphical dialog box, using the <code>JOptionPane</code> class.  For example, the following program prompts the user to enter the radius of a circle, and computes the area.</p>


<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Input via a Dialog box
 */</span>
import javax.swing.JOptionPane;   <span class="color-comment">// Needed to use JOptionPane</span>
public class <strong>JOptionPaneTest</strong> {
   public static void main(String[] args) {
      String radiusStr;
      double radius, area;
      <span class="color-comment">// Read input String from dialog box</span>
      radiusStr = <strong>JOptionPane.showInputDialog(&quot;Enter the radius of the circle&quot;)</strong>;
      radius = Double.parseDouble(radiusStr);   <span class="color-comment">// Convert String to double</span>
      area = radius*radius*Math.PI;
      System.out.println(&quot;The area is &quot; + area);
   }
}</pre></td>
</tr>
</tbody>
</table>

<p>Dissecting the Program:</p>

<ul>
<li>In Line 4, the <code>import</code> statement is needed to use the <code>JOptionPane</code>.</li>

<li>In Line 10, we use the method <code>JOptionPane.showInputDialog(promptMessage)</code> to prompt users for an input, which returns the input as a <code>String</code>.</li>

<li>Line 11 converts the input <code>String</code> to a <code>double</code>, using the method <code>Double.parseDouble()</code>.</li>
</ul>

<h4><span class="font-code">java.io.Console</span> (JDK 1.6)</h4>

<p>Java SE 6 introduced a new <code>java.io.Console</code> class to simplify character-based input/output to/from the system console. BUT, the <code>Console</code> class does not run under IDE (such as Eclipse/NetBeans)!!!</p>

<p>To use the new <code>Console</code> class, you first use <code>System.console()</code> to retrieve the  <code>Console</code> object corresponding to the current system console.</p>

<pre class="color-example">
Console con = System.console();</pre>

<p>You can then use methods such as <code>readLine()</code> to read a line. You can optionally include a prompting message with format specifiers (e.g., <code>%d</code>, <code>%s</code>) in the prompting message.</p>

<pre class="color-example">
String inLine = con.readLine();
String msg = con.readLine(&quot;Enter your message: &quot;);        <span class="color-comment">// readLine() with prompting message</span>
String msg = con.readLine(&quot;%s, enter message: &quot;, name);   <span class="color-comment">// Prompting message with format specifier</span></pre>

<p>You can use <code>con.printf()</code> for formatted output with format specifiers such as <code>%d</code>, <code>%s</code>.
You can also connect the <code>Console</code> to a <code>Scanner</code> for formatted input, i.e., parsing primitives such as <code>int</code>, <code>double</code>, for example,</p>

<pre class="color-example">
Scanner in = new Scanner(con.reader());  <span class="color-comment">// Use Scanner to scan the Console</span>
<span class="color-comment">// Use the Scanner's methods such as nextInt(), nextDouble() to parse primitives</span> 
int anInt = in.nextInt();
double aDouble = in.nextDouble();
String str = in.next();
String line = in.nextLine();</pre>

<h5>Example:</h5>

<pre class="color-example">
<span class="color-comment">/*
 * Testing java.io.Console class
 */</span>
<strong>import java.io.Console;</strong>
import java.util.Scanner;
public class <strong>ConsoleTest</strong> {
   public static void main(String[] args) {
      <strong>Console con = System.console();</strong>   <span class="color-comment">// Retrieve the Console object</span>
      <span class="color-comment">// Console class does not work in Eclipse/NetBeans</span>
      if (con == null) {
          System.err.println(&quot;Console Object is not available.&quot;);
          System.exit(1);
      }
   
      <span class="color-comment">// Read a line with a prompting message</span>
      String name = <strong>con.readLine(&quot;Enter your Name: &quot;)</strong>;
      <strong>con.printf(&quot;Hello %s%n&quot;, name);</strong>
      <span class="color-comment">// Use the console with Scanner for parsing primitives</span>
      <strong>Scanner in = new Scanner(con.reader());</strong>
      con.printf(&quot;Enter an integer: &quot;);
      int anInt = in.nextInt();
      con.printf(&quot;The integer entered is %d%n&quot;, anInt);
      con.printf(&quot;Enter a floating point number: &quot;);
      double aDouble = in.nextDouble();
      con.printf(&quot;The floating point number entered is %f%n&quot;, aDouble);
      in.close();
   }
}</pre>

<p>The <code>Console</code> class also provides a secure mean for password entry via method <code>readPassword()</code>. This method disables input echoing and keep the password in a <code>char[]</code> instead of a <code>String</code>. The <code>char[]</code> containing the password can be and should be overwritten, removing it from memory as soon as it is no longer needed. (Recall that <code>String</code>s are immutable and cannot be overwritten. When they are longer needed, they will be garbage-collected at an unknown instance.)</p>

<pre class="color-example">
<span class="color-comment">/*
 * Inputting password via Console
 */</span>
import java.io.Console;
import java.util.Arrays;
public class <strong>ConsolePasswordTest</strong> {
   static String login;
   static <strong>char[] password</strong>;
   
   public static void main(String[] args) {
      Console con = System.console();
      if (con == null) {
         System.err.println(&quot;Console Object is not available.&quot;);
         System.exit(1);
      }
   
      login = con.readLine(&quot;Enter your login Name: &quot;);
      <strong>password = con.readPassword(&quot;Enter your password: &quot;)</strong>;
      if (checkPassword(login, password)) {
         <strong>Arrays.fill(password, ' ')</strong>;  <span class="color-comment">// Remove password from memory</span>
         <span class="color-comment">// Continue ...</span>
   
      }
   }
   
   static boolean checkPassword(String login, char[] password) {
       return true;
   }
}</pre>

<h4>Exercises on Input/Output</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseInput">LINK TO EXERCISE ON INPUT</a></p>

<h3>Arrays</h3>
<p>Suppose that you want to find the average of the marks for a class of 30 students, you certainly do not want to create 30 variables: <code>mark1</code>, <code>mark2</code>, ..., <code>mark30</code>. Instead, You could use a single variable, called an <em>array</em>, with 30 elements.</p>

<p>An array is <em>an ordered collection of elements of the same type</em>, identified by a pair of square brackets <code>[ ]</code>.  To use an array, you need to:</p>

<ol>
<li><em>Declare</em> the array with a <em>name</em> and a <em>type</em>. Use a plural name for array, e.g., <code>marks</code>, <code>rows</code>, <code>numbers</code>. All elements of the array belong to the same type.</li>

<li><em>Allocate</em> the array using <code>new</code> operator, or through <em>initialization</em>, e.g.,
  <pre class="color-example">
int[] marks;  <span class="color-comment">// Declare an int array named marks
              // marks contains a special value called null.</span>
int marks[];  <span class="color-comment">// Same as above, but the above syntax recommended</span>
marks = new int[5];   <span class="color-comment">// Allocate 5 elements via the &quot;new&quot; operator</span>
<span class="color-comment">// Declare and allocate a 20-element array in one statement via &quot;new&quot; operator</span>
int[] factors = new int[20];
<span class="color-comment">// Declare, allocate a 6-element array thru initialization</span>
int[] numbers = {11, 22, 33, 44, 55, 66}; <span class="color-comment">// size of array deduced from the number of items</span></pre>
</li>
</ol>

<p>When an array is constructed via the <code>new</code> operator, all the elements are initialized to their default value, e.g., <code>0</code> for <code>int</code>, <code>0.0</code> for <code>double</code>, <code>false</code> for <code>boolean</code>, and <code>null</code> for objects. [Unlike C/C++, which does NOT initialize the array contents.]</p>

<p>When an array is declared but not allocated, it contains a special value called <code>null</code>.</p>

<p>You can refer to an element of an array via an index (or subscript) enclosed within the square bracket <code>[ ]</code>.  Java's array index begins with zero (<code>0</code>). For example, suppose that <code>marks</code> is an <code>int</code> array of 5 elements, then the 5 elements are: <code>marks[0]</code>, <code>marks[1]</code>, <code>marks[2]</code>, <code>marks[3]</code>, and <code>marks[4]</code>.</p>

<pre class="color-example">
int[] marks = new int[5];   <span class="color-comment">// Declare &amp; allocate a 5-element int array</span>
<span class="color-comment">// Assign values to the elements</span>
marks[0] = 95;
marks[1] = 85;
marks[2] = 77;
marks[3] = 69;
marks[4] = 66;
System.out.println(marks[0]);
System.out.println(marks[3] + marks[4]);</pre>

<p>To create an array, you need to known the length (or size) of the array in advance, and allocate accordingly.  Once an array is created, its length is fixed and cannot be changed. At times, it is hard to ascertain the length of an array (e.g., how many students?). Nonetheless, you need to estimate the length and allocate an upper bound. This  is probably the major drawback of using an array.</p>

<p>In Java, the length of array is kept in an <em>associated variable</em> called <code>length</code> and can be retrieved using &quot;<code><em>arrayName</em>.length</code>&quot;, e.g.,</p>

<pre class="color-example">
int[] factors = new int[5];       <span class="color-comment">// Declare and allocate a 5-element int array</span>
int numFactors = factors.length;  <span class="color-comment">// numFactor is 5</span></pre>

<img class="image-float-right" src="images/JavaBasics_array.gif" alt="array" />

<p>The index of an array is between <code>0</code> and <code><em>arrayName</em>.length - 1</code>.</p>

<p>Unlike languages like C/C++, Java performs array <em>index-bound check</em> at the <em>runtime</em>.  In other words, for each reference to an array element, the index is checked against the array's length.  If the index is outside the range of <code>[0, arrayName.legnth-1]</code>, the Java Runtime will signal an exception called <code> ArrayIndexOutOfBoundException</code>. It is important to note that checking array index-bound consumes computation power, which inevitably slows down the processing.  However, the benefits gained in terms of good software engineering out-weight the slow down in speed.</p>

<h4>Array and Loop</h4>

<p>Arrays works hand-in-hand with loops. You can process all the elements of an array via a loop, for example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
<span class="color-comment">/*
 * Find the mean and standard deviation of numbers kept in an array
 */</span>
public class <strong>MeanStdArray</strong> {
   public static void main(String[] args) {
      int[] marks = {74, 43, 58, 60, 90, 64, 70};
      int sum = 0;
      int sumSq = 0;
      int count = marks.length;
      double mean, stdDev;
      for (int i=0; i&lt;count; ++i) {
         sum += marks[i];
         sumSq += marks[i]*marks[i];
      }
      mean = (double)sum/count;
      System.out.printf(&quot;Mean is %.2f%n&quot;, mean);
      stdDev = Math.sqrt((double)sumSq/count - mean*mean);
      System.out.printf(&quot;Std dev is %.2f%n&quot;, stdDev);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Enhanced for-loop (or &quot;for-each&quot; Loop) (JDK 1.5)</h4>

<p>JDK 1,5 introduces a new loop syntax known as <em>enhanced for-loop</em> (or <em>for-each</em> loop) to facilitate processing of arrays and collections. It takes the following syntax:</p>

<table class="table-program">
<tr>
<th>Syntax</th>
<th>Example</th>
</tr>

<tr>
<td>
<pre class="color-syntax">
<strong>for (</strong> <em>type item</em> <strong>:</strong> <em>anArray</em> <strong>) {</strong>
   <em>body</em> <strong>;
}</strong>
<span class="color-comment">// <em>type</em> must be the same as the
// <em>anArray</em>'s type</span>
&nbsp;</pre></td>
<td>
<pre class="color-explanation">int[] numbers = {8, 2, 6, 4, 3};
int sum = 0;
for (int number : numbers) {   <span class="color-comment">// for each int number in int[] numbers</span>
   sum += number;
}
System.out.println(&quot;The sum is &quot; + sum);</pre>
</td>
</tr>
</table>

<p>It shall be read as &quot;for each element in the array...&quot;. The loop executes once for each element in the array, with the element's value copied into the declared variable. The for-each loop is handy to transverse all the elements of an array or a collection. It requires fewer lines of codes, eliminates the loop counter and the array index, and is easier to read. However, for array of primitive types (e.g., array of <code>int</code>s), it can <em>read</em> the elements only, and cannot <em>modify</em> the array's contents. This is because each element's value is copied into the loop's variable (pass-by-value), instead of working on its original copy.</p>

<p>In many situations, you merely want to transverse thru the array and read each of the elements. For these cases, enhanced for-loop is preferred and recommended over other loop constructs.</p>

<h4>Exercises on Arrays</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseArray">LINK TO EXERCISES ON ARRAY</a></p>

<h4>Multi-Dimensional Array</h4>

<p>In Java, you can declare an array of arrays. For examples:</p>

<pre class="color-example">
int grid[][] = new int[12][8];   <span class="color-comment">// a 12&times;8 grid of int</span>
grid[0][0] = 8;
grid[1][1] = 5;
System.out.println(grid.length);      <span class="color-comment">// 12</span>
System.out.println(grid[0].length);   <span class="color-comment">// 8</span>
System.out.println(grid[11].length);  <span class="color-comment">// 8</span></pre>

<p>In the above example, <code>grid</code> is an array of 12 elements. Each of the elements (<code>grid[0]</code> to <code>grid[11]</code>) is an 8-element <code>int</code> array. In other words, <code>grid</code> is a &quot;12-element array&quot; of &quot;8-element int arrays&quot;. Hence, <code>grid.length</code> gives <code>12</code> and <code>grid[0].length</code> gives <code>8</code>.</p>

<pre class="color-example">
public class <strong>Array2DTest</strong> {
   public static void main(String[] args) {
      int[][] grid = new int[12][8];   <span class="color-comment">// A 12x8 grid, in [row][col] or [y][x]</span>
      int numRows = grid.length;       <span class="color-comment">// 12</span>
      int numCols = grid[0].length;    <span class="color-comment">// 8</span>
   
      <span class="color-comment">// Fill in grid</span>
      for (int row = 0; row &lt; numRows; ++row) {
         for (int col = 0; col &lt; numCols; ++col) {
            grid[row][col] = row*numCols + col + 1;
         }
      }
   
      <span class="color-comment">// Print grid</span>
      for (int row = 0; row &lt; numRows; ++row) {
         for (int col = 0; col &lt; numCols; ++col) {
            System.out.printf(&quot;%3d&quot;, grid[row][col]);
         }
         System.out.println();
      }
   }
}</pre>

<img class="image-float-right" src="images\Array_MultiDimensional.png" alt="Array_MultiDimensional.png" />

<p>To be precise, Java does not support multi-dimensional array directly. That is, it does not support syntax like <code>grid[3, 2]</code> like some languages. Furthermore, it is possible that the arrays in an array-of-arrays have different length.</p>

<p>Take note that the right way to view the &quot;array of arrays&quot; is as shown, instead of treating it as a 2D table, even if all the arrays have the same length.</p>

<p>For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td>
<pre>
public class Array2DWithDifferentLength {
   public static void main(String[] args) {
      int[][] grid = {
         {1, 2},
         {3, 4, 5},
         {6, 7, 8, 9}
      };
 
      <span class="color-comment">// Print grid</span>
      for (int y = 0; y &lt; grid.length; ++y) {
         for (int x = 0; x &lt; grid[y].length; ++x) {
            System.out.printf(&quot;%2d&quot;, grid[y][x]);
         }
         System.out.println();
      }
 
      int[][] grid1 = new int[3][];
      grid1[0] = new int[2];
      grid1[1] = new int[3];
      grid1[2] = new int[4];
 
      <span class="color-comment">// Print grid - all elements init to 0</span>
      for (int y = 0; y &lt; grid1.length; ++y) {
         for (int x = 0; x &lt; grid1[y].length; ++x) {
            System.out.printf(&quot;%2d&quot;, grid1[y][x]);
         }
         System.out.println();
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h3>Methods (Functions)</h3>

<h4>Why Methods?</h4>

<p>At times, a certain portion of codes has to be used many times. Instead of re-writing the codes many times, it is better to put them into a &quot;subroutine&quot;, and &quot;call&quot; this &quot;subroutine&quot; many time - for ease of maintenance and understanding. Subroutine is  called method (in Java) or function (in C/C++).</p>

<p>The benefits of using methods are:</p>

<ol>
<li><em>Divide and conquer</em>: construct the program from simple, small pieces or components.  Modularize the program into self-contained tasks.</li>

<li><em>Avoid repeating codes</em>: It is easy to copy and paste, but hard to maintain and synchronize all the copies.</li>

<li><em>Software Reuse</em>: you can reuse the methods in other programs, by packaging them into library codes.</li>
</ol>

<h4>Using Methods</h4>

<p>Two parties are involved in using a method: a <em>caller</em>, who <em>calls</em> or <em>invokes</em> the method, and the <em>method</em> called.</p>
<p>The process is:</p>

<ol>
<li>The caller invokes a method and passes <em>arguments</em> to the method.</li>
<li>The method:
<ol>
<li>receives the arguments passed by the caller,</li>
<li>performs the programmed operations defined in the method's body, and</li>
<li>returns a result back to the caller.</li>
</ol>
</li>
<li>The caller receives the result, and continue its operations.</li>
</ol>

<p><span class="line-heading">Example:</span> Suppose that we need to evaluate the area of a circle many times, it is better to write a method called <code>getArea()</code>, and re-use it when needed.</p>

<img class="image-center" src="images/Method.png" alt="Method.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
public class <strong>EgMethodGetArea</strong> {
  <span class="color-comment"> // The entry main method</span>
   public static void <span class="color-new">main</span>(String[] args) {
      double r = 1.1, area, area2;
     <span class="color-comment"> // Call (Invoke) method getArea()</span>
      area = <span class="color-new">getArea(r)</span>;
      System.out.println(&quot;area is &quot; + area);
     <span class="color-comment"> // Call method getArea() again</span>
      area2 = <span class="color-new">getArea(2.2)</span>;
      System.out.println(&quot;area 2 is &quot; + area2);
     <span class="color-comment"> // Call method getArea() one more time</span>
      System.out.println(&quot;area 3 is &quot; + <span class="color-new">getArea(3.3)</span>);
   }
 
  <span class="color-comment"> // Method getArea() Eefinition.</span>
  <span class="color-comment"> // Compute and return the area (in double) of circle given its radius (in double).</span>
   <span class="color-new">public static double getArea(double radius) {
      return radius * radius * Math.PI;
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The expected outputs are:</p>
<pre class="output">
area is 3.8013271108436504
area 2 is 15.205308443374602
area 3 is 34.21194399759284</pre>

<p>In the above example, a reusable method called <code>getArea()</code> is defined, which receives an argument in <code>double</code> from the caller, performs the calculation, and return a <code>double</code> result to the caller.  In the <code>main()</code>, we invoke <code>getArea()</code> methods thrice, each time with a different parameter.</p>
<p>Take note that there is a transfer of control from the caller to the method called, and from the method back to the caller, as illustrated.</p>

<img class="image-center" src="images/MethodTransferControl.png" alt="Method.png" />

<h5>Tracing Method Invocation</h5>

<p>You can trace method operations under Eclipse/NetBeans:</p>
<ul>
<li><strong>Step Over</strong>: Treat the method call as one single step.</li>
<li><strong>Step Into</strong>: Step into the method, so that you can trace the operations of the method.</li>
<li><strong>Step Out</strong>: Complete the current method and return to the caller.</li>
<li>Set &quot;<strong>Breakpoints</strong>&quot; inside the method, and &quot;resume&quot; running to the first breakpoint.</li>
</ul>


<h5>Method Definition Syntax</h5>

<p>The syntax for method definition is as follows:</p>

<pre class="color-syntax">
<strong>public static</strong> <em>returnValueTyp</em>e <em>methodName </em><strong>(</strong> <em>arg-1-type arg-1</em>, <em>arg-2-type arg-2</em>,... <strong>) {</strong>
   <em>body</em> <strong>;
}</strong></pre>

<h5>Method Naming Convention</h5>

<p>A method's name shall be a verb or verb phrase (action), comprising one or more words. The first word is in lowercase, while the rest are initial-capitalized (called <em>camel-case</em>).  For example, <code>getArea()</code>, <code>setRadius()</code>, <code>moveDown()</code>, <code>isPrime()</code>, etc.</p>

<p><span class="line-heading">Another Example:</span></p>

<pre class="color-example">
<span class="color-comment">/** Example of Java Method definition and invocation */</span>
public class EgMinMaxMethod {
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      int a = 6, b = 9, max, min;
      max = max(a, b);  <span class="color-comment">// invoke method max() with arguments</span>
      min = min(a, b);  <span class="color-comment">// invoke method min() with arguments</span>
      System.out.println(max + "," + min);
   
      System.out.println(max(5, 8)); <span class="color-comment">// invoke method max()</span>
      System.out.println(min(5, 8)); <span class="color-comment">// invoke method min()</span>
   }

   <span class="color-comment">// The max() method returns the maximum of two given numbers</span>
   public static int max(int number1, int number2) {
      return (number1 > number2) ? number1 : number2;
   }

   <span class="color-comment">// The min() method returns the minimum of two given numbers</span>
   public static int min(int number1, int number2) {
      return (number1 &lt; number2) ? number1 : number2;
   }
}</pre>


<h4>The &quot;<span class="font-code">return</span>&quot; statement</h4>

<p>Inside the method body, you could use a <code>return</code> statement to return a value (of the <code><em>returnValueType</em></code> declared in the method's signature) to return a value back to the caller. The syntax is:</p>
<pre class="color-syntax">
return <em>aReturnValue</em>;   <span class="color-comment">// of <em>returnValueType</em> declared in method's signature</span>
return;                <span class="color-comment">// return nothing (or void)</span></pre>

<h4>The &quot;<span class="font-code">void</span>&quot; Return-Type</h4>

<p>Suppose that you need a method to perform certain actions (e.g., printing) without a need to return a value to the caller, you can declare its return-value type as <code>void</code>. In the method's body, you could use a &quot;<code>return;</code>&quot; statement without a return value to return control to the caller. In this case, the <code>return</code> statement is optional. If there is no <code>return</code> statement, the entire body will be executed, and control returns to the caller at the end of the body.</p>

<p>Notice that <code>main()</code> is a method with a return-value type of <code>void</code>. <code>main()</code> is called by the Java runtime, perform the actions defined in the body, and return nothing back to the Java runtime.</p>

<h4>Actual Parameters vs. Formal Parameters</h4>

<p>Recall that a method receives arguments from its caller, performs the actions defined in the method's body, and return a value (or nothing) to the caller.</p>

<p>In the above example, the variable <code>(double radius)</code> declared in the signature of <code>getArea(double radius)</code> is known as <em>formal parameter</em>. Its scope is within the method's body. When the method is invoked by a caller, the caller must supply so-called <em>actual parameter</em>s or <em>arguments</em>, whose value is then used for the actual computation. For example, when the method is invoked via &quot;<code>area1=getArea(radius1)</code>&quot;, <code>radius1</code> is the actual parameter, with a value of <code>1.1</code>.</p>

<h4>Pass-by-Value for Primitive-Type Parameters</h4>

<p>In Java, when an argument of primitive type is pass into a method, a <em>copy</em> is created and passed into the method. The invoked method works on the <em>cloned copy</em>, and cannot modify the original copy. This is known as <em>pass-by-value</em>.</p>

<p>For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre>
</td>
<td>
<pre>
public class PassingParameterTest {
   public static void main(String[] args) {
      int number = 8;               <span class="color-comment"> // primitive type</span>
      System.out.println(&quot;In caller, before calling the method, number is: &quot; + number); <span class="color-comment"> // 8</span>
      int result = <span class="color-new">increment(number)</span>;<span class="color-comment"> // invoke method</span>
      System.out.println(&quot;In caller, after calling the method, number is: &quot; + number);  <span class="color-comment"> // 8</span>
      System.out.println(&quot;The result is &quot; + result); <span class="color-comment"> // 9</span>
   }
 
   <span class="color-new">public static int increment(int number)</span> {
      System.out.println(&quot;Inside method, before operation, number is &quot; + number);<span class="color-comment"> // 8</span>
      ++number; <span class="color-comment"> // change the parameter</span>
      System.out.println(&quot;Inside method, after operation, number is &quot; + number); <span class="color-comment"> // 9</span>
      return number;
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Varargs - Method with Variable Number of Formal Arguments (JDK 1.5)</h4>

<p>Before JDK 1.5, a method has to be declared with a <em>fixed number of formal arguments</em>.  C-like <code>printf()</code>, which take a <em>variable number of argument</em>, cannot not be implemented.  Although you can use an array for passing a variable number of arguments, it is not neat and requires some programming efforts.</p>

<p>JDK 1.5 introduces variable arguments (or varargs) and a new syntax &quot;<code><em>Type</em>...</code>&quot;. For example,</p>

<pre class="color-example">
public PrintWriter printf(String format, Object... args)
public PrintWriter printf(Local l, String format, Object... args)</pre>

<p>Varargs can be used only for the last argument.  The three dots (<code>...</code>) indicate that the last argument may be passed as an array or as a sequence of comma-separated arguments.  The compiler automatically packs the varargs into an array.  You could then retrieve and process each of these arguments inside the method's body as an array. It is possible to pass varargs as an array, because Java maintains the length of the array in an associated variable <code>length</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
public class VarargsTest {
   <span class="color-comment">// A method which takes a variable number of arguments (varargs)</span>
   public static void doSomething(String... strs) {
      System.out.print(&quot;Arguments are: &quot;);
      for (String str : strs) {
         System.out.print(str + &quot;, &quot;);
      }
      System.out.println();
   }
 
   <span class="color-comment">// A method which takes exactly two arguments</span>
   public static void doSomething(String s1, String s2) {
      System.out.println(&quot;Overloaded version with 2 args: &quot; + s1 + &quot;, &quot; + s2);
   }
 
   <span class="color-comment">// Cannot overload with this method - crash with varargs version</span>
   <span class="color-comment">// public static void doSomething(String[] strs)</span>
 
   <span class="color-comment">// Test main() method</span>
   <span class="color-comment">// Can also use String... instead of String[]</span>
   public static void main(String... args) {
      doSomething(&quot;Hello&quot;, &quot;world&quot;, &quot;again&quot;, &quot;and&quot;, &quot;again&quot;);
      doSomething(&quot;Hello&quot;, &quot;world&quot;);
 
      String[] strs = {&quot;apple&quot;, &quot;orange&quot;};
      doSomething(strs);  <span class="color-comment">// invoke varargs version</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Notes:</p>

<ul>
<li>If you define a method that takes a varargs <code>String...</code>, you cannot define an overloaded method that takes a <code>String[]</code>.</li>

<li>&quot;varargs&quot; will be matched <em>last</em> among the overloaded methods.  The <code>varargsMethod(String, String)</code>, which is more specific, is matched before the <code>varargsMethod(String...)</code>.</li>

<li>From JDK 1.5, you can also declare your <code>main()</code> method as:
<pre class="color-syntax">
public static void main(String... args) { .... }  <span class="color-comment">// JDK 1.5 varargs</span></pre>
</li>
</ul>

<h4>Method Overloading</h4>
<p>In Java, a method (of a particular method name) can have more than one versions, each version operates on different set of parameters - known as <em>method overloading</em>. The versions shall be differentiated by the numbers, types, or orders of the parameters.</p>

<p>For example,</p>

<pre class="color-example">
<span class="color-comment">/** Testing Method Overloading */</span>
public class EgMethodOverloading {
   public static void main(String[] args) {
      System.out.println(average(8, 6));     <span class="color-comment">// invoke version 1</span>
      System.out.println(average(8, 6, 9));  <span class="color-comment">// invoke version 2</span>
      System.out.println(average(8.1, 6.1)); <span class="color-comment">// invoke version 3</span>
      System.out.println(average(8, 6.1));
           <span class="color-comment">// int 8 autocast to double 8.0, invoke version 3</span>
      // average(1, 2, 3, 4)  <span class="color-error">// Compilation Error - no such method</span>
   }
   <span class="color-comment">// Version 1 takes 2 int's</span>
   public static int average(int n1, int n2) {
      System.out.println("version 1");
      return (n1 + n2)/2;  <span class="color-comment">// int</span>
   }
   <span class="color-comment">// Version 2 takes 3 int's</span>
   public static int average(int n1, int n2, int n3) {
      System.out.println("version 2");
      return (n1 + n2 + n3)/3;   <span class="color-comment">// int</span>
   }
   <span class="color-comment">// Version 3 takes 2 doubles</span>
   public static double average(double n1, double n2) {
      System.out.println("version 3");
      return (n1 + n2)/2.0;  <span class="color-comment">// double</span>
   }
}</pre>

<p>The expected outputs are:</p>
<pre class="output">
version 1
7
version 2
7
version 3
7.1
version 3
7.05</pre>

<h4>&quot;<span class="font-code">boolean</span>&quot; Methods</h4>

<p>A <code>boolean</code> method returns a <code>boolean</code> value to the caller.</p>

<p>Suppose that we wish to write a method called <code>isOdd()</code> to check if a given number is odd.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td>
<pre>
<span class="color-comment">/**
 *  Testing boolean method (method that returns a boolean value)
 */</span>
public class BooleanMethodTest {
   <span class="color-comment">// This method returns a boolean value</span>
   <span class="color-new">public static boolean isOdd(int number) {
      if (number % 2 == 1) {
         return true;
      } else {
         return false;
      }
   }</span>
 
   public static void main(String[] args) {
      System.out.println(<span class="color-new">isOdd(5)</span>);  <span class="color-comment">// true</span>
      System.out.println(<span class="color-new">isOdd(6)</span>);  <span class="color-comment">// false</span>
      System.out.println(<span class="color-new">isOdd(-5)</span>); <span class="color-comment">// false</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This seemingly correct codes produces <code>false</code> for <code>-5</code>, because <code>-5%2</code> is <code>-1</code> instead of <code>1</code>.  You may rewrite the condition:</p>

<pre class="color-example">
public static boolean isOdd(int number) {
   if (number % 2 == 0) {
      return false;
   } else {
      return true;
   }
}</pre>

<p>The above produces the correct answer, but is poor.  For boolean method, you can simply return the resultant <code>boolean</code> value of the comparison, instead of using a conditional statement, as follow:</p>

<pre class="color-example">
public static boolean isEven(int number) {
   return (number % 2 == 0);
}
public static boolean isOdd(int number) {
   return !(number % 2 == 0);
}</pre>

<h4>Mathematical Methods</h4>

<p>JDK provides many common-used Mathematical methods in a class called <code>Math</code>. The signatures of some of these methods are:</p>

<pre class="color-syntax">
double Math.pow(double x, double y) <span class="color-comment">// returns x raises to power of y</span>
double Math.sqrt(double x)          <span class="color-comment">// returns the square root of x</span>
double Math.random()                <span class="color-comment">// returns a random number in [0.0, 1.0)</span>
double Math.sin()
double Math.cos()</pre>

<p>The <code>Math</code> class also provide two constants:</p>

<pre class="color-syntax">
Math.PI   <span class="color-comment">// 3.141592653589793</span>
Math.E    <span class="color-comment">// 2.718281828459045</span></pre>

<p>To check all the available methods, open JDK API documentation &rArr; select <em>package</em> &quot;<code>java.lang</code>&quot; &rArr; select <em>class</em> &quot;<code>Math</code>&quot; &rArr; choose <em>method</em>.</p>

<p>For examples,</p>

<pre class="color-example">
int secretNumber = (int)Math.random()*100;  <span class="color-comment">// Generate a random int between 0 and 99</span>
&nbsp;
double radius = 5.5;
double area = radius*radius*Math.PI;
area = Math.pow(radius, 2)*Math.PI;         <span class="color-comment">// Not as efficient as above</span>
&nbsp;
int x1 = 1, y1 = 1, x2 = 2, y2 = 2;
double distance = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
int dx = x2 - x1;
int dy = y2 - y1;
distance = Math.sqrt(dx*dx + dy*dy);        <span class="color-comment">// Slightly more efficient</span></pre>

<h4>Implicit Type-Casting for Method's Parameters</h4>

<p>A method that takes a <code>double</code> parameter can accept any numeric primitive type, such as <code>int</code> or <code>float</code>. This is because implicit type-casting is carried out. However, a method that take a <code>int</code> parameter cannot accept a <code>double</code> value. This is because the implicit type-casting is always a widening conversion which prevents loss of precision. An explicit type-cast is required for narrowing conversion. Read &quot;<a href="#typecasting">Type-Casting</a>&quot; on the conversion rules.</p>

<h4>Exercises on Methods</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseMethod">LINK TO EXERCISES ON METHOD</a></p>


<h3>Command-Line Arguments</h3>

<p>Java's <code>main(String[] args)</code> method takes an argument: <code>String[] args</code>, i.e., a <code>String</code> array named <code>args</code>. This is known as &quot;command-line arguments&quot;, which corresponds to the augments provided by the user when the java program is invoked. For example, a Java program called <code>Arithmetic</code> could be invoked with additional command-line arguments as follows (in a &quot;cmd&quot; shell):</p>

<pre class="color-command">
java Arithmetic <strong>12 3456 +</strong></pre>

<p>Each argument, i.e., <code>&quot;12&quot;</code>, <code>&quot;3456&quot;</code> and <code>&quot;+&quot;</code>, is a <code>String</code>. Java runtime packs all the arguments into a <code>String</code> array and passes into the <code>main()</code> method as <code>args</code>. For this example, <code>args</code> has the following properties:</p>

<pre class="color-example">
args = {&quot;12&quot;, &quot;3456&quot;, &quot;+&quot;}   <span class="color-comment">// &quot;args&quot; is a String array</span>
args.length = 3              <span class="color-comment">// length of the array args</span>
args[0] = &quot;12&quot;   <span class="color-comment">            // Each element of the array is a String</span>
args[1] = &quot;3456&quot;
args[2] = &quot;+&quot;
args[0].length() = 2   <span class="color-comment">      // length of the String</span>
args[1].length() = 4
args[2].length() = 1</pre>

<p><span class="line-heading">Example:</span> The program <code>Arithmetic</code> reads three parameters form the command-line, two integers and an arithmetic operator (<code>'+'</code>, <code>'-'</code>, <code>'*'</code>, or <code>'/'</code>), and performs the arithmetic operation accordingly. For example,</p>

<pre class="output">
<strong>java Arithmetic 3 2 +</strong>
3+2=5
<strong>java Arithmetic 3 2 -</strong>
3-2=1
<strong>java Arithmetic 3 2 /</strong>
3/2=1</pre>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td>
<pre>
public class <strong>Arithmetic</strong> {
   public static void main (String[] args) {
      int operand1, operand2;
      char theOperator;
      operand1 = Integer.parseInt(args[0]);  <span class="color-comment">// Convert String to int</span>
      operand2 = Integer.parseInt(args[1]);
      theOperator = args[2].charAt(0);       <span class="color-comment">// Consider only 1st character</span>
      System.out.print(args[0] + args[2] + args[1] + &quot;=&quot;);
      switch(theOperator) {
         case ('+'):
            System.out.println(operand1 + operand2); break;
         case ('-'):
            System.out.println(operand1 - operand2); break;
         case ('*'):
            System.out.println(operand1 * operand2); break;
         case ('/'):
            System.out.println(operand1 / operand2); break;
         default:
            System.out.printf(&quot;%nError: Invalid operator!&quot;);
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Exercises on Command-Line Arguments</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseArgs">LINK TO EXERCISES ON COMMAND-LINE ARGUMENTS</a></p>


<h3>Code Examples</h3>

<h4>EG 1: <span class="font-code">Bin2Dec</span></h4>

<p>Convert a binary string into its equivalent decimal number.</p>

<h5>Version 1:</h5>

<pre class="color-example">
<span class="color-comment">/*
 * Prompt user for a binary string, and convert into its equivalent decimal number.
 */</span>
import java.util.Scanner;
public class Bin2Dec {
   public static void main(String[] args) {
      String binStr; <span class="color-comment"> // The input binary string</span>
      int binStrLen; <span class="color-comment"> // The length of binStr</span>
      int dec = 0;   <span class="color-comment"> // The decimal equivalent, accumulate from 0</span>
 
     <span class="color-comment"> // Read input</span>
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter a binary string: &quot;);
      binStr = in.next();
      binStrLen = binStr.length();
 
     <span class="color-comment"> // Process char by char from the right (i.e. Least-significant bit)</span>
      for (int exp = 0; exp &lt; binStrLen ; ++exp) {
         int charPos = binStrLen - 1 - exp;    <span class="color-comment"> // charAt(pos)</span>
         char binChar = binStr.charAt(charPos);
        <span class="color-comment"> // 3 cases: '1' (add to dec), '0' (do nothing), other (error)</span>
         if (binChar == '1') {
            dec += (int)Math.pow(2, exp); <span class="color-comment"> // cast the double result back to int</span>
         } else if (binChar != '0') {
            System.out.println(&quot;Error: Invalid binary string \&quot;&quot; + binStr + &quot;\&quot;&quot;);
            System.exit(1);  <span class="color-comment"> // quit</span>
         }
      }

      <span class="color-comment">// Print result</span>
      System.out.println(&quot;The equivalent decimal for \&quot;&quot; + binStr + &quot;\&quot; is &quot; + dec);
      in.close();
   }
}</pre>

<pre class="color-example-light">
binStr             : 1 0 1 1 1 0 0 1
charAt(pos)        : 0 1 2 3 4 5 6 7  (pos counts from the left)
Math.pow(2, exp)   : 7 6 5 4 3 2 1 0  (exp counts from the right)
 
binStr.length() = 8
pos + exp = binStr.length() - 1</pre>

<h5>Version 2:</h5>

<pre class="color-example">
<span class="color-comment">/*
 * Prompt user for a binary string, and convert into its equivalent decimal number.
 * Validate the input string.
 * Repeat the program, until user chooses to quit.
 * Allow blank in the binary string, e.g., &quot;0100 1000&quot;.
 */</span>
import java.util.Scanner;
public class Bin2DecIteractive {
   public static void main(String[] args) {
      String inStr; <span class="color-comment"> // The input binary string</span>
      Scanner in = new Scanner(System.in);
      boolean done = false; <span class="color-comment"> // boolean flag for controlling the loop</span>
 
      while (!done) {
        <span class="color-comment"> // Prompt for the input string</span>
         System.out.print(&quot;Enter a binary string or 'q' to quit: &quot;);
         inStr = in.nextLine(); <span class="color-comment"> // read entire line including blanks</span>
         if (inStr.equals(&quot;q&quot;)) {
            System.out.println(&quot;Bye!&quot;);
            done = true;
         } else if (!isValidBinStr(inStr)) {
            System.out.println(&quot;Error: Invalid binary string: \&quot;&quot; + inStr + &quot;\&quot;, try again.&quot;);
         } else {
            System.out.println(&quot;The equivalent decimal number for \&quot;&quot; + inStr + &quot;\&quot; is &quot; + bin2Dec(inStr));
         }
      }
      in.close();
   }
 
  <span class="color-comment"> // Return true if the given string contains only binary numbers and blanks.</span>
   public static boolean isValidBinStr(String binStr) {
      for (int i = 0; i &lt; binStr.length(); ++i) {
         char binChar = binStr.charAt(i);
         if (binChar != '0' &amp;&amp; binChar != '1' &amp;&amp; binChar != ' ') {
            return false; <span class="color-comment"> // break on first invalid char</span>
         }
      }
      return true;
   }
 
  <span class="color-comment"> // Return the equivalent decimal number of the given binary string.</span>
  <span class="color-comment"> // Blanks are allowed in the binStr, e.g., &quot;0010 1000&quot;.</span>
  <span class="color-comment"> // Assume that the input contains '0', '1' or ' '.</span>
   public static int bin2Dec(String binStr) {
      int binStrLen = binStr.length(); <span class="color-comment"> // The length of binStr</span>
      int dec = 0; <span class="color-comment"> // Equivalent decimal number, accumulating from 0</span>
 
     <span class="color-comment"> // We need to process from the right (i.e. Least-significant bit)</span>
      for (int charPos = binStrLen - 1, exp = 0; charPos &gt;= 0; --charPos) {
         char binChar = binStr.charAt(charPos);
        <span class="color-comment"> // 3 cases: '1' (add to dec, ++exp), '0' (++exp), ' ' (do nothing)</span>
         if (binChar == '1') {
            dec += (int)Math.pow(2, exp);
            ++exp;
         } else if (binChar == '0') {
            ++exp;
         }<span class="color-comment"> // else for ' ' (do nothing)</span>
      }
      return dec;
   }
}</pre>

<h4>EG 2: <span class="font-code">Hex2Dec</span></h4>

<p>Convert a hexadecimal string to its decimal equivalence.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Prompt user for the hexadecimal string, and convert to its equivalent decimal number
 */</span>
import java.util.Scanner;
public class Hex2Dec {
   public static void main(String[] args) {
      String hexStr;  <span class="color-comment"> // The input hexadecimal String</span>
      int hexStrLen;  <span class="color-comment"> // The length of hexStr</span>
      int dec = 0;    <span class="color-comment"> // The decimal equivalent, accumulating from 0</span>
 
     <span class="color-comment"> // Read input</span>
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter a Hexadecimal string: &quot;);
      hexStr = in.next();
      hexStrLen = hexStr.length();
 
     <span class="color-comment"> // Process char by char from the right (least-significant digit)</span>
      for (int exp = 0; exp &lt; hexStrLen; ++exp) {
         int charPos = hexStrLen - 1 - exp;
         char hexChar = hexStr.charAt(charPos);
         int factor = (int)Math.pow(16, exp);
        <span class="color-comment"> // 23 cases: '0'-'9', 'a'-'f', 'A'-'F', other (error)</span>
         if (hexChar &gt;= '1' &amp;&amp; hexChar &lt;= '9') {
            dec += (hexChar - '0') * factor;
         } else if (hexChar &gt;= 'a' &amp;&amp; hexChar &lt;= 'f') {
            dec += (hexChar - 'a' + 10) * factor;
         } else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') {
            dec += (hexChar - 'A' + 10) * factor;
         } else {
            System.out.println(&quot;Error: Invalid hex string \&quot;&quot; + hexStr + &quot;\&quot;&quot;);
            System.exit(1);
         }
      }
      System.out.println(&quot;The equivalent decimal for \&quot;&quot; + hexStr + &quot;\&quot; is &quot; + dec);
      in.close();
   }
}</pre>

<p>You may use <code>in.next().toLowercase()</code> to reduce the number of cases. But that modifies the input string.</p>

<h4>EG 3: <span class="font-code">Dec2Hex</span></h4>

<p>Convert a decimal number to its hexadecimal equivalence.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Prompt user for an int, and convert to its equivalent hexadecimal number.
 */</span>
import java.util.Scanner;
public class <strong>Dec2Hex</strong> {
   public static void main(String[] args) {
      int dec;              <span class="color-comment">// The input decimal number</span>
      String hexStr = &quot;&quot;;   <span class="color-comment">// The equivalent hex String, accumulating from empty String</span>
      int radix = 16;       <span class="color-comment">// Hex radix</span>
      char[] hexChar = {'0','1','2','3','4','5','6','7','8','9',
          'A','B','C','D','E','F'};  <span class="color-comment">// Use this array as lookup table</span>
   
      <span class="color-comment">// Read input</span>
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter a decimal number: &quot;);
      dec = in.nextInt();
   
      <span class="color-comment">// Repeated division and get the remainder</span>
      while (dec &gt; 0) {
         int hexDigit = dec % radix;
         hexStr = hexChar[hexDigit] + hexStr;  <span class="color-comment">// append in front of the hex string</span>
         dec = dec / radix;
      }
      System.out.println(&quot;The equivalent hexadecimal number is &quot; + hexStr);
      in.close();
   }
}</pre>

<h4>EG 4: <span class="font-code">Hex2Bin</span></h4>

<p>Convert a hexadecimal number to its binary equivalence.</p>

<pre class="color-example">
<span class="color-comment">/*
 * Prompt user for a hexadecimal string, and convert to its binary equivalence.
 */</span>
import java.util.Scanner;
public class <strong>Hex2Bin</strong> {
   public static void main(String[] args) {
      String hexStr;     <span class="color-comment">// The input hexadecimal String</span>
      int hexStrLen;     <span class="color-comment">// The length of hexStr</span>
      String binStr =&quot;&quot;; <span class="color-comment">// The equivalent binary String, accumulating from empty String</span>
   
      <span class="color-comment">// Lookup table for the binary string corresponding to Hex digit '0' (index 0) to 'F' (index 15)</span>
      String[] binStrs
         = {&quot;0000&quot;,&quot;0001&quot;,&quot;0010&quot;,&quot;0011&quot;,&quot;0100&quot;,&quot;0101&quot;,&quot;0110&quot;,&quot;0111&quot;,
            &quot;1000&quot;,&quot;1001&quot;,&quot;1010&quot;,&quot;1011&quot;,&quot;1100&quot;,&quot;1101&quot;,&quot;1110&quot;,&quot;1111&quot;};
   
      <span class="color-comment">// Read input</span>
      Scanner in = new Scanner(System.in);
      System.out.print(&quot;Enter a Hexadecimal string: &quot;);
      hexStr = in.next();
      hexStrLen = hexStr.length();
   
      <span class="color-comment">// Process the string from the left</span>
      for (int pos = 0; pos &lt; hexStrLen; ++pos) {
         char hexChar = hexStr.charAt(pos);
         if (hexChar &gt;= '0' &amp;&amp; hexChar &lt;= '9') {
            binStr += binStrs[hexChar-'0'];  <span class="color-comment">// index into the binStrs array </span>
         } else if (hexChar &gt;= 'a' &amp;&amp; hexChar &lt;= 'f') {
            binStr += binStrs[hexChar-'a'+10];
         } else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') {
            binStr += binStrs[hexChar-'A'+10];
         } else {
            System.err.println(&quot;Error: Invalid Hex string \&quot;&quot; + hexStr + &quot;\&quot;&quot;);
            System.exit(1);  <span class="color-comment">// quit</span>
         }
      }
      System.out.println(&quot;The equivalent binary for \&quot;&quot; + hexStr + &quot;\&quot; is \&quot;&quot; + binStr + &quot;\&quot;&quot;);
      in.close();
   }
}</pre>

<h4>EG 5: Guess A Number</h4>
<p>Guess a number between 0 and 99.</p>

<pre class="color-example">
import java.util.Scanner;
public class <strong>NumberGuess</strong> {
   public static void main(String[] args) {
      int secretNumber;     <span class="color-comment">// Secret number to be guessed</span>
      int numberIn;         <span class="color-comment">// The guessed number entered</span>
      int trialNumber = 0;  <span class="color-comment">// Number of trials so far</span>
      boolean done = false; <span class="color-comment">// boolean flag for loop control</span>
   
      <span class="color-comment">// Set up the secret number
      // Math.random() generates a double in [0.0, 1.0)</span>
      secretNumber = (int)(Math.random()*100);
   
      Scanner in = new Scanner(System.in);

      while (!done) {
         ++trialNumber;
         System.out.print(&quot;Enter your guess (between 0 and 99): &quot;);
         numberIn = in.nextInt();
         if (numberIn == secretNumber) {
            System.out.println(&quot;Congratulation&quot;);
            done = true;
         } else if (numberIn &lt; secretNumber) {
            System.out.println(&quot;Try higher&quot;);
         } else {
            System.out.println(&quot;Try lower&quot;);
         }
      }
      System.out.println(&quot;You got in &quot; + trialNumber +&quot; trials&quot;);
      in.close();
   }
}</pre>

<h4>More Exercises on Java Basics</h4>
<p><a href="J2a_BasicsExercises.html#ExerciseMore">LINK TO MORE EXERCISES ON JAVA BASICS</a></p>

<h3>(Advanced) Bitwise Operations</h3>

<h4>Bitwise Logical Operations</h4>

<p>Bitwise  operators perform operations on one or two operands on a bit-by-bit basis, as follows, in descending order of precedences.</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th>Operator</th>
  <th>Description</th>
  <th>Usage</th>
</tr>
<tr>
  <td class="text-center"><span class="font-code">~</span></td>
  <td>Bitwise NOT (inversion)</td>
  <td><span class="font-code">~<em>expr</em></span></td>
</tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">&amp;</span></td>
  <td>Bitwise AND</td>
  <td><span class="font-code"><em>expr1</em> &amp; <em>expr2</em></span></td>
</tr>
<tr>
  <td class="text-center"><span class="font-code">^</span></td>
  <td>Bitwise XOR</td>
  <td><span class="font-code"><em>expr1</em> ^ <em>expr2</em></span></td>
</tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">|</span></td>
  <td>Bitwise OR</td>
  <td><span class="font-code"><em>expr1</em> | <em>expr2</em></span></td>
</tr>
</table>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12</pre>
</td>
<td>
<pre>
public class TestBitwiseOp {
   public static void main(String[] args) {
      int x = 0xAAAA_5555;                <span class="color-comment">// a negative number (sign bit (msb) = 1)</span>
      int y = 0x5555_1111;                <span class="color-comment">// a positive number (sign bit (msb) = 0)</span>
      System.out.printf(&quot;%d%n&quot;, x);       <span class="color-comment">// -1431677611</span>
      System.out.printf(&quot;%d%n&quot;, y);       <span class="color-comment">// 1431638289</span>
      System.out.printf(&quot;%08X%n&quot;, ~x);    <span class="color-comment">// 5555AAAAH</span>
      System.out.printf(&quot;%08X%n&quot;, x &amp; y); <span class="color-comment">// 00001111H</span>
      System.out.printf(&quot;%08X%n&quot;, x | y); <span class="color-comment">// FFFF5555H</span>
      System.out.printf(&quot;%08X%n&quot;, x ^ y); <span class="color-comment">// FFFF4444H</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Compound operator <code>&amp;=</code>, <code>|=</code> and <code>^=</code> are also available, e.g., <code>x &amp;= y</code> is the same as <code>x = x &amp; y</code>. </p>

<p>Take note that:</p>

<ol>
<li><code>'&amp;'</code>, <code>'|'</code> and <code>'^'</code> are applicable when both operands are integers (<code>int</code>, <code>byte</code>, <code>short</code>, <code>long</code> and <code>char</code>) or <code>boolean</code>s. When both operands are integers, they perform bitwise operations. When both operands are <code>boolean</code>s, they perform logical AND, OR, XOR operations (i.e., same as logical <code>&amp;&amp;</code>, <code>||</code> and <code>^</code>). They are not applicable to <code>float</code> and <code>double</code>. On the other hand, logical AND (<code>&amp;&amp;</code>) and OR (<code>||</code>) are applicable to <code>boolean</code>s only.

<pre class="color-example">
System.out.println(true &amp; true);   <span class="color-comment">// logical -&gt; true</span>
System.out.println(0x1 &amp; 0xffff);  <span class="color-comment">// bitwise -&gt; 1</span>
System.out.println(true &amp;&amp; true);  <span class="color-comment">// logical -&gt; true</span></pre>
</li>

<li>The bitwise NOT (or bit inversion) operator is represented as '~', which is different from logical NOT (<code>!</code>).</li>

<li>The bitwise XOR is represented as <code>'^'</code>, which is the same as logical XOR (<code>^</code>).</li>

<li>The operators' precedence is in this order: <code>'~'</code>, <code>'&amp;'</code>, <code>'^'</code>, <code>'|'</code>, <code>'&amp;&amp;'</code>, <code>'||'</code>. For example,
<pre class="color-example">
System.out.println(true | true &amp; false);  <span class="color-comment">// true | (true &amp; false) -&gt; true</span>
System.out.println(true ^ true &amp; false);  <span class="color-comment">// true ^ (true &amp; false) -&gt; true</span></pre>
</li>
</ol>

<p>Bitwise operations are powerful and yet extremely efficient. [Example on advanced usage.]</p>

<h4>Bit-Shift Operations</h4>

<p>Bit-shift operators perform left or right shift on an operand by a specified number of bits.  Right-shift can be either signed-extended (<code>&gt;&gt;</code>) (padded with signed bit) or unsigned-extended (<code>&gt;&gt;&gt;</code>) (padded with zeros). Left-shift is always padded with zeros (for both signed and unsigned).</p>

<table class="table-zebra" style="width:80%">
<tr>
  <th> Operator</th>
  <th>Usage</th>
  <th>Description</th>
</tr>
<tr>
  <td class="text-center"><span class="font-code">&lt;&lt;</span></td>
  <td><span class="font-code">operand &lt;&lt; number</span></td>
  <td>Left-shift and padded with zeros</td>
</tr>
<tr class="tr-alt">
  <td class="text-center"><span class="font-code">&gt;&gt;</span></td>
  <td><span class="font-code">operand &gt;&gt; number</span></td>
  <td>Right-shift and padded with sign bit (signed-extended right-shift)</td>
</tr>
<tr>
  <td class="text-center"><span class="font-code">&gt;&gt;&gt;</span></td>
  <td><span class="font-code">operand &gt;&gt;&gt; number</span></td>
  <td>Right-shift and padded with zeros (unsigned-extended right-shift)</td>
</tr>
</table>

<p>Since all the Java's integers (byte, short, int and long) are signed integers, left-shift &lt;&lt; and right-shift &gt;&gt; operators perform signed-extended bit shift.  Signed-extended right shift &gt;&gt; pads the most significant bits with the sign bit to maintain its sign (i.e., padded with zeros for positive numbers and ones for negative numbers).  Operator &gt;&gt;&gt; (introduced in Java, not in C/C++) is needed to perform unsigned-extended right shift, which always pads the most significant bits with zeros.  There is no difference between the signed-extended and unsigned-extended left shift, as both operations pad the least significant bits with zeros.</p>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre>
</td>
<td>
<pre>
public class BitShiftTest {
   public static void main(String[] args) {
      int x = 0xAAAA5555;               <span class="color-comment">// a negative number (sign bit (msb) = 1)</span>
      int y = 0x55551111;               <span class="color-comment">// a positive number (sign bit (msb) = 0)</span>
      System.out.printf(&quot;%d%n&quot;, x);     <span class="color-comment">// -1431677611</span>
      System.out.printf(&quot;%d%n&quot;, y);     <span class="color-comment">// 1431638289</span>
      System.out.printf(&quot;%08X%n&quot;, x&lt;&lt;1);  <span class="color-comment">// 5554AAAAH</span>
      System.out.printf(&quot;%08X%n&quot;, x&gt;&gt;1);  <span class="color-comment">// D5552AAAH</span>
      System.out.printf(&quot;%d%n&quot;, x&gt;&gt;1);    <span class="color-comment">// negative</span>
      System.out.printf(&quot;%08X%n&quot;, y&gt;&gt;1);  <span class="color-comment">// 2AAA8888H</span>
      System.out.printf(&quot;%08d%n&quot;, y&gt;&gt;1);  <span class="color-comment">// positive</span>
      System.out.printf(&quot;%08X%n&quot;, x&gt;&gt;&gt;1); <span class="color-comment">// 55552AAAH</span>
      System.out.printf(&quot;%d%n&quot;, x&gt;&gt;&gt;1);   <span class="color-comment">// positive</span>
      System.out.printf(&quot;%08X%n&quot;, y&gt;&gt;&gt;1); <span class="color-comment">// 2AAA8888</span>
      System.out.printf(&quot;%d%n&quot;, y&gt;&gt;&gt;1);   <span class="color-comment">// positive</span>
 
      <span class="color-comment">// More efficient to use signed-right-right to perform division by 2, 4, 8,...</span>
      int i1 = 12345;
      System.out.println(&quot;i1 divides by 2 is &quot; + (i1 &gt;&gt; 1));
      System.out.println(&quot;i1 divides by 4 is &quot; + (i1 &gt;&gt; 2));
      System.out.println(&quot;i1 divides by 8 is &quot; + (i1 &gt;&gt; 3));
      int i2 = -12345;
      System.out.println(&quot;i2 divides by 2 is &quot; + (i2 &gt;&gt; 1));
      System.out.println(&quot;i2 divides by 4 is &quot; + (i2 &gt;&gt; 2));
      System.out.println(&quot;i2 divides by 8 is &quot; + (i2 &gt;&gt; 3));
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>As seen from the example, it is more efficient to use sign-right-shift to perform division by 2, 4, 8... (power of 2), as integers are stored in binary.</p>

<p>[More example on advanced usage.]</p>

<h4>Types and Bitwise Operations</h4>

<p>The bitwise operators are applicable to integral primitive types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> and <code>char</code>.  <code>char</code> is treated as unsigned 16-bit integer. There are not applicable to <code>float</code> and  <code>double</code>. The <code>'&amp;'</code>, <code>'|'</code>, <code>'^'</code>, when apply to two <code>boolean</code>s, perform logical operations. Bit-shift operators are not applicable to <code>boolean</code>s.</p>

<p>Like binary arithmetic operations:</p>

<ul>
<li><code>byte</code>, <code>short</code> and <code>char</code> operands are first promoted to <code>int</code>.</li>

<li>If both the operands are of the same type (<code>int</code> or <code>long</code>), they are evaluated in that type and returns a result of that type.</li>

<li>If the operands are of different types, the smaller operand (<code>int</code>) is promoted to the larger one (<code>long</code>). It then operates on the larger type (<code>long</code>) and returns a result in the larger type (<code>long</code>).</li>
</ul>

<h3>Algorithms</h3>

<p>Before writing a program to solve a problem, you have to first develop the steps involved, called <em>algorithm</em>, and then translate the <em>algorithm</em> into programming statements. This is the hardest part in programming, which is also hard to teach because the it involves intuition, knowledge and experience. </p>

<p>An <em>algorithm</em> is a step-by-step instruction to accomplice a  task, which may involve decision and iteration. It is often expressed in English-like <em>pseudocode</em>, before translating into programming statement of a particular programming language. There is no standard on how to write pseudocode - simply write something that you, as well as other people, can understand the steps involved, and able to translate into a working program.</p>

<h4>Algorithm for Prime Testing</h4>

<p>Ancient Greek mathematicians like Euclid and Eratosthenes (around 300-200 BC) had developed many <em>algorithms</em> (or step-by-step instructions) to work on prime numbers. By definition, a <em>prime  </em>is a positive integer that is divisible by one and itself only.</p>

<p>To test whether a number <em><code>x</code></em> is a prime number, we could apply the definition by dividing <em><code>x</code></em> by 2, 3, 4, ..., up to <code><em>x</em>-1</code>.  If no divisor is found, then <em><code>x</code></em> is a prime number. Since divisors come in pair, there is no need to try all the factors until <em>x</em>-1, but up to <code>&radic;<em>x</em></code>.</p>

<pre class="color-syntax">
<span class="color-comment">// To test whether an int x is a prime</span>
int maxFactor = (int)Math.sqrt(x);   <span class="color-comment">// find the nearest integral square root of x</span>
assume x is a prime;
for (int factor = 2; factor &lt;= maxFactor; ++factor) {
   if (x is divisible by factor) {
      x is not a prime;
      break;  <span class="color-comment">  // a factor found, no need to find more factors</span>
   }
}</pre>

<p><span class="line-heading">TRY</span>: translate the above pseudocode into a Java program called <code>PrimeTest</code>.</p>

<h4>Algorithm for Perfect Numbers</h4>

<p>A positive integer is called a <em>perfect number</em> if the sum of all its proper divisor is equal to its value.  For example, the number <code>6</code> is perfect because its proper divisors are <code>1</code>, <code>2</code>, and <code>3</code>, and <code>6=1+2+3</code>; but the number <code>10</code> is not perfect because its proper divisors are <code>1</code>, <code>2</code>, and <code>5</code>, and <code>10&ne;1+2+5</code>. Other perfect numbers are <code>28</code>, <code>496</code>, ...</p>

<p>The following algorithm can be used to test for perfect number:</p>

<pre class="color-syntax">
<span class="color-comment">// To test whether int x is a perfect number</span>
int sum = 0;
for (int i = 1; i &lt; x; ++i) {
   if (x is divisible by i) {
      i is a proper divisor;
      add i into the sum;
   }
}
if (sum == x)
   x is a perfect number
else
   x is not a perfect number</pre>

<p><span class="line-heading">TRY</span>: translate the above pseudocode into a Java program called <code>PerfectNumberTest</code>.</p>

<h4>Algorithm on Computing Greatest Common Divisor (GCD)</h4>

<p>Another early algorithm developed by ancient Greek mathematician Euclid (300 BC) is to find the Greatest Common Divisor (GCD) (or Highest Common Factor (HCF)) of two integers. By definition, <code>GCD(a,b)</code> is the largest factor that divides both <code>a</code> and <code>b</code>.</p>

<p>Assume that <code>a</code> and <code>b</code> are positive integers and <code>a &gt;= b</code>, the Euclidean algorithm is based on these two properties:</p>

<pre class="color-syntax">
1.  GCD(a, 0) = a
2.  GCD(a, b) = GCD(b, a mod b), where &quot;a mod b&quot; denotes the remainder of a divides by b.
</pre>

<p>For example,</p>

<pre class="color-example">
GCD(15, 5) = GCD(5, 0) = 5
GCD(99,88) = GCD(88,11) = GCD(11,0) = 11
GCD(3456,1233) = GCD(1233,990) = GCD(990,243) = GCD(243,18) = GCD(18,9) = GCD(9,0) = 9</pre>

<p>The Euclidean algorithm is as follows:</p> 

<pre class="color-syntax">
GCD(a, b)  <span class="color-comment">// assume that a &gt;= b</span>
while (b != 0) {
<span class="color-comment">   // Change the value of a and b: a &larr; b, b &larr; a mod b, and repeat until b is 0</span>
   temp &larr; b
   b &larr; a mod b
   a &larr; temp
}
<span class="color-comment">// after the loop completes, i.e., b is 0, we have GCD(a, 0)</span>
GCD is a</pre>

<p>Before explaining the algorithm, suppose we want to exchange (or swap) the values of two variables <em><code>x</code></em> and <em><code>y</code></em>.  Explain why the following code does not work.</p>
<pre class="color-example">
int x = 55, y=66;
<span class="color-comment">// swap the values of x and y</span>
x = y;
y = x;</pre>

<p>To swap the values of two variables, we need to define a temporary  variable as follows:</p>
<pre class="color-example">
int x = 55, y=66;
int temp;
<span class="color-comment">// swap the values of x and y</span>
temp = y;
y = x;
x = temp;</pre>

<p>Let us look into the Euclidean algorithm, <code>GCD(a, b) = a</code>, if <code>b</code> is <code>0</code>. Otherwise, we replace <code>a</code> by <code>b</code>; <code>b</code> by <code>(a mod b)</code>, and compute <code>GCD(b, a mod b)</code>. Repeat the process until the second term is <code>0</code>. Try this out on pencil-and-paper to convince yourself that it works.</p>

<p><span class="line-heading">TRY</span>: Write a program called <code>GCD</code>, based on the above algorithm.</p>

<h4>Exercises on Algorithm</h4>

<p><a href="J2a_BasicsExercises.html#ExerciseNumberTheory">LINK TO EXERCISES ON ALGORITHMS</a></p>

<h3>Summary</h3>

<p>This chapter covers the Java programming basics:</p>

<ul>
<li>Variables, literals, expressions and statements.</li>

<li>The concept of type and Java's eight primitive types: <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, and <code>boolean</code>.</li>

<li>Implicit and explicit type-casting.</li>

<li>Operators: assignment (<code>=</code>), arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>), increment/decrement (<code>++</code>, <code>--</code>) relational operators (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>), logical operators (<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>^</code>) and conditional (<code>? :</code>).</li>

<li>Three flow control constructs: sequential, condition (<code>if</code>, <code>if-else</code>, <code>switch-case</code> and nested-if) and loops (<code>while</code>, <code>do-while</code>, <code>for</code> and nested loops).</li>

<li>Input (via <code>Scanner</code>) &amp; Output (<code>print()</code>, <code>println()</code> and <code>printf()</code>) operations.</li>

<li>Arrays and the enhanced for-loop.</li>

<li>Methods and passing parameters into methods.</li>

<li>The advanced bitwise logical operators (<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>^</code>) and bit-shift operators (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>).</li>

<li>Developing algorithm for solving problems.</li>
</ul>

<a class="references" href="../howto/References.html#java">Link to Java References and Resources</a>

<p class="references">More References and Resources</p>

<ol>
<li>&quot;Code Conventions for the Java Programming Language&quot; @ <a href="http://java.sun.com/docs/codeconv/index.html">http://www.oracle.com/technetwork/java/codeconv-138413.html</a> (MUST READ), Sun Microsystems (now Oracle).</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 1.8.0_66<br />
Last modified: March, 2016</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
</body>
</html>
