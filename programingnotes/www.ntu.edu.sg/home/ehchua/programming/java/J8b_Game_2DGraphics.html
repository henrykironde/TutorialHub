<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>2D Graphics &amp; Java2D</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java  Game Programming</h1>
<h2> 2D Graphics, Java2D and Images</h2>
</div>

<div id="content-main">


<p>The pre-requisite knowledge needed to for game programming includes:</p>
<ul>
<li>OOP, in particular the concepts of inheritance and polymorphism for designing classes.</li>
<li>GUI and custom graphics programming (<code>javax.swing</code>).</li>
<li>Event-handling, in particular mouse-event and key-event handling (<code>java.awt.event</code>).</li>
<li>Graphics programming using Java 2D (<code>java.awt.geom</code>).</li>
<li>Paying sounds (<code>javax.sound</code>).</li>
<li>Basic knowledge on I/O, multi-threading for starting the game thread, and timing control.</li>
<li>Transformation, collision detection and reaction algorithms.</li>
</ul>

<p>Advanced Knowledge:</p>
<ul>
<li>JOGL (Java Bindings to OpenGL), or Java3D for 3D graphics.</li>
<li>JOAL (Java Bindings to OpenAL) for advanced sound.</li>
</ul>

<h3>Revisit <span class="font-code">java.awt.Graphics</span> for Custom Drawing</h3>

<img class="image-float-right" src="images/Graphics_Coordinates.png" />


<p><span class="line-heading">Read:</span> &quot;<a href="J4b_CustomGraphics.html">Custom Graphics</a>&quot; chapter.</p>
<p>The <code>java.awt.Graphics</code> class is used for custom painting. It manages the graphics context (such as color, font and clip area) and provides methods for rendering of three types of graphical objects:</p>
<ol>
<li>Texts: via <code>drawString()</code>.</li>
<li>Vector-graphic primitives and shapes: via <code>drawXxx()</code> and <code>fillXxx()</code> for <code>Line</code>, <code>PolyLine</code>, <code>Oval</code>, <code>Rect</code>, <code>RoundRect</code>, <code>3DRect</code>, and <code>Arc</code>.</li>
<li>Bitmap images: via <code>drawImage()</code>.</li>
</ol>

<p>The <code>Graphics</code> class also allows you to get/set the attributes of the graphics context:</p>
<ul>
<li>Font (<code>setFont()</code>, <code>getFont()</code>)</li>
<li>Color (<code>setColor()</code>, <code>getColor()</code>)</li>
<li>Display clipping area (<code>getClip()</code>, <code>getClipBounds()</code>, <code>setClip()</code>)</li>
</ul>

<p>It is important to take note that the graphics co-ordinates system is &quot;inverted&quot;, as illustrated.</p>

<p>The <code>java.awt.Graphics</code> class is, however, limited in its functions and capabilities. It supports mainly straight-line segments. <code>java.awt.Graphics2D</code> (of the Java 2D API) greatly extends the functions and capabilities of the <code>Graphics</code> class.</p>

<h4>Template for Custom Drawing</h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
 
<span class="color-comment">// Swing Program Template</span>
@SuppressWarnings(&quot;serial&quot;)
public class SwingTemplateJPanel extends JPanel {
   <span class="color-comment">// Name-constants</span>
   public static final int CANVAS_WIDTH = 640;
   public static final int CANVAS_HEIGHT = 480;
   public static final String TITLE = &quot;...Title...&quot;;
   <span class="color-comment">// ......</span>
 
   <span class="color-comment">// private variables of GUI components</span>
   <span class="color-comment">// ......</span>
 
   <span class="color-comment">/** Constructor to setup the GUI components */</span>
   public SwingTemplateJPanel() {
      setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
      <span class="color-comment">// &quot;this&quot; JPanel container sets layout</span>
      <span class="color-comment">// setLayout(new ....Layout());</span>
 
      <span class="color-comment">// Allocate the UI components</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-comment">// &quot;this&quot; JPanel adds components</span>
      <span class="color-comment">// add(....)</span>
 
      <span class="color-comment">// Source object adds listener</span>
      <span class="color-comment">// .....</span>
   }
 
   <span class="color-comment">/** Custom painting codes on this JPanel */</span>
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);  <span class="color-comment">// paint background</span>
      setBackground(Color.BLACK);
 
      <span class="color-comment">// Your custom painting codes</span>
      <span class="color-comment">// ......</span>
   }
 
   <span class="color-comment">/** The entry main() method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         public void run() {
            JFrame frame = new JFrame(TITLE);
            frame.setContentPane(new SwingTemplateJPanel());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.pack();             <span class="color-comment">// &quot;this&quot; JFrame packs its components</span>
            frame.setLocationRelativeTo(null); <span class="color-comment">// center the application window</span>
            frame.setVisible(true);            <span class="color-comment">// show it</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>The custom drawing is done by extending a <code>JPanel</code> and overrides the <code>paintComponent()</code> method.</li>
<li>The size of the drawing panel is set via the <code>setPreferredSize()</code>.</li>
<li>The <code>JFrame</code> does not set its size, but packs its components by invoking <code>pack()</code>.</li>
<li>In the <code>main()</code>, the GUI construction is carried out in the event-dispatch thread to ensure thread-safety.</li>
</ul>

<p>You can run the above class as an applet, by providing a main applet class:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
import javax.swing.*;
 
<span class="color-comment">/** Swing Program Template for running as Applet */</span>
@SuppressWarnings(&quot;serial&quot;)
public class SwingTemplateApplet extends JApplet {
 
   <span class="color-comment">/** init() to setup the UI components */</span>
   @Override
   public void init() {
      <span class="color-comment">// Run GUI codes in the Event-Dispatching thread for thread safety</span>
      try {
         SwingUtilities.invokeAndWait(new Runnable() { <span class="color-comment">// Applet uses invokeAndWait()</span>
            @Override
            public void run() {
               <span class="color-comment">// Set the content-pane of the JApplet to an instance of main JPanel</span>
               setContentPane(new SwingTemplateJPanel());
            }
         });
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h3>Java 2D API &amp; <span class="font-code">Graphics2D</span></h3>

<p><span class="line-heading">Reference:</span> Java Tutorial's &quot;2D Graphics&quot; @ <a href="http://docs.oracle.com/javase/tutorial/2d/TOC.html">http://docs.oracle.com/javase/tutorial/2d/TOC.html</a>.</p>

<p>Java AWT API has been around since JDK 1.1. Java 2D API is part of Java Foundation Class (JFC), similar to Swing, and was introduced in JDK 1.2. It provides more capabilities for graphics programming. Java 2D spans many packages: <code>java.awt</code>, <code>java.awt.image</code>, <code>java.awt.color</code>, <code>java.awt.font</code>, <code>java.awt.geom</code>, <code>java.awt.print</code>, and <code>java.awt.image.renderable</code>.</p>

<h4><span class="font-code">java.awt.Graphics2D</span></h4>

<img class="image-float-right" src="images/AWT_GraphicsClassDiagram.png" />

<p>The core class in Java2D is the <code>java.awt.Graphics2D</code>. <code>Graphics2D</code> is a subclass of <code>java.awt.Graphics</code>, which<code></code> extends the support of the legacy <code>Graphics</code> class in rendering three groups of objects: text, vector-graphics and bitmap images. It also supports more attributes that affect the rendering, e.g.,</p>
<ul>
<li>Transform attribute (translation, rotation, scaling and shearing).</li>
<li>Pen attribute (outline of a shape) and Stroke attribute (point-size, dashing-pattern, end-cap and join decorations). </li>
<li>Fill attribute (interior of a shape) and Paint attribute (fill shapes  with solid colors, gradients, and patterns).</li>
<li>Composite attribute (for overlapping shapes).</li>
<li>Clip attribute (display area).</li>
<li>Font attribute.</li>
</ul>

<p><code>Graphics2D</code> is designed as a subclass of <code>Graphics</code>. To use <code>Graphcs2D</code> context, <em>downcast</em> the <code>Graphics</code> handle <code>g</code> to <code>Graphics2D</code> in painting methods such as <code>paintComponent()</code>. This works because the graphics subsystem in fact passes a <code>Graphics2D</code> object as the argument when calling back the painting methods. For example,</p>
<pre class="color-example">
@Override
public void paintComponent(Graphics g) {  <span class="color-comment">// graphics subsystem passes a Graphis2D subclass object as argument</span>
   super.paintComponent(g);           <span class="color-comment">// paint parent's background</span>
   <span class="color-new">Graphics2D g2d = (Graphics2D) g;</span>   <span class="color-comment">// downcast the Graphics object back to Graphics2D</span>
   <span class="color-comment">// Perform custom drawing using g2d handle</span>
   ......
}</pre>

<p>Besides the <code>drawXxx()</code> and <code>fillXxx()</code>, <code>Graphics2D</code> provides more general drawing methods which operates on <code>Shape</code> interface.</p>

<pre class="color-syntax">
public abstract void draw(Shape s)
public abstract void fill(Shape s)
public abstract void clip(Shape s)</pre>

<h4>Affine Transform (<span class="font-code">java.awt.geom.AffineTransform</span>)</h4>
<p>Transform is key in game programming and animation!</p>
<p>An <em>affine transform</em> is a linear transform such as <em>translation</em>, <em>rotation</em>, <em>scaling</em>, or <em>shearing</em> in which a straight line remains straight and parallel lines remain parallel after the transformation. It can be represented using the following 3x3 matrix operation:</p>
<pre class="color-syntax">
[ x' ]   [ m00  m01  m02 ] [ x ]   [ m00x + m01y + m02 ]
[ y' ] = [ m10  m11  m12 ] [ y ] = [ m10x + m11y + m12 ]
[ 1  ]   [   0    0    1 ] [ 1 ]   [         1         ]</pre>

<p>Affine transform is supported via the <code>java.awt.geom.AffineTransform</code> class. The <code>Graphics2D</code> context maintains an <code>AffineTransform</code> attribute, and provides methods to change the transform attributes:</p>

<pre class="color-syntax">
<span class="color-comment">// in class java.awt.Graphics2D</span>
public abstract void setTransform(AffineTransform at);  <span class="color-comment"> // overwrites the current Transform in the Graphics2D context</span>
public abstract void translate(double tx, double ty);   <span class="color-comment"> // concatenates the current Transform with a translation transform</span>   
public abstract void rotate(double theta);               <span class="color-comment">// concatenates the current Transform with a rotation transform</span>
public abstract void scale(double scaleX, double scaleY) <span class="color-comment">// concatenates the current Transform with a scaling transform</span>
public abstract void shear(double shearX, double shearY) <span class="color-comment">// concatenates the current Transform with a shearing transform</span>
</pre>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.geom.AffineTransform;
import javax.swing.*;
 
<span class="color-comment">/** Test applying affine transform on vector graphics */</span>
@SuppressWarnings(&quot;serial&quot;)
public class AffineTransformDemo extends JPanel {
   <span class="color-comment">// Named-constants for dimensions</span>
   public static final int CANVAS_WIDTH = 640;
   public static final int CANVAS_HEIGHT = 480;
   public static final String TITLE = &quot;Affine Transform Demo&quot;;
 
   <span class="color-comment">// Define an arrow shape using a polygon centered at (0, 0)</span>
   int[] polygonXs = { -20, 0, +20, 0};
   int[] polygonYs = { 20, 10, 20, -20};
   Shape shape = new Polygon(polygonXs, polygonYs, polygonXs.length);
   double x = 50.0, y = 50.0;  <span class="color-comment">// (x, y) position of this Shape</span>
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public AffineTransformDemo() {
      setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
   }
 
   <span class="color-comment">/** Custom painting codes on this JPanel */</span>
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);    <span class="color-comment">// paint background</span>
      setBackground(Color.WHITE);
      Graphics2D g2d = (Graphics2D)g;
 
      <span class="color-comment">// Save the current transform of the graphics contexts.</span>
      AffineTransform saveTransform = g2d.getTransform();
      <span class="color-comment">// Create a identity affine transform, and apply to the Graphics2D context</span>
      AffineTransform identity = new AffineTransform();
      g2d.setTransform(identity);
 
      <span class="color-comment">// Paint Shape (with identity transform), centered at (0, 0) as defined.</span>
      g2d.setColor(Color.GREEN);
      g2d.fill(shape);
      <span class="color-comment">// Translate to the initial (x, y) position, scale, and paint</span>
      g2d.translate(x, y);
      g2d.scale(1.2, 1.2);
      g2d.fill(shape);
 
      <span class="color-comment">// Try more transforms</span>
      for (int i = 0; i &lt; 5; ++i) {
         g2d.translate(50.0, 5.0);  <span class="color-comment">// translates by (50, 5)</span>
         g2d.setColor(Color.BLUE);
         g2d.fill(shape);
         g2d.rotate(Math.toRadians(15.0)); <span class="color-comment">// rotates about transformed origin</span>
         g2d.setColor(Color.RED);
         g2d.fill(shape);
      }
      <span class="color-comment">// Restore original transform before returning</span>
      g2d.setTransform(saveTransform);
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(TITLE);
            frame.setContentPane(new AffineTransformDemo());
            frame.pack();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null); <span class="color-comment">// center the application window</span>
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<img class="image-center" src="images/Graphics_TestAffineTransform.png" />

<p>These are the steps for carrying out affine transform with a <code>Graphics2D</code> context:</p>
<ol>
<li>Override the <code>paintComponent(Graphics)</code> method of the custom drawing <code>JPanel</code>. Downcast the <code>Graphics</code> object into <code>Graphics2D</code>.
<pre class="color-example">
@Override
public void paintComponent(Graphics g) {
   Graphics2D g2d = (Graphics2D) g;
   ......
}</pre></li>

<li>Prepare a <code>Shape</code> (such as <code>Polygon</code>, <code>Rectangle2D, Rectangle</code>). The original shape shall center at (0, 0) to simplify rotation.</li>
<li>Save the current transform associated with this <code>Graphics2D</code> context, and restore the saved transform before exiting the method.
<pre class="color-example">
AffineTransform saveTransform = g2d.getTransform();   <span class="color-comment">// save</span>
....
g2d.setTransform(saveTransform);                      <span class="color-comment">// restore</span>
</pre>
</li>

<li>Allocate a new <code>AffineTransform</code>. Initialize to the default <em>identity</em> transform. Apply it to the current <code>Graphics2D</code> context. You can then use the <code>Graphics2D</code> context to perform translation, rotation, scaling and shearing.
<pre class="color-example">
AffineTransform identity = new AffineTransform();   <span class="color-comment">// an identity transform</span>
g2d.setTransform(identity);  <span class="color-comment">// overwrites the transform associated with this Graphics2D context</span>
g2d.translate(x, y);         <span class="color-comment">// translates from (0, 0) to the current (x, y) position</span>
g2d.scale(scaleX, scaleY);   <span class="color-comment">// scaling</span>
g2d.rotate(angle);           <span class="color-comment">// rotation clockwise about (0, 0), by angle (in radians)</span>
g2d.shear(shearX, shearY);   <span class="color-comment">// shearing</span>
</pre>
</li>

</ol>

<p>Take note that successive transforms are <em>concatenated</em>, until it is reset (to the identity transform) or overwritten.</p>
<p> In the above example, the <code>Polygon</code>, which is originally centered at (0, 0) (shown in green), is first translated to (50, 50) and scaled up by 1.2 (in green). A loop of 5-iterations is applied to translate by (50, 5) (in blue) and rotate by 15 degrees about (0, 0) (in red). Observe that after each transform, the <em>axes</em> and <em>origin </em>are transformed accordingly. This is especially noticeable for rotation, as the axes are no longer parallel and perpendicular to the screen and its origin is shifted as well. The origin of the axes is set to (0, 0) by the identity transform.</p>

<h5>Rotation</h5>

<p>The result of rotation depends on the angle rotated, as well as its rotation center. Two methods are provided:</p>
<pre class="color-syntax">
public abstract void rotate(theta);
public abstract void rotate(theta, anchorX, anchorY)</pre>

<p>The first method rotates about the origin (0, 0), while the second method rotate about (anchorX, anchorY), without affecting the origin after the rotation. Take note that after each rotation, the coordinates is rotated as well. Rotation can be made simpler, by center the shape at (0, 0) as shown in the above example.</p>

<h4>Geometric Primitives and Shapes</h4>

<p>Java 2D's primitives include:</p>
<ul>
<li>point (<code>Point2D</code>)</li>
<li>line (<code>Line2D</code>)</li>
<li>rectangular shapes (<code>Rectangle2D</code>, <code>RoundRectangle2D</code>,, <code>Ellipse2D</code>, <code>Arc2D</code>, <code>Dimension2D</code>)</li>
<li>quadratic and cubic curves with control points (<code>QuadCurve2D</code>, <code>CubicCurve2D</code>)</li>
<li>arbitrary shapes (<code>Path2D</code>).</li>
</ul>

<p>[TODO] Class diagram</p>
<p>The <code>Xxx2D</code> classes have two nested <code>public</code> <code>static</code> subclasses <code>Xxx2D.Double</code> and <code>Xxx2D.Float</code> to support <code>double</code>- and <code>float</code>-precision. High-quality 2D rendering (e.g., rotation, shearing, curve segments) cannot be performed in <code>int</code> (even though eventually it will be converted to integral screen-pixel values for display). Hence, <code>double</code> and <code>float</code> subclasses are  introduced in Java 2D for better accuracy and smoothness. The earlier <code>int</code>-precision classes, such as <code>Point</code> and <code>Rectangle</code> are retrofitted as a subclass of <code>Point2D</code> and  <code>Rectangle2D</code>.</p>

<p>The <code>Xxx2D</code>, <code>Xxx2D.Double</code> and <code>Xxx2D.Float</code> are kept in package <code>java.awt.geom</code> package.</p>

<h5><span class="font-code">GeneralPath</span></h5>
<p>The <code>java.awt.geom.GeneralPath</code> class represents a geometric path constructed from straight lines, quadratic and cubic curves. For example,</p>

<pre class="color-example">
int[] x = { -20, 0, 20, 0};
int[] y = { 20, 10, 20, -20};
GeneralPath p = new GeneralPath();
p.moveTo(x[0], y[0]);
for (int i = 1; i &lt; x.length; ++i) {
   p.lineTo(x[i], y[i]);
}
p.closePath();
g2d.translate(350, 250);
g2d.draw(p);</pre>


<h4><span class="font-code">Point2D</span> and its Subclasses <span class="font-code">Point</span>, <span class="font-code">Point2D.Double</span> and <span class="font-code">Point2D.Float</span> (Advanced)</h4>

<p><span class="line-heading">Reference:</span> Source codes of <code>java.awt.geom.Point2D</code> and <code>java.awt.Point</code>.</p>

<p>As an example, let's examine <code>Point2D</code> <code>abstract</code> superclass and its subclasses more closely.</p>

<h5><span class="font-code">java.awt.geom.Point2D</span></h5>
<p><code>Point2D</code> is an abstract class that cannot be instantiated. It declares the following <code>abstract</code> methods:</p>
<pre class="color-syntax">
abstract public double getX();
abstract public double getY();
abstract public void setLocation(double x, double y);</pre>

<p>It also defines and implemented some <code>static</code> methods and member methods. (Hence, it is designed as an abstract class, instead of interface.)</p>
<pre class="color-syntax">
<span class="color-comment">// static methods</span>
public static double distance(double x1, double y1, double x2, double y2)
public static double distanceSq(double x1, double y1, double x2, double y2)
<span class="color-comment">// instance (non-static) methods</span>
public double distance(double x, double y)
public double distanceSq(double x, double y)
public double distance(Point2D p)
public double distanceSq(Point2D p)
......</pre>

<p><code>Point2D</code> does not define any instance variable, in particular, the <code>x</code> and <code>y</code> location of the point.  This is because it is not sure about the type of <code>x</code> and <code>y</code> (which could be <code>int</code>, <code>float</code> or <code>double</code>).  The instance variables, therefore, are left to the implementation subclasses.  Three subclasses were implemented for types of <code>int</code>, <code>float</code> and <code>double</code>, respectively.</p>

<h5>Subclasses <span class="font-code">java.awt.Point</span>, <span class="font-code">java.awt.geom.Point2D.Double</span> and <span class="font-code">java.awt.geom.Point2D.Float</span></h5>
<p>How to design these subclasses?</p>
<p><code>java.awt.Point</code> is the subclass for <code>int</code>-precision. It declares instance variables <code>x</code> and <code>y</code> as <code>int</code>, provides implementation to the abstract methods declared in the superclass, and provides some additional methods. </p>

<pre class="color-syntax">
package java.awt;
public <strong>class Point extends Point2D</strong> {
   <span class="color-comment">// Instance variables (x, y) of type int</span>
   public int x;
   public int y;
   <span class="color-comment">// Constructor</span>
   public Point(int x, int y) { this.x = x; this.y = y; }
   <span class="color-comment">// Provide implementation to the abstract methods declared in the superclass</span>
   public double getX() { return x; }
   public double getY() { return y; }
   public void setLocation(double x, double y) {
      this.x = (int)Math.floor(x + 0.5);
      this.y = (int)Math.floor(y + 0.5);
   }
   <span class="color-comment">// Other methods</span>
   ......
}</pre>

<p><code>Point</code> (of <code>int</code>-precision) is a straight-forward implementation of inheritance and polymorphism. <code>Point</code> is a legacy class (since JDK 1.1) and retrofitted when Java 2D was introduced. For higher-quality and smoother graphics (e.g., rotation), <code>int</code>-precision is insufficient. Java 2D, hence, introduced <code>float</code>-precision and <code>double</code>-precision points.</p>

<p><code>Point2D.Double</code> (for <code>double</code>-precision point) and <code>Point2D.Float</code> (for <code>float</code>-precision point) are, however, implemented as nested <code>public static</code> subclasses inside the <code>Point2D</code> outer class.</p>
<p>Recall that nested class (or inner class) can be used for:</p>
<ol>
<li>Simplifying access control: inner class can access the <code>private</code> variables of the enclosing outer class, as they are at the same level.</li>
<li>Keeping codes together and namespace management.</li>
</ol>

<p>In this case, it is used for namespace management, as there is no access-control involved.</p>
<pre class="color-syntax">
package java.awt.geom;
abstract public class <strong>Point2D</strong> {  <span class="color-comment">// outer class</span>
&nbsp;
   <strong>public static class Double extend Point2D</strong> {  <span class="color-comment">// public static nested class and subclass</span>
      public double x;
      public double y;
      <span class="color-comment">// Constructor</span>
      public Double(double x, double y) { this.x = x; this.y = y; }
      <span class="color-comment">// Provides implementation to the abstract methods</span>
      public double getX() { return x; }
      public double getY() { return y; }
      public void setLocation(double x, double y) {
         this.x = x;
         this.y = y;
      }
      <span class="color-comment">// Other methods</span>
      ......
   }
&nbsp;
   <strong>public static class Float extend Point2D</strong> {  <span class="color-comment">// public static nested class and subclass</span>
      public float x;
      public float y;
      <span class="color-comment">// Constructor</span>
      public Float(float x, float y) { this.x = x; this.y = y; }
      <span class="color-comment">// Provide implementation to the abstract methods</span>
      public double getX() { return x; }
      public double getY() { return y; }
      public void setLocation(double x, double y) {
         this.x = (float)x;
         this.y = (float)y;
      }
      <span class="color-comment">// Other methods</span>
      ......
   }
&nbsp;
   <span class="color-comment">// Definition for the outer class</span>
   abstract public double getX();
   abstract public double getY();
   abstract public void setLocation(double x, double y);
   ......
}</pre>

<p><code>Double</code> and <code>Float</code> are <code>static</code>. In other words, they can be referenced via the classname as <code>Point2D.Double</code> and <code>Point2D.Float</code>, and used directly without instantiating the outer class, just like any <code>static</code> variable or method (e.g., <code>Math.PI</code>, <code>Math.sqrt()</code>, <code>Integer.parseInt()</code>). They are subclasses of <code>Point2D</code>, and thus can be upcasted to <code>Point2D</code>.</p>

<pre class="color-example">
Point2D.Double p1 = new Point2D.Double(1.1, 2.2);
Point2D.Float  p2 = new Point2D.Float(3.3f, 4.4f);
Point          p3 = new Point(5, 6);
<span class="color-comment"></span><span class="color-comment">// You can upcast subclasses Point2D.Double, Point2D.Float and Point to superclass Point2D.</span>
Point2D p4 = new Point2D.Double(1.1, 2.2);
Point2D p5 = new Point2D.Float(3.3f, 4.4f);
Point2D p6 = new Point(5, 6);</pre>

<p>In summary, you can treat <code>Point2D.Double</code> and <code>Point2D.Float</code> as <em>ordinary</em> classes with a slightly longer name. They were designed as nested class for namespace management, instead of calling them <code>Point2DDouble</code> and <code>Point2DFloat</code>.</p>

<p>Note: These classes were designed before JDK 1.5, which introduces generic to support passing of type.</p>

<h4>Interface <span class="font-code">java.awt.Shape</span></h4>

<p>Almost all the <code>Xxx2D</code> classes (except <code>Point2D</code>) implements <code>java.awt.Shape</code> interface. It can be used as argument in <code>Graphics2D</code>'s <code>draw(<em>Shape</em>)</code> and <code>fill(<em>Shape</em>)</code> methods.</p>

<p>The <code>Shape</code> interface declares <code>abstract</code> methods <code>contains()</code> and <code>intersects()</code>, which are useful in game programming for collision detection:</p>
<pre class="color-syntax">
<span class="color-comment">// Is this point within this Shape's bounds?</span>
boolean contains(double x, double y)   
boolean contains(Point2D p)
<span class="color-comment">// Is this rectangle within this Shape's bounds?</span>
boolean contains(double x, double y, double width, double height)
boolean contains(Rectangle2D rect)
<span class="color-comment">// Does the interior of the given bounding rectangle intersect with this shape?</span>
boolean intersects(double x, double y, double width, double height)
boolean intersects(Rectangle2D rect)</pre>

<p>The <code>Shape</code> interface also declares methods to return the bounding rectangle of this shape (again, useful in collision detection).</p>
<pre class="color-syntax">
Rectangle getBounds()       <span class="color-comment">// int-precision</span>
Rectangle2D getBounds2D()   <span class="color-comment">// higher precision version</span></pre>

<p>The <code>Shape</code> interface declares a method called <code>getPathIterator()</code> to retrieve a <code>PathIterator</code> object that can be used to iterate along the <code>Shape</code> boundary.</p>
<pre class="color-syntax">
PathIterator getPathIterator(AffineTransform at)
PathIterator getPathIterator(AffineTransform at, double flatness)</pre>

<p>The popular legacy <code>java.awt.Polygon</code> class was retrofitted to implement <code>Shape</code> interface. However, there is no <code>Polyon2D</code> in Java 2D, which can be served by a more generic <code>Path2D</code>.</p>

<p>[TODO] Example</p>

<h4><span class="font-code">Stroke</span>, <span class="font-code">Paint</span> and <span class="font-code">Composite</span> Attributes</h4>

<h5>Pen's Stroke</h5>
<p>The <code>Graphisc2D</code>'s stroke attribute control the pen-stroke used for the outline of a shape. It is set via the <code>Graphis2D</code>'s <code>setStroke()</code>. A <code>Stroke</code> object implements <code>java.awt.Stroke</code> interface. Java 2D provides a built-in <code>java.awt.BasicStroke</code>.</p>

<pre class="color-syntax">
public <strong>BasicStroke</strong>(float width, int cap, int join, float miterlimit, float[] dash, float dash_phase)
   <span class="color-comment">// All parameters are optional
   // <em>width</em>:  width of the pen stroke
   // <em>cap</em>: the decoration of the ends, CAP_ROUND, CAP_SQUARE or CAP_BUTT.
   // <em>join</em>: the decoration where two segments meet, JOIN_ROUND, JOIN_MITER, or JOIN_BEVEL
   // <em>miterlimit</em>: the limit to trim the miter join.
   // <em>dash</em>: the array representing the dashing pattern.
   // <em>dash_phase</em>: the offset to start the dashing pattern</span></pre>

<p>For example,</p>

<pre class="color-example">
g2d.setStroke(new BasicStroke(10, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
g2d.setColor(Color.CYAN);
g2d.draw(new Rectangle2D.Double(300, 50, 200, 100));
  
<span class="color-comment">// Test dash-stroke</span>
float[] dashPattern = {20, 5, 10, 5};  <span class="color-comment">// dash, space, dash, space</span>
g2d.setStroke(new BasicStroke(5, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND,
      10, dashPattern, 0));
g2d.setColor(Color.CYAN);
g2d.draw(new Rectangle2D.Double(50, 200, 200, 100));</pre>

<h5>Paint</h5>

<p>The <code>Graphics2D</code>'s paint attribute determines the color used to render the shape. It is set via the <code>Graphics2D</code>'s <code>setPaint()</code> method. A <code>Paint</code> object implements the <code>java.awt.Paint</code> interface. Java 2D provides many built-in <code>Paint</code> objects such as <code>GradientPaint</code>, <code>LinearGradientPaint</code>, <code>RadialGradientPaint</code>, <code>MultipleGradientPaint</code>, <code>TexturePaint</code>, and others.</p>

<p>For example,</p>
<pre class="color-example">
g2d.setPaint(new GradientPaint(50, 80, Color.RED, 250, 180, Color.GREEN));
   <span class="color-comment">// set current paint context to a GradientPaint, from (x1, y1) with color1 to (x2, y2) with color2</span>
g2d.fill(new Rectangle2D.Double(50, 80, 200, 100));
   <span class="color-comment">// fill the Shap with the current paint context</span></pre>

<h5>Composite</h5>
<p>[TODO] How to compose the drawing of primitive with the underlying graphics area.</p>

<h3>Working with Bitmap Images</h3>

<img class="image-float-right" src="images/Graphics_ImageClassDiagram.png" />

<p><span class="line-heading">Reference:</span> Java Tutorial's &quot;2D Graphics&quot; Section &quot;Working with Images&quot; @ <a href="http://docs.oracle.com/javase/tutorial/2d/images/index.html">http://docs.oracle.com/javase/tutorial/2d/images/index.html</a>&quot;</p>

<p>A bitmap image is a 2D rectangular array of <em>pixels</em>. Each pixel has a <em>color</em> value (typically in RGB or RGBA). The dimension of the image is represented by its <em>width</em> and <em>length</em> in pixels. In Java, the origin (0, 0) of an image is positioned at the top-left corner, like all other components.</p>

<p>Most of the image display and processing methods work on <code>java.awt.Image</code>. <code>Image</code> is an <code>abstract</code> class that represent an image as a rectangular array of pixels. The most commonly-used implementation subclass is <code>java.awt.image.BufferedImage</code>, which stores the pixels in memory buffer so that they can be directly accessed. A <code>BufferedImage</code> comprises a <code>ColorModel</code> and a <code>Raster</code> of pixels. The <code>ColorModel</code> provides a color interpretation of the image's pixel data.</p>

<p>An <code>Image</code> object (and subclass <code>BufferedImage</code>) can be rendered onto a <code>JComponent</code> (such as <code>JPanel</code>) via <code>Graphics</code>' (or <code>Graphics2D</code>') <code>drawImage()</code> method.</p>

<p>Image is typically read in from an external image file into a <code>BufferedImage</code> (although you can create a <code>BufferedImage</code> based on algorithm). Image file formats supported by JDK include:</p>

<ul>
<li>GIF</li>
<li>PNG (Portable Network Graphics)</li>
<li>JPEG</li>
<li>BMP</li>
</ul>

<p><code>BufferedImage</code> supports image filtering operations (such as convolution). The resultant image can be painted on the screen, sent to printer, or save to an external file.</p>


<h5>Transparent vs. Opaque Background</h5>
<p>PNG  and GIF supports transparent background.  JPEG does not. PNG and GIF are palette-based. They maintain a list of palettes and map each palette number to a RGB color value. Every image pixel is then labeled with a palette number, which is then mapped to the actual RGB values. One of the palette number can be designated as <em>transparent</em>. Pixels with this transparent palette value will not be displayed. Instead, the background of the image is displayed.</p>
<h4 id="loadimage">Loading Images</h4>

<p>There are several ways to create an <code>Image</code> for use in your program.</p>

<h5>Using <span class="font-code">ImageIO.read()</span> (JDK 1.4)</h5>

<p>The easiest way to load an image into your program is to use the <code>static</code> method <code>ImageIO.read()</code> of the <code>javax.imageio.ImageIO</code> class, which returns a <code>java.awt.image.BufferedImage</code>. Similar, you can use <code>ImageIO.write()</code> to write an image.</p>
<pre class="color-syntax">
public static BufferedImage <strong>read</strong>(URL <em>imagePath</em>) throws IOException
public static BufferedImage <strong>read</strong>(File <em>imagePath</em>) throws IOException
public static BufferedImage <strong>read</strong>(InputStream <em>stream</em>) throws IOException
public static BufferedImage <strong>read</strong>(ImageInputStream <em>stream</em>) throws IOException</pre>

<p>Instead of using <code>java.io.File</code> class to handle a disk file, it is better to use <code>java.net.URL</code>. <code>URL</code> is more flexible and can handle files from more sources, such as disk file and JAR file (used for distributing your program). It works on application as well as applet. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.io.IOException;
import java.net.URL;
import javax.imageio.ImageIO;
import javax.swing.*;
 
<span class="color-comment">/** Test loading an external image into a BufferedImage using ImageIO.read() */</span>
@SuppressWarnings(&quot;serial&quot;)
public class LoadImageDemo extends JPanel {
   <span class="color-comment">// Named-constants</span>
   public static final int CANVAS_WIDTH = 640;
   public static final int CANVAS_HEIGHT = 480;
   public static final String TITLE = &quot;Load Image Demo&quot;;
 
   private String imgFileName = &quot;images/duke.gif&quot;; <span class="color-comment">// relative to project root (or bin)</span>
   private Image img;  <span class="color-comment">// a BufferedImage object</span>
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public LoadImageDemo() {
      <span class="color-comment">// Load an external image via URL</span>
      URL imgUrl = getClass().getClassLoader().getResource(imgFileName);
      if (imgUrl == null) {
         System.err.println(&quot;Couldn't find file: &quot; + imgFileName);
      } else {
         try {
            img = ImageIO.read(imgUrl);
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
 
      setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
   }
 
   <span class="color-comment">/** Custom painting codes on this JPanel */</span>
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);    <span class="color-comment">// paint background</span>
      setBackground(Color.WHITE);
      g.drawImage(img, 50, 50, null);
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(&quot;Load Image Demo&quot;);
            frame.setContentPane(new LoadImageDemo());
            frame.pack();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Using <span class="font-code">Toolkit</span>'s <span class="font-code">getImage()</span></h5>

<pre class="color-syntax">
<span class="color-comment">// In java.awt.Toolkit</span>
public abstract Image getImage(URL url)
public abstract Image getImage(String filename)</pre>

<p>For example,</p>
<pre class="color-example">
import java.awt.Toolkit;
......
Toolkit tk = Toolkit.getDefaultToolkit();
Image img = tk.getImage(&quot;images/duke.gif&quot;);</pre> 

<h5>Via <span class="font-code">ImageIcon</span>'s <span class="font-code">getImage()</span></h5>

<p><code>ImageIcon</code> is used to decorate <code>JComponent</code>s (such as <code>JLabel</code> and <code>JButton</code>). Construct an <code>ImageIcon</code> and get an <code>Image</code> via <code>ImageIcon</code>'s <code>getImage()</code>. For example,</p>

<pre class="color-example">
ImageIcon icon = null;
String imgFilename = &quot;images/duke.gif&quot;;
java.net.URL imgURL = getClass().getClassLoader().getResource(imgFilename);
if (imgURL != null) {
   icon =  new ImageIcon(imgURL);
} else {
   System.err.println(&quot;Couldn't find file: &quot; + imgFilename);
}
Image img = icon.getImage();</pre>

<p>On the other hand, you can also construct an <code>ImageIcon</code> from an <code>Image</code> object via constructor:</p>
<pre class="color-syntax">
public ImageIcon(Image image)   <span class="color-comment">// Construct an ImageIcon from the Image object</span></pre>

<p>[TODO] Benchmark these methods for small and large images.</p>

<h4><span class="font-code">drawImage()</span></h4>
<p>The <code>java.awt.Graphics</code> class declares 6 versions of<code> drawImage()</code> for drawing bitmap images. The subclass <code>java.awt.Graphics2D</code> adds a few more.</p>

<pre class="color-syntax">
<span class="color-comment">// In class java.awt.Graphics</span>
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, Color <em>bgcolor</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>, Color <em>bgcolor</em>, ImageObserver <em>observer</em>)
   <span class="color-comment">// The <em>img</em> is drawn with its top-left corner at (<em>x</em>, <em>y</em>) scaled to the specified <em>width</em> and <em>height</em>
   //  (default to the image's width and height).
   // The <em>bgColor</em> (background color) is used for &quot;transparent&quot; pixels.</span>

public abstract boolean drawImage(Image <em>img</em>, int <em>destX1</em>, int <em>destY1</em>, int <em>destX2</em>, int <em>destY2</em>,
      int <em>srcX1</em>, int <em>srcY1</em>, int <em>srcX2</em>, int <em>srcY2</em>, ImageObserver <em>observer</em>)
public abstract boolean drawImage(Image <em>img</em>, int <em>destX1</em>, int <em>destY1</em>, int <em>destX2</em>, int <em>destY2</em>,
      int <em>srcX1</em>, int <em>srcY1</em>, int <em>srcX2</em>, int <em>srcY2</em>, Color <em>bgcolor</em>, ImageObserver <em>observer</em>)
   <span class="color-comment">// The <em>img</em> &quot;clip&quot; bounded by (<em>scrX1</em>, <em>scrY2</em>) and (<em>scrX2</em>, <em>srcY2</em>) is scaled and drawn from
   // (<em>destX1</em>, <em>destY1</em>) to (<em>destX2</em>, <em>destY2</em>).</span></pre>

<img class="image-center" src="images/Graphics_DrawImage.png" />

<p>The coordinates involved is shown in the above diagram. The <code>ImageObserver</code> receives notification about the <code>Image</code> as it is loaded. In most purposes, you can set it to <code>null</code>, or the custom drawing <code>JPanel</code> (via <code>this</code>). The <code>ImageObserver</code> is not needed for <code>BufferedImage</code>, and shall be set to <code>null</code>.</p>

<h5><span class="font-code">Graphics2D</span>'s <span class="font-code">drawImage()</span></h5>

<p><code>Graphics2D</code> supports affine transform and image filtering operations on images, as follows:</p>

<pre class="color-syntax">
<span class="color-comment">// In class java.awt.Graphics2D</span>
public abstract boolean drawImage(Image img, AffineTransform xform, ImageObserver obs)
   <span class="color-comment">// Apply the specified AffineTransform to the image</span>
public abstract void drawImage(BufferedImage img, BufferedImageOp op, int x, int y)
   <span class="color-comment">// Apply the specified image filtering operation to the image</span>
 
public abstract void drawRenderedImage(RenderedImage img, AffineTransform xform)
public abstract void drawRenderableImage(RenderableImage img, AffineTransform xform)</pre>

<h4>Image Affine Transforms</h4>

<img class="image-float-right" src="images/Graphics_TestAffineTransformImage.png" />

<p>Java 2D's affine transform works on bitmap image as well as vector graphics. However, instead of manipulating the <code>Graphics2D</code>'s current transform context (which operates on vector-graphics only via rendering methods <code>drawXxx()</code> and <code>fillXxx()</code>), you need to allocate an <code>AffineTransform</code> object to perform transformation on images.</p>

<h5> Code Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80</pre>
</td>
<td>
<pre>
import java.awt.geom.AffineTransform;
import javax.imageio.ImageIO;
import java.net.URL;
import java.awt.*;
import javax.swing.*;
import java.io.*;
 
<span class="color-comment">/** Test applying affine transform on images */</span>
@SuppressWarnings(&quot;serial&quot;)
public class ImageTransformDemo extends JPanel {
   <span class="color-comment">// Named-constants for dimensions</span>
   public static final int CANVAS_WIDTH = 640;
   public static final int CANVAS_HEIGHT = 480;
   public static final String TITLE = &quot;Image Transform Demo&quot;;
 
   <span class="color-comment">// Image</span>
   private String imgFileName = &quot;images/duke.png&quot;; <span class="color-comment">// relative to project root or bin</span>
   private Image img;
   private int imgWidth, imgHeight;    <span class="color-comment">// width and height of the image</span>
   private double x = 100.0, y = 80.0; <span class="color-comment">// center (x, y), with initial value</span>
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public ImageTransformDemo() {
      <span class="color-comment">// URL can read from disk file and JAR file</span>
      URL url = getClass().getClassLoader().getResource(imgFileName);
      if (url == null) {
         System.err.println(&quot;Couldn't find file: &quot; + imgFileName);
      } else {
         try {
            img = ImageIO.read(url);
            imgWidth = img.getWidth(this);
            imgHeight = img.getHeight(this);
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
 
      this.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
   }
 
   <span class="color-comment">/** Custom painting codes on this JPanel */</span>
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);    <span class="color-comment">// paint background</span>
      setBackground(Color.WHITE);
 
      Graphics2D g2d = (Graphics2D) g;
      g2d.drawImage(img, 0, 0, this);  <span class="color-comment">// Display with top-left corner at (0, 0)</span>
 
      <span class="color-comment">// drawImage() does not use the current transform of the Graphics2D context</span>
      <span class="color-comment">// Need to create a AffineTransform and pass into drawImage()</span>
      AffineTransform transform = new AffineTransform();  <span class="color-comment">// identity transform</span>
      <span class="color-comment">// Display the image with its center at the initial (x, y)</span>
      transform.translate(x - imgWidth/2, y - imgHeight/2);
      g2d.drawImage(img, transform, this);
      <span class="color-comment">// Try applying more transform to this image</span>
      for (int i = 0; i &lt; 5; ++i) {
         transform.translate(70.0, 5.0);
         transform.rotate(Math.toRadians(15), imgWidth/2, imgHeight/2); <span class="color-comment">// about its center</span>
         transform.scale(0.9, 0.9);
         g2d.drawImage(img, transform, this);
      }
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(TITLE);
            frame.setContentPane(new ImageTransformDemo());
            frame.pack();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null); <span class="color-comment">// center the application window</span>
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Image Filtering Operations</h4>
<p><code>Graphics2D</code> supports image filtering operations via the following <code>drawImage()</code> method:</p>

<pre class="color-syntax">
public abstract void drawImage(BufferedImage img, BufferedImageOp op, int x, int y)
   <span class="color-comment">// Apply the specified image filtering operation to the image</span></pre>

<p>Many built-in image filtering operations are available in <code>java.awt.image</code> package.</p>

<p>[TODO] more and example</p>

<h4>Animating Image Frames</h4>
<p>There are two ways to organize animated image frames:</p>
<ol>
<li>Keep each of the frames in its own file.</li>
<li>Keep all of the frames in a stripe (1D or 2D) in a single file for better organization and faster loading.</li>
</ol>

<h5>Code Example 1: Each Frame in its Own File</h5>
<p>Three image frames (in its own file) was used in this example, as follow:</p>
<img src="images/GamePacman_1.png" />
<img src="images/GamePacman_2.png" />
<img src="images/GamePacman_3.png" />
<p>In a typical game, the actor has a <code>(x, y)</code> position, move at a certain <code>speed</code> (in pixels per move-step) and <code>direction</code> (in degrees), and may rotate at a <code>rotationSpeed</code> (in degrees per move-step).</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132</pre>
</td>
<td>
<pre>
import java.awt.geom.AffineTransform;
import javax.imageio.ImageIO;
import java.net.URL;
import java.awt.*;
import javax.swing.*;
import java.io.*;
 
<span class="color-comment">/** Animating image frames. Each frame has its own file */</span>
@SuppressWarnings(&quot;serial&quot;)
public class AnimatedFramesDemo extends JPanel {
   <span class="color-comment">// Named-constants</span>
   static final int CANVAS_WIDTH = 640;
   static final int CANVAS_HEIGHT = 480;
   public static final String TITLE = &quot;Animated Frame Demo&quot;;
 
   private String[] imgFilenames = {
         &quot;images/pacman_1.png&quot;, &quot;images/pacman_2.png&quot;, &quot;images/pacman_3.png&quot;};
   private Image[] imgFrames;    <span class="color-comment">// array of Images to be animated</span>
   private int currentFrame = 0; <span class="color-comment">// current frame number</span>
   private int frameRate = 5;    <span class="color-comment">// frame rate in frames per second</span>
   private int imgWidth, imgHeight;    <span class="color-comment">// width and height of the image</span>
   private double x = 100.0, y = 80.0; <span class="color-comment">// (x,y) of the center of image</span>
   private double speed = 8;           <span class="color-comment">// displacement in pixels per move</span>
   private double direction = 0;       <span class="color-comment">// in degrees</span>
   private double rotationSpeed = 1;   <span class="color-comment">// in degrees per move</span>
 
   <span class="color-comment">// Used to carry out the affine transform on images</span>
   private AffineTransform transform = new AffineTransform();
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public AnimatedFramesDemo() {
      <span class="color-comment">// Setup animation</span>
      loadImages(imgFilenames);
      Thread animationThread = new Thread () {
         @Override
         public void run() {
            while (true) {
               update();   <span class="color-comment">// update the position and image</span>
               repaint();  <span class="color-comment">// Refresh the display</span>
               try {
                  Thread.sleep(1000 / frameRate); <span class="color-comment">// delay and yield to other threads</span>
               } catch (InterruptedException ex) { }
            }
         }
      };
      animationThread.start();  <span class="color-comment">// start the thread to run animation</span>
 
      <span class="color-comment">// Setup GUI</span>
      setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
   }
 
   <span class="color-comment">/** Helper method to load all image frames, with the same height and width */</span>
   private void loadImages(String[] imgFileNames) {
      int numFrames = imgFileNames.length;
      imgFrames = new Image[numFrames];  <span class="color-comment">// allocate the array</span>
      URL imgUrl = null;
      for (int i = 0; i &lt; numFrames; ++i) {
         imgUrl = getClass().getClassLoader().getResource(imgFileNames[i]);
         if (imgUrl == null) {
            System.err.println(&quot;Couldn't find file: &quot; + imgFileNames[i]);
         } else {
            try {
               imgFrames[i] = ImageIO.read(imgUrl);  <span class="color-comment">// load image via URL</span>
            } catch (IOException ex) {
               ex.printStackTrace();
            }
         }
      }
      imgWidth = imgFrames[0].getWidth(null);
      imgHeight = imgFrames[0].getHeight(null);
   }
 
   <span class="color-comment">/** Update the position based on speed and direction of the sprite */</span>
   public void update() {
      x += speed * Math.cos(Math.toRadians(direction));  <span class="color-comment">// x-position</span>
      if (x &gt;= CANVAS_WIDTH) {
         x -= CANVAS_WIDTH;
      } else if (x &lt; 0) {
         x += CANVAS_WIDTH;
      }
      y += speed * Math.sin(Math.toRadians(direction));  <span class="color-comment">// y-position</span>
      if (y &gt;= CANVAS_HEIGHT) {
         y -= CANVAS_HEIGHT;
      } else if (y &lt; 0) {
         y += CANVAS_HEIGHT;
      }
      direction += rotationSpeed;  <span class="color-comment">// update direction based on rotational speed</span>
      if (direction &gt;= 360) {
         direction -= 360;
      } else if (direction &lt; 0) {
         direction += 360;
      }
      ++currentFrame;    <span class="color-comment">// display next frame</span>
      if (currentFrame &gt;= imgFrames.length) {
         currentFrame = 0;
      }
   }
 
   <span class="color-comment">/** Custom painting codes on this JPanel */</span>
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g);  <span class="color-comment">// paint background</span>
      setBackground(Color.WHITE);
      Graphics2D g2d = (Graphics2D) g;
 
      transform.setToIdentity();
      <span class="color-comment">// The origin is initially set at the top-left corner of the image.</span>
      <span class="color-comment">// Move the center of the image to (x, y).</span>
      transform.translate(x - imgWidth / 2, y - imgHeight / 2);
      <span class="color-comment">// Rotate about the center of the image</span>
      transform.rotate(Math.toRadians(direction),
            imgWidth / 2, imgHeight / 2);
      <span class="color-comment">// Apply the transform to the image and draw</span>
      g2d.drawImage(imgFrames[currentFrame], transform, null);
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(TITLE);
            frame.setContentPane(new AnimatedFramesDemo());
            frame.pack();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null); <span class="color-comment">// center the application window</span>
            frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<p>[TODO]</p>

<h5>Code Example 2: Frames Organized in a Stripe</h5>

<p>In this example, all the frames of an animated sequence are kept in a single file organized in rows and columns.</p>
<img src="images/GameGhostStripe.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134</pre>
</td>
<td>
<pre>
import javax.imageio.ImageIO;
import java.net.URL;
import java.awt.*;
import javax.swing.*;
import java.io.*;
 
<span class="color-comment">/** Animating image frames. All frames kept in a stripe. */</span>
@SuppressWarnings(&quot;serial&quot;)
public class AnimatedFramesInStripe extends JPanel {
   <span class="color-comment">// Named-constants</span>
   static final int CANVAS_WIDTH = 640;
   static final int CANVAS_HEIGHT = 480;
   public static final String TITLE = &quot;Animated Frame Demo&quot;;
 
   private String imgFilename = &quot;images/GhostStripe.png&quot;;
   private int numRows, numCols, numFrames;
   private Image img;         <span class="color-comment">// for the entire image stripe</span>
   private int currentFrame;  <span class="color-comment">// current frame number</span>
   private int frameRate = 5; <span class="color-comment">// frame rate in frames per second</span>
   private int imgWidth, imgHeight;  <span class="color-comment">// width and height of the image</span>
   private double x = 100.0, y = 80.0; <span class="color-comment">// (x,y) of the center of image</span>
   private double speed = 8;           <span class="color-comment">// displacement in pixels per move</span>
   private double direction = 0;       <span class="color-comment">// in degrees</span>
   private double rotationSpeed = 1;   <span class="color-comment">// in degrees per move</span>
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public AnimatedFramesInStripe() {
      <span class="color-comment">// Setup animation</span>
      loadImage(imgFilename, 2, 4);
      Thread animationThread = new Thread () {
         @Override
         public void run() {
            while (true) {
               update();   <span class="color-comment">// update the position and image</span>
               repaint();  <span class="color-comment">// Refresh the display</span>
               try {
                  Thread.sleep(1000 / frameRate); <span class="color-comment">// delay and yield to other threads</span>
               } catch (InterruptedException ex) { }
            }
         }
      };
      animationThread.start();  <span class="color-comment">// start the thread to run animation</span>
 
      <span class="color-comment">// Setup GUI</span>
      setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
   }
 
   <span class="color-comment">/** Helper method to load image. All frames have the same height and width */</span>
   private void loadImage(String imgFileName, int numRows, int numCols) {
      URL imgUrl = getClass().getClassLoader().getResource(imgFileName);
      if (imgUrl == null) {
         System.err.println(&quot;Couldn't find file: &quot; + imgFileName);
      } else {
         try {
            img = ImageIO.read(imgUrl);  <span class="color-comment">// load image via URL</span>
         } catch (IOException ex) {
            ex.printStackTrace();
         }
      }
      numFrames = numRows * numCols;
      this.imgHeight = img.getHeight(null) / numRows;
      this.imgWidth = img.getWidth(null) / numCols;
      this.numRows = numRows;
      this.numCols = numCols;
      currentFrame = 0;
   }
 
   <span class="color-comment">/** Returns the top-left x-coordinate of the given frame number. */</span>
   private int getcurrentFrameX() {
      return (currentFrame % numCols) * imgWidth;
   }
 
   <span class="color-comment">/** Returns the top-left y-coordinate of the given frame number. */</span>
   private int getCurrentFrameY() {
      return (currentFrame / numCols) * imgHeight;
   }
 
   <span class="color-comment">/** Update the position based on speed and direction of the sprite */</span>
   public void update() {
      x += speed * Math.cos(Math.toRadians(direction));  <span class="color-comment">// x-position</span>
      if (x &gt;= CANVAS_WIDTH) {
         x -= CANVAS_WIDTH;
      } else if (x &lt; 0) {
         x += CANVAS_WIDTH;
      }
      y += speed * Math.sin(Math.toRadians(direction));  <span class="color-comment">// y-position</span>
      if (y &gt;= CANVAS_HEIGHT) {
         y -= CANVAS_HEIGHT;
      } else if (y &lt; 0) {
         y += CANVAS_HEIGHT;
      }
      direction += rotationSpeed;  <span class="color-comment">// update direction based on rotational speed</span>
      if (direction &gt;= 360) {
         direction -= 360;
      } else if (direction &lt; 0) {
         direction += 360;
      }
      ++currentFrame;    <span class="color-comment">// displays next frame</span>
      if (currentFrame &gt;= numFrames) {
         currentFrame = 0;
      }
   }
 
   <span class="color-comment">/** Custom painting codes on this JPanel */</span>
   @Override
   public void paintComponent(Graphics g) {
      super.paintComponent(g); <span class="color-comment">// paint background</span>
      setBackground(Color.WHITE);
      Graphics2D g2d = (Graphics2D) g;
 
      int frameX = getcurrentFrameX();
      int frameY = getCurrentFrameY();
      g2d.drawImage(img,
            (int)x - imgWidth / 2, (int)y - imgHeight / 2,
            (int)x + imgWidth / 2, (int)y + imgHeight / 2,
            frameX, frameY, frameX + imgWidth, frameY + imgHeight, null);
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            JFrame frame = new JFrame(TITLE);
            frame.setContentPane(new AnimatedFramesInStripe());
            frame.pack();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLocationRelativeTo(null); <span class="color-comment">// center the application window</span>
           frame.setVisible(true);
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<p>[TODO]</p>

<h3>High Performance Graphics</h3>

<h4>Full-Screen Display Mode (JDK 1.4)</h4>
<p><span class="line-heading">Reference:</span> Java Tutorial's &quot;Full-Screen Exclusive Mode API&quot; @<a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html</a>.</p>
<p>You could check if full-screen mode is supported in your graphics environment by invoking <code>isFullScreenSupported()</code> of the screen <code>GraphicsDevice</code>:</p>
<pre class="color-example">
GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
GraphicsDevice defaultScreen = env.getDefaultScreenDevice();
System.out.println(&quot;isFullScreenSupported: &quot; + defaultScreen.isFullScreenSupported());
 
<span class="color-comment">// Enter fullscreen mode</span>
setUndecorated(true);
setResizable(false);
defaultScreen.setFullScreenWindow(this);  <span class="color-comment">// &quot;this&quot; JFrame</span></pre>

<p>To enter fullscreen mode, use <code>GraphicsDevice</code>'s <code>setFullScreenWindow(JFrame)</code>. To leave the fullscreen mode and return to windowed mode, use <code>setFullScreenWindow(null)</code>. You should not try to <code>setSize()</code> or resize the window in full screen mode.</p>
<p>You could run your program in fullscreen (without the window's title bar) by invoking <code>JFrame</code>'s <code>setUndecorated(true)</code>.</p>
<p>There are a few ways to find out the current screen size:</p>
<pre class="color-example">
<span class="color-comment">// via the default Toolkit</span>
Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
int screenWidth = (int)dim.getWidth();
int screenHeight = (int)dim.getHeight();</pre>
<h5>Code Example 1: Running in Fullscreen Mode</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
 
<span class="color-comment">/** Testing the full-screen mode */</span>
@SuppressWarnings(&quot;serial&quot;)
public class FullScreenDemo extends JFrame {
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public FullScreenDemo() {
      <span class="color-comment">// Check if full screen mode supported?</span>
      <span class="color-new">GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
      GraphicsDevice defaultScreen = env.getDefaultScreenDevice();</span>
      if (!defaultScreen.isFullScreenSupported()) {
         System.err.println(&quot;Full Screen mode is not supported!&quot;);
         System.exit(1);
      }
 
      <span class="color-comment">// Use ESC key to quit</span>
      addKeyListener(new KeyAdapter() {
         @Override
         public void keyPressed(KeyEvent e) {
            if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
               System.exit(0);
            }
         }
      });
 
      setContentPane(new DrawCanvas());
      setDefaultCloseOperation(EXIT_ON_CLOSE);
      <span class="color-new">setUndecorated(true);
      setResizable(false);
      defaultScreen.setFullScreenWindow(this);</span> <span class="color-comment">// full-screen mode</span>
      setVisible(true);
   }
 
   <span class="color-comment">/** DrawCanvas (inner class) is a JPanel used for custom drawing */</span>
   private class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);
         setBackground(Color.BLACK);
 
         <span class="color-comment">// Paint messages</span>
         g.setColor(Color.YELLOW);
         g.setFont(new Font(Font.DIALOG, Font.BOLD, 30));
         FontMetrics fm = g.getFontMetrics();
         String msg = &quot;In Full-Screen mode&quot;;
         int msgWidth = fm.stringWidth(msg);
         int msgAscent = fm.getAscent();
         int msgX = getWidth() / 2 - msgWidth / 2;
         int msgY = getHeight() / 2 + msgAscent / 2;
         g.drawString(msg, msgX, msgY);
 
         g.setColor(Color.WHITE);
         g.setFont(new Font(Font.DIALOG, Font.PLAIN, 18));
         fm = g.getFontMetrics();
         msg = &quot;Press ESC to quit&quot;;
         msgWidth = fm.stringWidth(msg);
         int msgHeight = fm.getHeight();
         msgX = getWidth() / 2 - msgWidth / 2;
         msgY += msgHeight * 1.5;
         g.drawString(msg, msgX, msgY);
      }
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new FullScreenDemo();
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>



<h5>Code Example 2: Switching between Fullscreen and Windowed Mode</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
 
<span class="color-comment">/** Testing the full-screen mode */</span>
@SuppressWarnings(&quot;serial&quot;)
public class FullScreenEscDemo extends JFrame {
   <span class="color-comment">// Windowed mode settings</span>
   private static String winModeTitle =
         &quot;Switching between Full Screen Mode and Windowed Mode Demo&quot;;
   private static int winModeX, winModeY;          <span class="color-comment">// top-left corner (x, y)</span>
   private static int winModeWidth, winModeHeight; <span class="color-comment">// width and height</span>
 
   private boolean inFullScreenMode;    <span class="color-comment">// in fullscreen or windowed mode?</span>
   private boolean fullScreenSupported; <span class="color-comment">// is fullscreen supported?</span>
 
   <span class="color-comment">/** Constructor to set up the GUI components */</span>
   public FullScreenEscDemo() {
      <span class="color-comment">// Get the screen width and height</span>
      Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
      <span class="color-comment">// Set the windowed mode initial width and height to about fullscreen</span>
      winModeWidth = (int)dim.getWidth();
      winModeHeight = (int)dim.getHeight() - 35; <span class="color-comment">// minus task bar</span>
      winModeX = 0;
      winModeY = 0;
 
      <span class="color-comment">// Check if full screen mode supported?</span>
      GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
      final GraphicsDevice defaultScreen = env.getDefaultScreenDevice();
      fullScreenSupported = defaultScreen.isFullScreenSupported();
 
      if (fullScreenSupported) {
         setUndecorated(true);
         setResizable(false);
         defaultScreen.setFullScreenWindow(this); <span class="color-comment">// full-screen mode</span>
         inFullScreenMode = true;
      } else {
         setUndecorated(false);
         setResizable(true);
         defaultScreen.setFullScreenWindow(null); <span class="color-comment">// windowed mode</span>
         setBounds(winModeX, winModeY, winModeWidth, winModeHeight);
         inFullScreenMode = false;
      }
 
      <span class="color-comment">// Use ESC key to switch between Windowed and fullscreen modes</span>
      this.addKeyListener(new KeyAdapter() {
         @Override
         public void keyPressed(KeyEvent e) {
            if (e.getKeyCode() == KeyEvent.VK_SPACE) {
               if (fullScreenSupported) {
                  if (!inFullScreenMode) {
                     <span class="color-comment">// Switch to fullscreen mode</span>
                     setVisible(false);
                     setResizable(false);
                     dispose();
                     setUndecorated(true);
                     defaultScreen.setFullScreenWindow(FullScreenEscDemo.this);
                     setVisible(true);
                  } else {
                     <span class="color-comment">// Switch to windowed mode</span>
                     setVisible(false);
                     dispose();
                     setUndecorated(false);
                     setResizable(true);
                     defaultScreen.setFullScreenWindow(null);
                     setBounds(winModeX, winModeY, winModeWidth, winModeHeight);
                     setVisible(true);
                  }
                  inFullScreenMode = !inFullScreenMode;
                  repaint();
               }
            } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
               System.exit(0);
            }
         }
      });
 
      <span class="color-comment">// To save the window width and height if the window has been resized.</span>
      this.addComponentListener(new ComponentAdapter() {
         @Override
         public void componentMoved(ComponentEvent e) {
            if (!inFullScreenMode) {
               winModeX = getX();
               winModeY = getY();
            }
         }
 
         @Override
         public void componentResized(ComponentEvent e) {
            if (!inFullScreenMode) {
               winModeWidth = getWidth();
               winModeHeight = getHeight();
            }
         }
      });
 
      setContentPane(new DrawCanvas());
      setDefaultCloseOperation(EXIT_ON_CLOSE);
      setTitle(winModeTitle);
      setVisible(true);
   }
 
   <span class="color-comment">/** DrawCanvas (inner class) is a JPanel used for custom drawing */</span>
   private class DrawCanvas extends JPanel {
      @Override
      public void paintComponent(Graphics g) {
         super.paintComponent(g);
         setBackground(Color.BLACK);
 
         <span class="color-comment">// Draw a box to indicate the borders</span>
         Graphics2D g2d = (Graphics2D)g;
         g2d.setStroke(new BasicStroke(8));
         g2d.setColor(Color.RED);
         g2d.drawRect(0, 0, getWidth()-1, getHeight()-1);
 
         <span class="color-comment">// Paint messages</span>
         g.setColor(Color.YELLOW);
         g.setFont(new Font(Font.DIALOG, Font.BOLD, 30));
         FontMetrics fm = g.getFontMetrics();
         String msg = inFullScreenMode ? &quot;In Full-Screen mode&quot; : &quot;In Windowed mode&quot;;
         int msgWidth = fm.stringWidth(msg);
         int msgAscent = fm.getAscent();
         int msgX = getWidth() / 2 - msgWidth / 2;
         int msgY = getHeight() / 2 + msgAscent / 2;
         g.drawString(msg, msgX, msgY);
 
         g.setColor(Color.WHITE);
         g.setFont(new Font(Font.DIALOG, Font.PLAIN, 18));
         fm = g.getFontMetrics();
         msg = &quot;Press SPACE to toggle between Full-screen/windowed modes, ESC to quit.&quot;;
         msgWidth = fm.stringWidth(msg);
         int msgHeight = fm.getHeight();
         msgX = getWidth() / 2 - msgWidth / 2;
         msgY += msgHeight * 1.5;
         g.drawString(msg, msgX, msgY);
      }
   }
 
   <span class="color-comment">/** The Entry main method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes on the Event-Dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new FullScreenEscDemo();
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Rendering to the Display &amp; Double Buffering</h4>
<p>The common problems in rendering a graphic object or image to the display are:</p>
<ul>
<li>Flashing (or flickering): caused by clearing the display and then drawing the graphics.</li>
<li>Image Tearing: For a moving object, the user sees part of the new image and part of the old one. </li>
</ul>

<p>The common way to resolve these display rendering problem is via so-called <em>double buffering</em>.</p>

<p>A few techniques are available in Java for double buffering:</p>
<ul>
<li>BufferStrategy (JDK 1.4)</li>
<li>BufferredImage</li>
<li>other??</li>
</ul>

<p>[TODO]</p>

<h4>Splash Screen</h4>
<p>To show a splash screen before launching your application, include command-line VM argument &quot;<code>-splash:<em>splashImagefilename</em></code>&quot; to display the image.</p>
<p>To show a progress bar over the splash screen, need to write some codes to overlay the progress bar on top of the splash screen. The following shows a simulation:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td>
<pre>
import java.awt.*;
 
<span class="color-comment">/** Splash Screen Demo (with a Progress Bar)
    Run with VM command-line option -splash:splashImageFilename */</span>
public class SplashScreenDemo {
 
   public static void main(String[] args) {
      SplashScreen splash = SplashScreen.getSplashScreen();
      if (splash == null) {
         System.err.println(&quot;Splash Screen not available!&quot;);
      } else {
         <span class="color-comment">// Okay, Splash screen created</span>
         Dimension splashBounds = splash.getSize();
         Graphics2D g2d = splash.createGraphics();
 
         <span class="color-comment">// Simulate a progress bar</span>
         for (int i = 0; i &lt; 100; i += 5) {
            g2d.setColor(Color.RED);
            g2d.fillRect(0, splashBounds.height / 2,
                  splashBounds.width * i / 100, 20);
            splash.update();
            try {
               Thread.sleep(200); <span class="color-comment">// Some delays</span>
            } catch (Exception e) {}
         }
         g2d.dispose();
         splash.close();
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>[TODO] Can we use the <code>JProgressBar</code> class?</p>


<p class="references">REFERENCES &amp; RESOURCES</p>
<ul>
<li>Java 2D Tutorial @ <a href="http://docs.oracle.com/javase/tutorial/2d/TOC.html">http://docs.oracle.com/javase/tutorial/2d/TOC.html</a>.</li>

<li>Java Tutorial's &quot;Full-Screen Exclusive Mode API&quot; @ <a href="http://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html">http://docs.oracle.com/javase/tutorial/extra/fullscreen/index.html</a>.</li>
<li>Jonathan S. Harbour, &quot;Beginning Java 5 Game Programming&quot;.</li>
</ul>

</div> 
<!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 1.7.2<br />
Last modified: April, 2012</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
