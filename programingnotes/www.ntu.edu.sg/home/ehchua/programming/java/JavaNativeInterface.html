<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Java Native Interface (JNI) - Java Programming Tutorial</title>

<!-- @@ start change in v1 -->
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Java Native Interface (JNI)</h2>
</div>

<div id="content-main">

<!-- @@ end change in v1 -->

<h3>Introduction</h3>

<p>At times, it is necessary to use native codes (C/C++) to overcome the memory management and performance constraints in Java. Java supports native codes via the Java Native Interface (JNI).</p>

<p>JNI is difficult, as it involves two languages and runtimes.</p>
<p>I shall assume that you are familiar with:</p>
<ol>
<li>Java.</li>
<li>C/C++ and the GCC Compiler (Read &quot;<a href="../cpp/gcc_make.html">GCC and Make</a>&quot;).</li>
<li>(For Windows) Gygwin or MinGW (Read &quot;<a href="../howto/Cygwin_HowTo.html">How to Setup Cygwin and MinGW</a>&quot;).</li>
<li>(For IDE) Eclipse C/C++ Development Tool (CDT) (Read &quot;<a href="../howto/EclipseCpp_HowTo.html">Eclipse CDT</a>&quot;).</li>
</ol>

<h3>Getting Started</h3>

<h4>JNI with C</h4>

<h5>Step 1: Write a Java Class that uses C Codes - <span class="font-code">HelloJNI.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre>
</td>
<td>
<pre>
public class HelloJNI {
   static {
      System.loadLibrary(&quot;hello&quot;); <span class="color-comment">// Load native library at runtime</span>
                                   <span class="color-comment">// hello.dll (Windows) or libhello.so (Unixes)</span>
   }
 
   <span class="color-comment">// Declare a native method sayHello() that receives nothing and returns void</span>
   private native void sayHello();
 
   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args) {
      new HelloJNI().sayHello();  <span class="color-comment">// invoke the native method</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The static initializer invokes <code>System.loadLibrary()</code> to load the native library &quot;<code>Hello</code>&quot; (which contains the native method <code>sayHello()</code>) during the class loading. It will be mapped to &quot;<code>hello.dll</code>&quot; in Windows; or <code>&quot;libhello.so</code>&quot; in Unixes. This library shall be included in Java's library path (kept in Java system variable <code>java.library.path</code>); otherwise, the program will throw a <code>UnsatisfiedLinkError</code>. You could include the library into Java Library's path via VM argument <code>-Djava.library.path=<em>path_to_lib</em></code>.</p>

<p>Next, we declare the method <code>sayHello()</code> as a native instance method, via keyword <code>native</code>, which denotes that this method is implemented in another language. A native method does not contain a body. The <code>sayHello()</code> is contained in the native library loaded.</p>
<p>The <code>main()</code> method allocate an instance of <code>HelloJNI</code> and invoke the native method <code>sayHello()</code>.</p>

<p>Compile the &quot;<code>HelloJNI.java</code>&quot; into &quot;<code>HelloJNI.class</code>&quot;.</p>
<pre class="color-command">
&gt; <strong>javac HelloJNI.java</strong></pre>

<h5>Step 2: Create the C/C++ Header file - <span class="font-code">HelloJNI.h</span></h5>

<p>Run <code>javah</code> utility <code></code>on the class file to create a header file for C/C++ programs:</p>

<pre class="color-command">
&gt; <strong>javah HelloJNI</strong></pre>

<p>The output is <code>HelloJNI.h</code> as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td>
<td>
<pre>
<span class="color-comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
#include &lt;jni.h&gt;
<span class="color-comment">/* Header for class HelloJNI */</span>
 
#ifndef _Included_HelloJNI
#define _Included_HelloJNI
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
<span class="color-comment">/*
 * Class:     HelloJNI
 * Method:    sayHello
 * Signature: ()V
 */</span>
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *, jobject);
 
#ifdef __cplusplus
}
#endif
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p>The header declares a C function <code>Java_HelloJNI_sayHello</code> as follows:</p>

<pre class="color-syntax">
JNIEXPORT void JNICALL <strong>Java_HelloJNI_sayHello</strong>(JNIEnv *, jobject);</pre>

<p>The naming convention for C function is <code>Java_{package_and_classname}_{function_name}(JNI arguments)</code>. The dot in package name shall be replaced by underscore.</p>

<p>The arguments:</p>
<ul>
<li><code>JNIEnv*</code>: reference to JNI environment, which lets you access all the JNI fucntions.</li>
<li><code>jobject</code>: reference to &quot;<code>this</code>&quot; Java object.</li>
</ul>

<p>We are not using these arguments in the hello-world example, but will be using them later. Ignore the macros <code>JNIEXPORT</code> and <code>JNICALL</code> for the time being.</p>
<p>The <code>extern &quot;C&quot; </code>is recognized by C++ compiler only. It notifies the C++ compiler that these functions are to be compiled using C's function naming protocol (instead of C++ naming protocol). C and C++ have different function naming protocols as C++ support function overloading and uses a name mangling scheme to differentiate the overloaded functions. Read &quot;<a href="../cpp/cp1_Basics.html#name_mangling">Name Mangling</a>&quot;.</p>

<h5>Step 3: C Implementation - <span class="font-code">HelloJNI.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;HelloJNI.h&quot;
 
<span class="color-comment">// Implementation of native method sayHello() of HelloJNI class</span>
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {
   printf(&quot;Hello World!\n&quot;);
   return;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Save the C program as &quot;<code>HelloJNI.c</code>&quot;.</p>
<p>The header &quot;<code>jni.h</code>&quot; is available under the &quot;<code>&lt;JAVA_HOME&gt;\include</code>&quot; and &quot;<code>&lt;JAVA_HOME&gt;\include\win32</code>&quot; directories, where <code>&lt;JAVA_HOME&gt;</code> is your JDK installed directory (e.g., &quot;<code>c:\program files\java\jdk1.7.0</code>&quot;).</p>

<p>The C function simply prints the message &quot;Hello world!&quot; to the console.</p>

<p>Compile the C program - this depends on the C compiler you used.</p>

<p><span class="underline">For MinGW GCC in Windows</span></p>

<pre class="color-command">
&gt; <strong>set JAVA_HOME=C:\Program Files\Java\jdk1.7.0_{<em>xx</em>}</strong>
      <span class="color-comment">// Define and Set environment variable JAVA_HOME to JDK installed directory
      // I recommend that you set JAVA_HOME permanently, via &quot;Control Panel&quot; ⇒ &quot;System&quot; ⇒ &quot;Environment Variables&quot;</span>
&gt; <strong>echo %JAVA_HOME%</strong>
      <span class="color-comment">// In Windows, you can refer a environment variable by adding % prefix and suffix </span>
&gt; <strong>gcc -Wl,--add-stdcall-alias -I&quot;%JAVA_HOME%\include&quot; -I&quot;%JAVA_HOME%\include\win32&quot; -shared -o hello.dll HelloJNI.c</strong>
      <span class="color-comment">// Compile HellJNI.c into shared library hello.dll</span></pre>

<p>The compiler options used are:</p>
<ul>
<li><code>-Wl</code>: The <code>-Wl</code> to pass linker option <code>--add-stdcall-alias</code> to prevent <code>UnsatisfiedLinkError</code> (symbols with a stdcall suffix (<code>@nn</code>) will be exported as-is and also with the suffix stripped). (Some people suggested to use <code>-Wl,--kill-at</code>.)</li>
<li><code>-I</code>: for specifying the header files directories. In this case &quot;<code>jni.h</code>&quot; (in &quot;<code>&lt;JAVA_HOME&gt;\include</code>&quot;) and &quot;<code>jni_md.h</code>&quot; (in &quot;<code>&lt;JAVA_HOME&gt;\include\win32&quot;</code>), where <code>&lt;JAVA_HOME&gt;</code> denotes the JDK installed directory. Enclosed the directory in double quotes if it contains spaces.</li>
<li><code>-shared</code>: to generate share library.</li>
<li><code>-o</code>: for setting the output filename &quot;<code>hello.dll</code>&quot;.</li>
</ul>

<p>You can also compile and link in two steps:</p>
<pre class="color-command">
<span class="color-comment">// Compile-only with -c flag. Output is HElloJNI.o</span>
&gt; <strong>gcc -c -I&quot;%JAVA_HOME%\include&quot; -I&quot;%JAVA_HOME%\include\win32&quot; HelloJNI.c</strong>
 
<span class="color-comment">// Link into shared library &quot;hello.dll&quot;</span>
&gt; <strong>gcc -Wl,--add-stdcall-alias -shared -o hello.dll HelloJNI.o</strong></pre>


<p>Try <code>nm</code> (which list all the symbols) on the shared library produced to look for the <code>sayHello()</code> function. Take note the GCC added prefix <code>_</code> and suffix <code>@8</code> (the number of bytes of parameters). Check for the function name <code>Java_HelloJNI_sayHello</code> with type <code>&quot;T&quot;</code> (defined).</p>
<pre class="color-command">
&gt; <strong>nm hello.dll | grep say</strong>
624011d8 T _Java_HelloJNI_sayHello@8</pre>

<p><span class="underline">For Cygwin GCC in Windows</span></p>

<p>You need to define the type <code>__int64</code> as &quot;<code>long long</code>&quot; via option <code>-D _int64=&quot;long long&quot;</code>.</p>

<p>For gcc-3, include option <code>-mno-cygwin</code> to build DLL files which are not dependent upon the Cygwin DLL.</p>

<pre class="color-command">
&gt; gcc-3 -D __int64=&quot;long long&quot; -mno-cygwin -Wl,--add-stdcall-alias 
  -I&quot;&lt;JAVA_HOME&gt;\include&quot; -I&quot;&lt;JAVA_HOME&gt;\include\win32&quot; -shared -o hello.dll HelloJNI.c</pre>

<p>For gcc-4: I still cannot find the correct compiler option (<code>-mno-cygwin</code> is not supported). The Java program hangs!</p>


<h5>Step 4: Run the Java Program</h5>

<pre class="color-command">
&gt; <strong>java HelloJNI</strong>
<span class="color-comment">or</span>
&gt; <strong>java -Djava.library.path=. HelloJNI</strong></pre>

<p>You may need to specify the library path of the &quot;<code>hello.dll</code>&quot; via VM option <code>-Djava.library.path=&lt;<em>path_to_lib</em>&gt;</code>, as shown above.</p>

<h4>JNI with C/C++ Mixture</h4>

<h5>Step 1: Write a Java Class that uses Native Codes - <span class="font-code">HelloJNICpp.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td>
<pre>
public class HelloJNICpp {
   static {
      System.loadLibrary(&quot;hello&quot;); <span class="color-comment">// hello.dll (Windows) or libhello.so (Unixes)</span>
   }
 
   <span class="color-comment">// Native method declaration</span>
   private native void sayHello();
 
   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args) {
      new HelloJNICpp().sayHello();  <span class="color-comment">// Invoke native method</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Compile the <code>HelloJNICpp.java</code> into <code>HelloJNICpp.class</code>.</p>
<pre class="color-command">
&gt; <strong>javac HelloJNICpp.java</strong></pre>

<h5>Step 2: Create the C/C++ Header file - <span class="font-code">HelloJNICpp.h</span></h5>

<pre class="color-command">
&gt; <strong>javah HelloJNICpp</strong>
</pre>

<p>The resultant header file &quot;<code>HelloJNICpp.h</code>&quot; declares the native function as:</p>

<pre class="color-syntax">
JNIEXPORT void JNICALL <strong>Java_HelloJNICpp_sayHello</strong>(JNIEnv *, jobject);</pre>

<h5>Step 3: C/C++ Implementation - <span class="font-code">HelloJNICppImpl.h</span>, <span class="font-code">HelloJNICppImpl.cpp</span>, and <span class="font-code">HelloJNICpp.c</span></h5>
<p>We shall implement the program in C++ (in &quot;<code>HelloJNICppImpl.h</code>&quot; and &quot;<code>HelloJNICppImpl.cpp</code>&quot;), but use a C program (&quot;<code>HelloJNICpp.c</code>&quot;) to interface with Java.</p>

<p>C++ Header - &quot;<code>HelloJNICppImpl.h</code>&quot;</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12</pre>
</td>
<td>
<pre>
#ifndef _HELLO_JNI_CPP_IMPL_H
#define _HELLO_JNI_CPP_IMPL_H
 
#ifdef __cplusplus
        extern &quot;C&quot; {
#endif
        void sayHello ();
#ifdef __cplusplus
        }
#endif
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p>C++ Implementation - &quot;<code>HelloJNICppImpl.cpp</code>&quot;</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9</pre>
</td>
<td>
<pre>
#include &quot;HelloJNICppImpl.h&quot;
#include  &lt;iostream&gt;
 
using namespace std;
 
void sayHello () {
    cout &lt;&lt; &quot;Hello World from C++!&quot; &lt;&lt; endl;
    return;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>C Program interfacing with Java - &quot;<code>HelloJNICpp.c</code>&quot;</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &quot;HelloJNICpp.h&quot;
#include &quot;HelloJNICppImpl.h&quot;
 
JNIEXPORT void JNICALL Java_HelloJNICpp_sayHello (JNIEnv *env, jobject thisObj) {
    sayHello();  <span class="color-comment">// invoke C++ function</span>
    return;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Compile the C/C++ programs into shared library (&quot;<code>hello.dll</code>&quot; for Windows).</p>

<p><span class="underline">Using MinGW GCC in Windows</span></p>

<pre class="color-command">
&gt; <strong>set JAVA_HOME=C:\Program Files\Java\jdk1.7.0_{<em>xx</em>}</strong>
&gt; <strong>g++ -Wl,--add-stdcall-alias -I&quot;%JAVA_HOME%\include&quot; -I&quot;%JAVA_HOME%\include\win32&quot; 
      -shared -o hello.dll HelloJNICpp.c HelloJNICppImpl.cpp</strong></pre>

<h5>Step 4: Run the Java Program</h5>

<pre class="color-command">
&gt; <strong>java HelloJNICpp</strong>
<span class="color-comment">or</span>
&gt; <strong>java -Djava.library.path=. HelloJNICpp</strong></pre>

<h4>JNI in Package</h4>
<p>For production, all Java classes shall be kept in proper packages, instead of the default no-name package.</p>

<h5>Step 1: JNI Program - <span class="font-code">myjni\HelloJNI.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td>
<pre>
<span class="color-new">package myjni;</span>
 
public class HelloJNI {
   static {
      System.loadLibrary(&quot;hello&quot;); <span class="color-comment">// hello.dll (Windows) or libhello.so (Unixes)</span>
   }
   <span class="color-comment">// A native method that receives nothing and returns void</span>
   private native void sayHello();
 
   public static void main(String[] args) {
      new HelloJNI().sayHello();  <span class="color-comment">// invoke the native method</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This JNI class is kept in package &quot;<code>myjni</code>&quot; - to be saved as &quot;<code>myjni\HelloJNI.java</code>&quot;.</p>

<p>Compile the JNI program:</p>
<pre class="color-command">
<span class="color-comment">// change directory to package base directory</span>
&gt; <strong>javac myjni\HelloJNI.java</strong></pre>

<h5>Step 2: Generate C/C++ Header</h5>

<p>If your JNI program is kept in a package, you need to issue fully-qualified name to generate the C/C++ header. You may need to use <code>-classpath</code> option to specify the classpath of the JNI program and <code>-d</code> option to specify the destination directory.</p>

<pre class="color-command">
&gt; <strong>javah --help</strong>
......
 
<span class="color-comment">// Change directory to package base directory</span>
&gt; <strong>javah -d include myini.HelloJNI</strong></pre>

<p>In this example, we decided to place the header file under a &quot;<code>include</code>&quot; sub-directory. The output is &quot;<code>include\myjni_HelloJNI.h</code>&quot;.</p>

<p>The header file declares a native function:</p>
<pre class="color-syntax">
JNIEXPORT void JNICALL <strong>Java_myjni_HelloJNI_sayHello</strong>(JNIEnv *, jobject);</pre>

<p>Take note of the native function naming convention: <code>Java_&lt;<em>fully-qualified-name</em>&gt;_methodName</code>, with dots replaced by underscores.</p>

<h5>Step 3: C Implementation - <span class="font-code">HelloJNI.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;include\myjni_HelloJNI.h&quot;
 
JNIEXPORT void JNICALL Java_myjni_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {
   printf(&quot;Hello World!\n&quot;);
   return;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Compile the C program:</p>

<pre class="color-command">
&gt; <strong>gcc -Wl,--add-stdcall-alias -I&lt;JAVA_HOME&gt;\include -I&lt;JAVA_HOME&gt;\include\win32 -shared -o hello.dll HelloJNI.c</strong></pre>

<p>You can now run the JNI program:</p>
<pre class="color-command">
&gt; <strong>java myjni.HelloJNI</strong>
</pre>

<h4>JNI in Eclipse</h4>

<p>Writing JNI under Eclipse is handy for development Android apps with NDK.</p>
<p>You need to install Eclipse and Eclipse CDT (C/C++ Development Tool) Plugin. Read &quot;<a href="../howto/EclipseCpp_HowTo.html">Eclipse for C/C++</a>&quot; on how to install CDT.</p>

<h5>Step 1: Create a Java Project</h5>

<p>Create a new Java project (says <code>HelloJNI</code>), and the following Java  class &quot;<code>HelloJNI.java</code>&quot;:</p>

<pre class="color-example">
public class HelloJNI {
   static {
      System.loadLibrary(&quot;hello&quot;); <span class="color-comment">// hello.dll (Windows) or libhello.so (Unixes)</span>
   }
 
   <span class="color-comment">// Declare native method</span>
   private native void sayHello();
 
   <span class="color-comment">// Test Driver</span>
   public static void main(String[] args) {
      new HelloJNI().sayHello();  <span class="color-comment">// invoke the native method</span>
   }
}</pre>

<h5>Step 2: Convert the Java Project to C/C++ Makefile Project</h5>

<p>Right-click on the &quot;<code>HelloJNI</code>&quot; Java project &rArr; New &rArr; Other... &rArr; Convert to a C/C++ Project (Adds C/C++ Nature) &rArr; Next.</p>
<p>The &quot;Convert to a C/C++ Project&quot; dialog appears. In &quot;Project type&quot;, select &quot;<span class="underline">Makefile Project</span>&quot; &rArr; In &quot;Toolchains&quot;, select &quot;MinGW GCC&quot; &rArr; Finish.</p>

<p>Now, you can run this project as a Java as well as C/C++ project.</p>

<h5>Step 3: Generate C/C++ Header File</h5>

<p>Create a directroy called &quot;<code>jni</code>&quot; under the project to keep all the C/C++ codes, by right-click on the project &rArr; New &rArr; Folder &rArr; In &quot;Folder name&quot;, enter &quot;<code>jni</code>&quot;.</p>


<p>Create a &quot;<code>makefile</code>&quot; under the &quot;<code>jni</code>&quot; directory, by right-click on the &quot;<code>jni</code>&quot; folder &rArr; new &rArr; File &rArr; In &quot;File name&quot;, enter &quot;<code>makefile</code>&quot; &rArr; Enter the following codes. Take note that you need to use tab (instead of spaces) for the indent.</p>

<pre class="color-example">
<span class="color-comment"># Define a variable for classpath</span>
CLASS_PATH = ../bin

<span class="color-comment"># Define a virtual path for .class in the bin directory</span>
vpath %.class $(CLASS_PATH)

<span class="color-comment"># $* matches the target filename without the extension</span>
HelloJNI.h : HelloJNI.class
	javah -classpath $(CLASS_PATH) $*</pre>

<p>This makefile create a target &quot;<code>HelloJNI.h</code>&quot;, which has a dependency &quot;<code>HelloJNI.class</code>&quot;, and invokes the <code>javah</code> utiltiy on <code>HelloJNI.class</code> (under <code>-classpath</code>) to build the target header file.</p>

<p>Right-click on the makefile &rArr; Make Targets &rArr; Create &rArr; In &quot;Target Name&quot;, enter &quot;<code>HelloJNI.h</code>&quot;.</p>

<p>Run the makefile for the target &quot;<code>HelloJNI.h</code>&quot;, by right-click on the makefile &rArr; Make Targets &rArr; Build &rArr; Select the target &quot;<code>HelloJNI.h</code>&quot; &rArr; Build. The header file &quot;<code>HelloJNI.h</code>&quot; shall be generated in the &quot;<code>jni</code>&quot; directory. Refresh (F5) if necessary. The outputs are:</p>
<pre class="output">
make HelloJNI.h 
javah -classpath ../bin HelloJNI</pre>

<p>Read &quot;<a href="../cpp/gcc_make.html">GCC and Make</a>&quot; for details about makefile.</p>

<p>Alternatively, you could also use the CMD shell to run the make file:</p>
<pre class="color-command">
<span class="color-comment">// change directory to the directory containing makefile</span>
&gt; <strong>make HelloJNI.h</strong></pre>

<p>You can even use the CMD shell to run the <code>javah</code>:</p>
<pre class="color-command">
&gt; <strong>javah -classpath ../bin HelloJNI</strong></pre>

<h5>Step 4: C Implementation - <span class="font-code">HelloJNI.c</span></h5>
<p>Create a C program called &quot;<code>HelloJNI.c</code>&quot;, by right-click on the &quot;<code>jni</code>&quot; folder &rArr; New &rArr; Source file &rArr; In &quot;Source file&quot;, enter &quot;<code>HelloJNI.c</code>&quot;. Enter the following codes:</p>

<pre class="color-example">
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;HelloJNI.h&quot;
 
JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) {
   printf(&quot;Hello World!\n&quot;);
   return;
}</pre>

<p>Modify the &quot;<code>makefile</code>&quot; as follows to generate the shared library &quot;<code>hello.dll</code>&quot;. (Again, use tab to indent the lines.)</p>

<pre class="color-example">
<span class="color-comment"># Define a variable for classpath</span>
CLASS_PATH = ../bin

<span class="color-comment"># Define a virtual path for .class in the bin directory</span>
vpath %.class $(CLASS_PATH)

<span class="color-new">all : hello.dll</span>

<span class="color-comment"># $@ matches the target, $&lt; matches the first dependancy</span>
<span class="color-new">hello.dll : HelloJNI.o
	gcc -Wl,--add-stdcall-alias -shared -o $@ $&lt;</span>

<span class="color-comment"># $@ matches the target, $&lt; matches the first dependancy</span>
<span class="color-new">HelloJNI.o : HelloJNI.c HelloJNI.h
	gcc -I&quot;D:\bin\jdk1.7\include&quot; -I&quot;D:\bin\jdk1.7\include\win32&quot; -c $&lt; -o $@</span>

<span class="color-comment"># $* matches the target filename without the extension</span>
HelloJNI.h : HelloJNI.class
	javah -classpath $(CLASS_PATH) $*

<span class="color-new">clean :
	rm HelloJNI.h HelloJNI.o hello.dll</span></pre>

<p>Right-click on the &quot;<code>makefile</code>&quot; &rArr; Make Targets &rArr; Create &rArr; In &quot;Target Name&quot;, enter &quot;<code><code>all</code></code>&quot;. Repeat to create a target &quot;<code>clean</code>&quot;.</p>

<p>Run the makefile for the target &quot;<code>all</code>&quot;, by right-click on the makefile &rArr; Make Targets &rArr; Build &rArr; Select the target &quot;<code>all</code>&quot; &rArr; Build. The outputs are:</p>
<pre class="output">
make all
javah -classpath ../bin HelloJNI
gcc -I&quot;D:\bin\jdk1.7\include&quot; -I&quot;D:\bin\jdk1.7\include\win32&quot; -c HelloJNI.c -o HelloJNI.o
gcc -Wl,--add-stdcall-alias -shared -o hello.dll HelloJNI.o</pre>

<p>The shared library &quot;<code>hello.dll</code>&quot; shall have been created in &quot;<code>jni</code>&quot; directory.</p>

<h5>Step 5: Run the Java JNI Program</h5>
<p>You can run the Java JNI program <code>HelloJNI</code>. However, you need to provide the library path to the &quot;<code>hello.dll</code>&quot;. This can be done via VM argument <code>-Djava.library.path</code>. Right-click on the project &rArr; Run As &rArr; Run Configurations &rArr; Select &quot;Java Application&quot; &rArr; In &quot;Main&quot; tab, enter the main class &quot;<code>HelloJNI</code>&quot; &rArr; In &quot;Arguments&quot;, &quot;VM Arguments&quot;, enter &quot;<code>-Djava.library.path=jni</code>&quot; &rArr; Run.</p>

<p>You shall see the output &quot;Hello World!&quot; displayed on the console.</p>

<h4>JNI in NetBeans</h4>
<p>[TODO]</p>

<h3>JNI Basics</h3>

<p>JNI defines the following JNI types in the native system that correspond to Java types:</p>

<ol>
<li>Java Primitives: <code>jint</code>, <code>jbyte</code>, <code>jshort</code>, <code>jlong</code>, <code>jfloat</code>, <code>jdouble</code>, <code>jchar</code>, <code>jboolean</code> for Java Primitive of <code>int</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code> and <code>boolean</code>, respectively.</li>

<li>Java Reference Types: <code>jobject</code> for <code>java.lang.Object</code>. It also defines the following <em>sub-type</em>s:
  <ol>
<li><code>jclass</code> for <code>java.lang.Class</code>.</li>
<li><code>jstring</code> for <code>java.lang.String</code>.</li>
<li><code>jthrowable</code> for <code>java.lang.Throwable</code>.</li>
<li><code>jarray</code> for Java array. Java array is a reference type with eight primitive array and one <code>Object</code> array. Hence, there are eight array of primitives <code>jintArray</code>, <code>jbyteArray</code>, <code>jshortArray</code>, <code>jlongArray</code>, <code>jfloatArray</code>, <code>jdoubleArray</code>, <code>jcharArray</code> and <code>jbooleanArray</code>; and one object array <code>jobjectArray</code>.</li>
</ol>
</li>
</ol>

<p>The native functions receives argument in the above JNI types and returns a value in the JNI type (such as <code>jstring</code>, <code>jintArray</code>). However, native functions operate on their own native types (such as C-string, C's <code>int[]</code>). Hence, there is a need to convert (or transform) between JNI types and the native types.</p>

<p>The native programs:</p>
<ol>
<li>Receive the arguments in JNI type (passed over by the Java program).</li>
<li>For reference JNI type, convert or copy the arguments to local native types, e.g., <code>jstring</code> to a C-string, <code>jintArray</code> to C's <code>int[]</code>, and so on. Primitive JNI types such as <code>jint</code> and <code>jdouble</code> do not need conversion and can be operated directly.</li>
<li>Perform its operations, in local native type.</li>
<li>Create the returned object in JNI type, and copy the result into the returned object.</li>
<li>Return.</li>
</ol>

<p>The most confusing and challenging task in JNI programming is the conversion (or transformation) between JNI <em>reference</em> types (such as <code>jstring</code>, <code>jobject</code>, <code>jintArray</code>, <code>jobjectArray</code>) and native types (<code>C-string</code>, <code>int[]</code>). The JNI Environment interface provides many functions to do the conversion.</p>

<p>JNI is a C interface, which is not object-oriented. It does not really pass the objects.</p>
<p>[C++ object-oriented interface?!]</p>

<h3>Passing Arguments and Result between Java &amp; Native Programs</h3>

<h4>Passing Primitives</h4>

<p>Passing Java primitives is straight forward. A <code>jxxx</code> type is defined in the native system, i.e,. <code>jint</code>, <code>jbyte</code>, <code>jshort</code>, <code>jlong</code>, <code>jfloat</code>, <code>jdouble</code>, <code>jchar</code> and <code>jboolean</code> for each of the Java's primitives <code>int</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code> and <code>boolean</code>, respectively.</p>

<h5>Java JNI Program: <span class="font-code">TestJNIPrimitive.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td>
<pre>
public class TestJNIPrimitive {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// Declare a native method average() that receives two ints and return a double containing the average</span>
   private native double average(int n1, int n2);
 
   <span class="color-comment">// Test Driver</span>
   public static void main(String args[]) {
      System.out.println(&quot;In Java, the average is &quot; + new TestJNIPrimitive().average(3, 2));
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This JNI program loads a shared library <code>myjni.dll</code> (Windows) or <code>libmyjni.so</code> (Unixes). It declares a <code>native</code> method <code>average()</code> that receives two <code>int</code>'s<code></code> and returns a <code>double</code> containing the average value of the two <code>int</code>'s. The <code>main()</code> method invoke the <code>average()</code>.</p>

<p>Compile the Java program into &quot;<code>TestJNIPrimitive.class</code>&quot; and generate the C/C++ header file &quot;<code>TestJNIPrimitive.h</code>&quot;:</p>
<pre class="color-command">
&gt; javac TestJNIPrimitive.java
&gt; javah TestJNIPrimitive       <span class="color-comment">// Output is TestJNIPrimitive.h</span></pre>

<h5>C Implementation - <span class="font-code">TestJNIPrimitive.c</span></h5>

<p>The header file <code>TestJNIPrimitive.h</code> contains a function declaration <code>Java_TestJNIPrimitive_average()</code> which takes a <code>JNIEnv*</code> (for accessing JNI environment interface), a <code>jobject</code> (for referencing this <code>object</code>), two <code>jint</code>'s (Java native method's two arguments) and returns a <code>jouble</code> (Java native method's return-type).</p>
<pre class="color-syntax">
JNIEXPORT jdouble JNICALL <strong>Java_TestJNIPrimitive_average</strong>(JNIEnv *, jobject, jint, jint);</pre>

<p>The JNI types <code>jint</code> and <code>jdouble</code> correspond to Java's type <code>int</code> and <code>double</code>, respectively.</p>

<p>The &quot;<code>jni.h</code>&quot; and &quot;<code>win32\jni_mh.h</code>&quot; (which is platform dependent) contains these <code>typedef</code> statements for the eight JNI primitives and an additional <code>jsize</code>. </p>
<p>It is interesting to note that <code>jint</code> is mapped to C's <code>long</code> (which is at least 32 bits), instead of of C's <code>int</code> (which could be 16 bits). Hence, it is important to use <code>jint</code> in the C program, instead of simply using <code>int</code>. Cygwin does not support <code>__int64</code>.</p>

<pre class="color-syntax">
<span class="color-comment">// In &quot;win\jni_mh.h&quot; - machine header which is machine dependent</span>
typedef long            jint;
typedef __int64         jlong;
typedef signed char     jbyte;
 
<span class="color-comment">// In &quot;jni.h&quot;</span>
typedef unsigned char   jboolean;
typedef unsigned short  jchar;
typedef short           jshort;
typedef float           jfloat;
typedef double          jdouble;
typedef jint            jsize;</pre>


<p>The implementation <code>TestJNIPrimitive.c</code> is as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIPrimitive.h&quot;
 
JNIEXPORT jdouble JNICALL Java_TestJNIPrimitive_average
          (JNIEnv *env, jobject thisObj, jint n1, jint n2) {
   jdouble result;
   printf(&quot;In C, the numbers are %d and %d\n&quot;, n1, n2);
   result = ((jdouble)n1 + n2) / 2.0;
   <span class="color-comment">// jint is mapped to int, jdouble is mapped to double</span>
   return result;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Compile the C program into shared library (<code>jni.dll</code>).</p>
<pre class="color-command">
<span class="color-comment">// MinGW GCC under Windows</span>
&gt; <strong>set JAVA_HOME={<em>jdk-installed-directory</em>}</strong>
&gt; <strong>gcc -Wl,--add-stdcall-alias -I&quot;%JAVA_HOME%\include&quot; -I&quot;%JAVA_HOME%\include\win32&quot; -shared -o myjni.dll TestJNIPrimitive.c</strong></pre>

<p>Now, run the Java Program:</p>
<pre class="color-command">
&gt; <strong>java TestJNIPrimitive</strong></pre>



<h5>C++ Implementation - <span class="font-code">TestJNIPrimitive.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;iostream&gt;
#include &quot;TestJNIPrimitive.h&quot;
using namespace std;
 
JNIEXPORT jdouble JNICALL Java_TestJNIPrimitive_average
          (JNIEnv *env, jobject obj, jint n1, jint n2) {
   jdouble result;
   cout &lt;&lt; &quot;In C++, the numbers are &quot; &lt;&lt; n1 &lt;&lt; &quot; and &quot; &lt;&lt; n2 &lt;&lt; endl;
   result = ((jdouble)n1 + n2) / 2.0;
   <span class="color-comment">// jint is mapped to int, jdouble is mapped to double</span>
   return result;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Use <code>g++</code> (instead of <code>gcc</code>) to compile the C++ program:</p>
<pre class="color-command">
<span class="color-comment">// MinGW GCC under Windows</span>
&gt; <strong>g++ -Wl,--add-stdcall-alias -I&quot;%JAVA_HOME%\include&quot; -I&quot;%JAVA_HOME%\include\win32&quot; -shared -o myjni.dll TestJNIPrimitive.cpp</strong></pre>

<h4>Passing Strings</h4>

<h5>Java JNI Program: <span class="font-code">TestJNIString.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12</pre>
</td>
<td>
<pre>
public class TestJNIString {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
   <span class="color-comment">// Native method that receives a Java String and return a Java String</span>
   private native String sayHello(String msg);
 
   public static void main(String args[]) {
      String result = new TestJNIString().sayHello(&quot;Hello from Java&quot;);
      System.out.println(&quot;In Java, the returned string is: &quot; + result);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This JNI program declares a <code>native</code> method <code>sayHello()</code> that receives a Java <code>String</code> and returns a Java <code>String</code>. The <code>main()</code> method invokes the <code>sayHello()</code>.</p>

<p>Compile the Java program and generate the C/C++ header file &quot;<code>TestJNIString.h</code>&quot;:</p>
<pre class="color-command">
&gt; <strong>javac TestJNIString.java</strong>
&gt; <strong>javah TestJNIString</strong></pre>

<h5>C Implementation - <span class="font-code">TestJNIString.c</span></h5>

<p>The header file <code>TestJNIString.h</code> contains this function declaration:</p>
<pre class="color-example">
JNIEXPORT jstring JNICALL <strong>Java_TestJNIString_sayHello</strong>(JNIEnv *, jobject, jstring);</pre>

<p>JNI defined a <code>jstring</code> type to represent the Java <code>String</code>. The last argument (of JNI type <code>jstring</code>) is the Java <code>String</code> passed into the C program. The return-type is also <code>jstring</code>.</p>

<p>Passing strings is more complicated than passing primitives, as Java's <code>String</code> is an object (reference type), while C-string is a NULL-terminated <code>char</code> array. You need to convert between Java <code>String</code> (represented as JNI <code>jstring</code>) and C-string (<code>char*</code>).</p>

<p>The JNI Environment (accessed via the argument <code>JNIEnv*</code>) provides functions for the conversion:</p>
<ol>
<li>To get a C-string (<code>char*</code>) from JNI string (<code>jstring</code>), invoke method <code>const char* GetStringUTFChars(JNIEnv*, jstring, jboolean*)</code>.</li>
<li>To get a JNI string (<code>jstring</code>) from a C-string (<code>char*</code>), invoke method <code>jstring NewStringUTF(JNIEnv*, char*)</code>.</li>
</ol>


<p>The C implementation <code>TestJNIString.c</code> is as follows.</p>
<ol>
<li>It receives the JNI string (<code>jstring</code>), convert into a C-string (<code>char*</code>), via <code>GetStringUTFChars()</code>.</li>
<li>It then performs its intended operations - displays the string received and prompts user for another string to be returned.</li>
<li>It converts the returned C-string (<code>char*</code>) to JNI string (<code>jstring</code>), via <code>NewStringUTF()</code>, and return the <code>jstring</code>.</li>
</ol>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIString.h&quot;
 
JNIEXPORT jstring JNICALL Java_TestJNIString_sayHello(JNIEnv *env, jobject thisObj, jstring inJNIStr) {
   <span class="color-comment">// Step 1: Convert the JNI String (jstring) into C-String (char*)</span>
   const char *inCStr = (*env)-&gt;GetStringUTFChars(env, inJNIStr, NULL);
   if (NULL == inCSt) return NULL;
 
   <span class="color-comment">// Step 2: Perform its intended operations</span>
   printf(&quot;In C, the received string is: %s\n&quot;, inCStr);
   (*env)-&gt;ReleaseStringUTFChars(env, inJNIStr, inCStr);  <span class="color-comment">// release resources</span>
 
   <span class="color-comment">// Prompt user for a C-string</span>
   char outCStr[128];
   printf(&quot;Enter a String: &quot;);
   scanf(&quot;%s&quot;, outCStr);    <span class="color-comment">// not more than 127 characters</span>
 
   <span class="color-comment">// Step 3: Convert the C-string (char*) into JNI String (jstring) and return</span>
   return (*env)-&gt;NewStringUTF(env, outCStr);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Compile the C program into shared library.</p>
<pre class="color-command">
<span class="color-comment">// MinGW GCC under Windows</span>
&gt; <strong>gcc -Wl,--add-stdcall-alias -I&quot;&lt;JAVA_HOME&gt;\include&quot; -I&quot;&lt;JAVA_HOME&gt;\include\win32&quot; -shared -o myjni.dll TestJNIString.c</strong></pre>

<p>Now, run the Java Program:</p>
<pre class="color-command">
&gt; <strong>java TestJNIString</strong>
In C, the received string is: Hello from Java
Enter a String: test
In Java, the returned string is: test</pre>

<h5>JNI Native String Functions</h5>

<p>JNI supports conversion for Unicode (16-bit characters) and UTF-8 (encoded in 1-3 bytes)  strings. UTF-8 strings act like null-terminated C-strings (<code>char</code> array), which should be used in C/C++ programs.</p>

<p>The JNI string (<code>jstring</code>) functions are:</p>

<pre class="color-syntax">
<span class="color-comment">// UTF-8 String (encoded to 1-3 byte, backward compatible with 7-bit ASCII)
// Can be mapped to null-terminated char-array C-string</span>
const char * <strong>GetStringUTFChars</strong>(JNIEnv *env, jstring string, jboolean *isCopy);
   <span class="color-comment">// Returns a pointer to an array of bytes representing the string in modified UTF-8 encoding.</span>
void <strong>ReleaseStringUTFChars</strong>(JNIEnv *env, jstring string, const char *utf);
   <span class="color-comment">// Informs the VM that the native code no longer needs access to utf.</span>
jstring <strong>NewStringUTF</strong>(JNIEnv *env, const char *bytes);
   <span class="color-comment">// Constructs a new java.lang.String object from an array of characters in modified UTF-8 encoding.</span>
jsize <strong>GetStringUTFLength</strong>(JNIEnv *env, jstring string);
   <span class="color-comment">// Returns the length in bytes of the modified UTF-8 representation of a string.</span>
void <strong>GetStringUTFRegion</strong>(JNIEnv *env, jstring str, jsize start, jsize length, char *buf);
   <span class="color-comment">// Translates len number of Unicode characters beginning at offset start into modified UTF-8 encoding 
   // and place the result in the given buffer buf.</span>
  
<span class="color-comment">// Unicode Strings (16-bit character)</span>
const jchar * <strong>GetStringChars</strong>(JNIEnv *env, jstring string, jboolean *isCopy);
   <span class="color-comment">// Returns a pointer to the array of Unicode characters</span>
void <strong>ReleaseStringChars</strong>(JNIEnv *env, jstring string, const jchar *chars);
   <span class="color-comment">// Informs the VM that the native code no longer needs access to chars.</span>
jstring <strong>NewString</strong>(JNIEnv *env, const jchar *unicodeChars, jsize length);
   <span class="color-comment">// Constructs a new java.lang.String object from an array of Unicode characters.</span>
jsize <strong>GetStringLength</strong>(JNIEnv *env, jstring string);
   <span class="color-comment">// Returns the length (the count of Unicode characters) of a Java string.</span>
void <strong>GetStringRegion</strong>(JNIEnv *env, jstring str, jsize start, jsize length, jchar *buf);
   <span class="color-comment">// Copies len number of Unicode characters beginning at offset start to the given buffer buf</span></pre>

<h5>UTF-8 strings or C-strings</h5>

<p>The <code>GetStringUTFChars()</code> function can be used to create a new C-string (<code>char*</code>) from the given Java's <code>jstring</code>. The function returns <code>NULL</code> if the memory cannot be allocated. It is always a good practice to check against <code>NULL</code>.</p>
<p>The 3rd parameter <code>isCopy</code> (of <code>jboolean*</code>), which is an &quot;in-out&quot; parameter, will be set to <code>JNI_TRUE</code> if the returned string is a copy of the original <code>java.lang.String</code> instance. It will be set to <code>JNI_FALSE</code> if the returned string is a direct pointer to the original <code>String</code> instance - in this case, the native code shall not modify the contents of the returned string. The JNI runtime will try to return a direct pointer, if possible; otherwise, it returns a copy. Nonetheless, we seldom interested in modifying the underlying string, and often pass a <code>NULL</code> pointer.</p>
<p>Always invoke <code>ReleaseStringUTFChars()</code> whenever you do not need the returned string of <code>GetStringUTFChars()</code> to release the memory and the reference so that it can be garbage-collected.</p>
<p>The <code>NewStringUTF()</code> function create a new JNI string (<code>jstring</code>), with the given C-string.</p>
<p>JDK 1.2 introduces the <code>GetStringUTFRegion()</code>, which copies the <code>jstring</code> (or a portion from <code>start</code> of <code>length</code>) into the &quot;<em>pre-allocated&quot;</em> C's <code>char</code> array. They can be used in place of <code>GetStringUTFChars()</code>. The <code>isCopy</code> is not needed as the C's array is <em>pre-allocated</em>.</p>
<p>JDK 1.2 also introduces the <code>Get/ReleaseStringCritical()</code> functions. Similar to <code>GetStringUTFChars()</code>, it returns a direct pointer if possible; otherwise, it returns a copy. The native method shall not block (for IO or others) between a pair a <code>GetStringCritical()</code> and <code>ReleaseStringCritical()</code> call.</p>
<p>For detailed description, always refer to &quot;Java Native Interface Specification&quot; @ <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html</a>.</p>

<h5>Unicode String</h5>
<p>Instead of <code>char*</code>, it uses a <code>jchar*</code> to store the Unicode characters.</p>

<h5>C++ Implementation - <span class="font-code">TestJNIString.cpp</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &quot;TestJNIString.h&quot;
using namespace std;
 
JNIEXPORT jstring JNICALL Java_TestJNIString_sayHello(JNIEnv *env, jobject thisObj, jstring inJNIStr) {
   <span class="color-comment">// Step 1: Convert the JNI String (jstring) into C-String (char*)</span>
   const char *inCStr = env-&gt;GetStringUTFChars(inJNIStr, NULL);
   if (NULL == inCStr) return NULL;
 
   <span class="color-comment">// Step 2: Perform its intended operations</span>
   cout &lt;&lt; &quot;In C++, the received string is: &quot; &lt;&lt; inCStr &lt;&lt; endl;
   env-&gt;ReleaseStringUTFChars(inJNIStr, inCStr);  <span class="color-comment">// release resources</span>
 
   <span class="color-comment">// Prompt user for a C++ string</span>
   string outCppStr;
   cout &lt;&lt; &quot;Enter a String: &quot;;
   cin &gt;&gt; outCppStr;
 
   <span class="color-comment">// Step 3: Convert the C++ string to C-string, then to JNI String (jstring) and return</span>
   return env-&gt;NewStringUTF(outCppStr.c_str());
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Use <code>g++</code> to compile the C++ program:</p>
<pre class="color-command">
<span class="color-comment">// MinGW GCC under Windows</span>
&gt; <strong>g++ -Wl,--add-stdcall-alias -I&quot;&lt;JAVA_HOME&gt;\include&quot; -I&quot;&lt;JAVA_HOME&gt;\include\win32&quot; -shared -o myjni.dll TestJNIString.cpp</strong></pre>

<p>Take note that C++ native string functions have different syntax from C. In C++, we could us &quot;<code>env-&gt;</code>&quot;, instead of &quot;<code>(env*)-&gt;</code>&quot;. Furthermore, there is no need for the <code>JNIEnv*</code> argument in the C++ functions.</p>

<p>Also take note that C++ support a <code>string</code> class (under the header <code>&lt;string&gt;</code> which is more user-friendly, as well as the legacy C-string (char array).</p>

<p>[TODO] Is C++ <code>string</code> class supported directly?</p>

<h4>Passing Array of Primitives</h4>

<h5>JNI Program - <span class="font-code">TestJNIPrimitiveArray.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
public class TestJNIPrimitiveArray {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// Declare a native method sumAndAverage() that receives an int[] and</span>
   <span class="color-comment">//  return a double[2] array with [0] as sum and [1] as average</span>
   private native double[] sumAndAverage(int[] numbers);
 
   <span class="color-comment">// Test Driver</span>
   public static void main(String args[]) {
      int[] numbers = {22, 33, 33};
      double[] results = new TestJNIPrimitiveArray().sumAndAverage(numbers);
      System.out.println(&quot;In Java, the sum is &quot; + results[0]);
      System.out.println(&quot;In Java, the average is &quot; + results[1]);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>C Implementation - <span class="font-code">TestJNIPrimitiveArray.c</span></h5>

<p>The header &quot;<code>TestJNIPrimitiveArray.h</code>&quot; contains the following function declaration:</p>
<pre class="color-syntax">
JNIEXPORT jdoubleArray JNICALL Java_TestJNIPrimitiveArray_average (JNIEnv *, jobject, jintArray);</pre>

<p>In Java, array is a <em>reference type</em>, similar to a class. There are 9 types of Java arrays, one each of the eight primitives and an array of <code>java.lang.Object</code>. JNI defines a type for each of the eight Java primitive arrays, i.e, <code>jintArray</code>, <code>jbyteArray</code>, <code>jshortArray</code>, <code>jlongArray</code>, <code>jfloatArray</code>, <code>jdoubleArray</code>, <code>jcharArray</code>, <code>jbooleanArray</code> for Java's primitive array of <code>int</code>, <code>byte</code>, <code>short</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code> and <code>boolean</code>, respectively. It also define a <code>jobjectArray</code> for Java's array of <code>Object</code> (to be discussed later).</p>

<p>Again, you need to convert between JNI array and native array, e.g., between <code>jintArray</code> and C's <code>jint[]</code>, or <code>jdoubleArray</code> and C's <code>jdouble[]</code>. The JNI Environment interface provides a set of functions for the conversion:</p>

<ol>
<li>To get a C native <code>jint[]</code> from a JNI <code>jintArray</code>, invoke <code>jint* GetIntArrayElements(JNIEnv *env, jintArray a, jboolean *iscopy)</code>.</li>
<li>To get a JNI <code>jintArray</code> from C native <code>jint[]</code>, first, invoke <code>jintArray NewIntArray(JNIEnv *env, jsize len)</code> to allocate, then use <code>void SetIntArrayRegion(JNIEnv *env, jintArray a, jsize start, jsize len, const jint *buf)</code> to copy from the <code>jint[]</code> to <code>jintArray</code>.</li>
</ol>

<p>There are 8 sets of the above functions, one for each of the eight Java primitives.</p>

<p>The native program is required to:</p>
<ol>
<li>Receive the incoming JNI array (e.g., <code>jintArray</code>), convert to C's native array (e.g., <code>jint[]</code>).</li>
<li>Perform its intended operations.</li>
<li>Convert the return C's native array (e.g., <code>jdouble[]</code>) to JNI array (e.g., <code>jdoubleArray</code>), and return the JNI array.</li>
</ol>



<p>The C implementation &quot;<code>TestJNIPrimitiveArray.c</code>&quot; is:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIPrimitiveArray.h&quot;
 
JNIEXPORT jdoubleArray JNICALL Java_TestJNIPrimitiveArray_sumAndAverage
          (JNIEnv *env, jobject thisObj, jintArray inJNIArray) {
   <span class="color-comment">// Step 1: Convert the incoming JNI jintarray to C's jint[]</span>
   jint *inCArray = (*env)-&gt;GetIntArrayElements(env, inJNIArray, NULL);
   if (NULL == inCArray) return NULL;
   jsize length = (*env)-&gt;GetArrayLength(env, inJNIArray);
 
   <span class="color-comment">// Step 2: Perform its intended operations</span>
   jint sum = 0;
   int i;
   for (i = 0; i &lt; length; i++) {
      sum += inCArray[i];
   }
   jdouble average = (jdouble)sum / length;
   (*env)-&gt;ReleaseIntArrayElements(env, inJNIArray, inCArray, 0); <span class="color-comment">// release resources</span>
 
   jdouble outCArray[] = {sum, average};
 
   <span class="color-comment">// Step 3: Convert the C's Native jdouble[] to JNI jdoublearray, and return</span>
   jdoubleArray outJNIArray = (*env)-&gt;NewDoubleArray(env, 2);  <span class="color-comment">// allocate</span>
   if (NULL == outJNIArray) return NULL;
   (*env)-&gt;SetDoubleArrayRegion(env, outJNIArray, 0 , 2, outCArray);  <span class="color-comment">// copy</span>
   return outJNIArray;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>JNI Primitive Array Functions</h5>

<p>The JNI primitive array (<code>jintArray</code>, <code>jbyteArray</code>, <code>jshortArray</code>, <code>jlongArray</code>, <code>jfloatArray</code>, <code>jdoubleArray</code>, <code>jcharArray</code> and  <code>jbooleanArray</code>) functions are:</p>

<pre class="color-syntax">
<span class="color-comment">// <em>ArrayType</em>: jintArray, jbyteArray, jshortArray, jlongArray, jfloatArray, jdoubleArray, jcharArray, jbooleanArray
// <em>PrimitiveType</em>: int, byte, short, long, float, double, char, boolean
// <em>NativeType</em>: jint, jbyte, jshort, jlong, jfloat, jdouble, jchar, jboolean</span>
<em>NativeType</em> * <strong>Get&lt;<em>PrimitiveType</em>&gt;ArrayElements</strong>(JNIEnv *env, <em>ArrayType</em> array, jboolean *isCopy);
void <strong>Release&lt;<em>PrimitiveType</em>&gt;ArrayElements</strong>(JNIEnv *env, <em>ArrayType</em> array, <em>NativeType</em> *elems, jint mode);
void <strong>Get&lt;<em>PrimitiveType</em>&gt;ArrayRegion</strong>(JNIEnv *env, <em>ArrayType</em> array, jsize start, jsize length, <em>NativeType</em> *buffer);
void <strong>Set&lt;<em>PrimitiveType</em>&gt;ArrayRegion</strong>(JNIEnv *env, <em>ArrayType</em> array, jsize start, jsize length, const <em>NativeType</em> *buffer);
<em>ArrayType</em> <strong>New&lt;<em>PrimitiveType</em>&gt;Array</strong>(JNIEnv *env, jsize length);
void * <strong>GetPrimitiveArrayCritical</strong>(JNIEnv *env, jarray array, jboolean *isCopy);
void <strong>ReleasePrimitiveArrayCritical</strong>(JNIEnv *env, jarray array, void *carray, jint mode);</pre>

<p>The <code>GET|Release&lt;<em>PrimitiveType</em>&gt;ArrayElements()</code> can be used to create a new C's native array <code>jxxx[]</code> from the given Java <code>jxxxArray</code>. <code>GET|Set&lt;<em>PrimitiveType</em>&gt;ArrayRegion()</code> can be used to copy a <code>jxxxArray</code> (or a portion from <code>start</code> of <code>length</code>) <em>to and from</em> a <em>pre-allocated</em> C native array <code>jxxx[]</code>.</p>
<p>The <code>New&lt;PrimitiveType&gt;Array()</code> can be used to allocate a new <code>jxxxArray</code> of a given size. You can then use the <code>Set&lt;<em>PrimitiveType</em>&gt;ArrayRegion()</code> function to fill its contents from a native array <code>jxxx[]</code>.</p>
<p>The <code>Get|ReleasePrimitiveArrayCritical()</code> functions does not allow blocking calls in between the get and release.</p>

<h3>Accessing Object's Variables and Calling Back Methods</h3>

<h4>Accessing Object's Instance Variables</h4>

<h5>JNI Program - <span class="font-code">TestJNIInstanceVariable.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
public class TestJNIInstanceVariable {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// Instance variables</span>
   private int number = 88;
   private String message = &quot;Hello from Java&quot;;
 
   <span class="color-comment">// Declare a native method that modifies the instance variables</span>
   private native void modifyInstanceVariable();
 
   <span class="color-comment">// Test Driver</span>   
   public static void main(String args[]) {
      TestJNIInstanceVariable test = new TestJNIInstanceVariable();
      test.modifyInstanceVariable();
      System.out.println(&quot;In Java, int is &quot; + test.number);
      System.out.println(&quot;In Java, String is &quot; + test.message);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The class contains two <code>private</code> instance variables: a primitive <code>int</code> called <code>number</code> and a <code>String</code> called <code>message</code>. It also declares a native method, which could modify the contents of the instance variables.</p>

<h5>C Implementation - <span class="font-code">TestJNIInstanceVariable.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIInstanceVariable.h&quot;
 
JNIEXPORT void JNICALL Java_TestJNIInstanceVariable_modifyInstanceVariable
          (JNIEnv *env, jobject thisObj) {
   <span class="color-comment">// Get a reference to this object's class</span>
   jclass thisClass = (*env)-&gt;GetObjectClass(env, thisObj);
 
   <span class="color-comment">// int</span>
   <span class="color-comment">// Get the Field ID of the instance variables &quot;number&quot;</span>
   jfieldID fidNumber = (*env)-&gt;GetFieldID(env, thisClass, &quot;number&quot;, &quot;I&quot;);
   if (NULL == fidNumber) return;
 
   <span class="color-comment">// Get the int given the Field ID</span>
   jint number = (*env)-&gt;GetIntField(env, thisObj, fidNumber);
   printf(&quot;In C, the int is %d\n&quot;, number);
 
   <span class="color-comment">// Change the variable</span>
   number = 99;
   (*env)-&gt;SetIntField(env, thisObj, fidNumber, number);
 
   <span class="color-comment">// Get the Field ID of the instance variables &quot;message&quot;</span>
   jfieldID fidMessage = (*env)-&gt;GetFieldID(env, thisClass, &quot;message&quot;, &quot;Ljava/lang/String;&quot;);
   if (NULL == fidMessage) return;
 
   <span class="color-comment">// String</span>
   <span class="color-comment">// Get the object given the Field ID</span>
   jstring message = (*env)-&gt;GetObjectField(env, thisObj, fidMessage);
 
   <span class="color-comment">// Create a C-string with the JNI String</span>
   const char *cStr = (*env)-&gt;GetStringUTFChars(env, message, NULL);
   if (NULL == cStr) return;
 
   printf(&quot;In C, the string is %s\n&quot;, cStr);
   (*env)-&gt;ReleaseStringUTFChars(env, message, cStr);
 
   <span class="color-comment">// Create a new C-string and assign to the JNI string</span>
   message = (*env)-&gt;NewStringUTF(env, &quot;Hello from C&quot;);
   if (NULL == message) return;
 
   <span class="color-comment">// modify the instance variables</span>
   (*env)-&gt;SetObjectField(env, thisObj, fidMessage, message);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>To access the instance variable of an object:</p>
<ol>
<li>Get a reference to this object's class via <code>GetObjectClass()</code>.</li>
<li>Get the Field ID of the instance variable to be accessed via <code>GetFieldID()</code> from the class reference. You need to provide the variable name and its field descriptor (or signature). For a Java class, the field descriptor is in the form of &quot;<code>L&lt;fully-qualified-name&gt;;</code>&quot;, with dot replaced by forward slash (<code>/</code>), e.g.,, the class descriptor for <code>String</code> is &quot;<code>Ljava/lang/String;</code>&quot;. For primitives, use <code>&quot;I&quot;</code> for <code>int</code>, <code>&quot;B&quot;</code> for <code>byte</code>, <code>&quot;S&quot;</code> for <code>short</code>, <code>&quot;J&quot;</code> for <code>long</code>, <code>&quot;F&quot;</code> for <code>float</code>, <code>&quot;D&quot;</code> for <code>double</code>, <code>&quot;C&quot;</code> for <code>char</code>, and <code>&quot;Z&quot;</code> for <code>boolean</code>. For arrays, include a prefix <code>&quot;[&quot;</code>, e.g., &quot;<code>[Ljava/lang/Object;</code>&quot; for an array of <code>Object</code>; <code>&quot;[I&quot;</code> for an array of <code>int</code>.</li>
<li>Based on the Field ID, retrieve the instance variable via <code>GetObjectField()</code> or <code>Get&lt;<em>primitive-type</em>&gt;Field()</code> function.</li>
<li>To update the instance variable, use the <code>SetObjectField()</code> or <code>Set&lt;<em>primitive-type</em>&gt;Field()</code> function, providing the Field ID.</li>
</ol>

<p>The JNI functions for accessing instance variable are:</p>
<pre class="color-syntax">
jclass <strong>GetObjectClass</strong>(JNIEnv *env, jobject obj);
   <span class="color-comment">// Returns the class of an object.</span>
   
jfieldID <strong>GetFieldID</strong>(JNIEnv *env, jclass cls, const char *name, const char *sig);
  <span class="color-comment">// Returns the field ID for an instance variable of a class.</span>
 
NativeType <strong>Get&lt;<em>type</em>&gt;Field</strong>(JNIEnv *env, jobject obj, jfieldID fieldID);
void <strong>Set&lt;<em>type</em>&gt;Field</strong>(JNIEnv *env, jobject obj, jfieldID fieldID, NativeType value);
  <span class="color-comment">// Get/Set the value of an instance variable of an object
  // &lt;<em>type</em>&gt; includes each of the eight primitive types plus Object.</span></pre>

<h4>Accessing Class' Static Variables</h4>

<p>Accessing static variables is similar to accessing instance variable, except that you use functions such as <code>GetStaticFieldID()</code>, <code>Get|SetStaticObjectField()</code>, <code>Get|SetStatic&lt;<em>Primitive-type</em>&gt;Field()</code>.</p>

<h5>JNI Program - <span class="font-code">TestJNIStaticVariable.java</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre>
</td>
<td>
<pre>
public class TestJNIStaticVariable {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// nyjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// Static variables</span>
   private static double number = 55.66;
 
   <span class="color-comment">// Declare a native method that modifies the static variable</span>
   private native void modifyStaticVariable();
 
   <span class="color-comment">// Test Driver</span>
   public static void main(String args[]) {
      TestJNIStaticVariable test = new TestJNIStaticVariable();
      test.modifyStaticVariable();
      System.out.println(&quot;In Java, the double is &quot; + number);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>C Implementation - <span class="font-code">TestJNIStaticVariable.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIStaticVariable.h&quot;
 
JNIEXPORT void JNICALL Java_TestJNIStaticVariable_modifyStaticVariable
          (JNIEnv *env, jobject thisObj) {
   <span class="color-comment">// Get a reference to this object's class</span>
   jclass cls = (*env)-&gt;GetObjectClass(env, thisObj);
 
   <span class="color-comment">// Read the int static variable and modify its value</span>
   jfieldID fidNumber = (*env)-&gt;GetStaticFieldID(env, cls, &quot;number&quot;, &quot;D&quot;);
   if (NULL == fidNumber) return;
   jdouble number = (*env)-&gt;GetStaticDoubleField(env, cls, fidNumber);
   printf(&quot;In C, the double is %f\n&quot;, number);
   number = 77.88;
   (*env)-&gt;SetStaticDoubleField(env, cls, fidNumber, number);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The JNI functions for accessing static variable are:</p>

<pre class="color-syntax">
jfieldID <strong>GetStaticFieldID</strong>(JNIEnv *env, jclass cls, const char *name, const char *sig);
  <span class="color-comment">// Returns the field ID for a static variable of a class.</span>
 
NativeType <strong>GetStatic&lt;<em>type</em>&gt;Field</strong>(JNIEnv *env, jclass clazz, jfieldID fieldID);
void <strong>SetStatic&lt;<em>type</em>&gt;Field</strong>(JNIEnv *env, jclass clazz, jfieldID fieldID, NativeType value);
  <span class="color-comment">// Get/Set the value of a static variable of a class.
  // &lt;<em>type</em>&gt; includes each of the eight primitive types plus Object.</span></pre>

<h4>Callback Instance Methods and Static Methods</h4>

<p>You can callback an instance and static methods from the native code.</p>

<h5>JNI Program - <span class="font-code">TestJNICallBackMethod.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre>
</td>
<td>
<pre>
public class TestJNICallBackMethod {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// Declare a native method that calls back the Java methods below</span>
   private native void nativeMethod();
 
   <span class="color-comment">// To be called back by the native code</span>
   private void callback() {
      System.out.println(&quot;In Java&quot;);
   }
 
   private void callback(String message) {
      System.out.println(&quot;In Java with &quot; + message);
   }
 
   private double callbackAverage(int n1, int n2) {
      return ((double)n1 + n2) / 2.0;
   }
 
   <span class="color-comment">// Static method to be called back</span>
   private static String callbackStatic() {
      return &quot;From static Java method&quot;;
   }

   <span class="color-comment">// Test Driver</span> 
   public static void main(String args[]) {
      new TestJNICallBackMethod().nativeMethod();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This class declares a <code>native</code> method called <code>nativeMethod()</code>, and invoke this <code>nativeMethod()</code>. The <code>nativeMethod()</code>, in turn, calls back the various instance and static methods defined in this class.</p>

<h5>C Implementation - <span class="font-code">TestJNICallBackMethod.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNICallBackMethod.h&quot;
 
JNIEXPORT void JNICALL Java_TestJNICallBackMethod_nativeMethod
          (JNIEnv *env, jobject thisObj) {
 
   <span class="color-comment">// Get a class reference for this object</span>
   jclass thisClass = (*env)-&gt;GetObjectClass(env, thisObj);
 
   <span class="color-comment">// Get the Method ID for method &quot;callback&quot;, which takes no arg and return void</span>
   jmethodID midCallBack = (*env)-&gt;GetMethodID(env, thisClass, &quot;callback&quot;, &quot;()V&quot;);
   if (NULL == midCallBack) return;
   printf(&quot;In C, call back Java's callback()\n&quot;);
   <span class="color-comment">// Call back the method (which returns void), baed on the Method ID</span>
   (*env)-&gt;CallVoidMethod(env, thisObj, midCallBack);
 
   jmethodID midCallBackStr = (*env)-&gt;GetMethodID(env, thisClass,
                               &quot;callback&quot;, &quot;(Ljava/lang/String;)V&quot;);
   if (NULL == midCallBackStr) return;
   printf(&quot;In C, call back Java's called(String)\n&quot;);
   jstring message = (*env)-&gt;NewStringUTF(env, &quot;Hello from C&quot;);
   (*env)-&gt;CallVoidMethod(env, thisObj, midCallBackStr, message);
 
   jmethodID midCallBackAverage = (*env)-&gt;GetMethodID(env, thisClass,
                                  &quot;callbackAverage&quot;, &quot;(II)D&quot;);
   if (NULL == midCallBackAverage) return;
   jdouble average = (*env)-&gt;CallDoubleMethod(env, thisObj, midCallBackAverage, 2, 3);
   printf(&quot;In C, the average is %f\n&quot;, average);
 
   jmethodID midCallBackStatic = (*env)-&gt;GetStaticMethodID(env, thisClass,
                                 &quot;callbackStatic&quot;, &quot;()Ljava/lang/String;&quot;);
   if (NULL == midCallBackStatic) return;
   jstring resultJNIStr = (*env)-&gt;CallStaticObjectMethod(env, thisClass, midCallBackStatic);
   const char *resultCStr = (*env)-&gt;GetStringUTFChars(env, resultJNIStr, NULL);
   if (NULL == resultCStr) return;
   printf(&quot;In C, the returned string is %s\n&quot;, resultCStr);
   (*env)-&gt;ReleaseStringUTFChars(env, resultJNIStr, resultCStr);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>To call back an instance method from the native code:</p>

<ol>
<li>Get a reference to this object's class via <code>GetObjectClass()</code>.</li>
<li>From the class reference, get the Method ID via <code>GetMethodID()</code>. You need to provide the method name and the signature. The signature is in the form &quot;<code>(<em>parameters</em>)<em>return-type</em></code>&quot;. You can list the method signature for a Java program via <code>javap</code> utility (Class File Disassembler) with <code>-s</code> (print signature) and <code>-p</code> (show private members):
  <pre class="color-command">
&gt; <strong>javap --help</strong>
&gt; <strong>javap -s -p TestJNICallBackMethod</strong>
  .......
  private void callback();
    Signature: ()V
 
  private void callback(java.lang.String);
    Signature: (Ljava/lang/String;)V
 
  private double callbackAverage(int, int);
    Signature: (II)D
 
  private static java.lang.String callbackStatic();
    Signature: ()Ljava/lang/String;
  .......</pre></li>

<li>Based on the Method ID, you could invoke <code>Call&lt;Primitive-type&gt;Method()</code> or <code>CallVoidMethod()</code> or <code>CallObjectMethod()</code>, where the return-type is <code>&lt;<em>Primitive-type</em>&gt;</code>, void and <code>Object</code>, respectively. Append the argument, if any, before the argument list. For non-<code>void</code> return-type, the method returns a value.</li>
</ol>

<p>To callback a <code>static</code> method, use <code>GetMethodID(), </code><code>CallStatic&lt;Primitive-type&gt;Method()</code>, <code>CallStaticVoidMethod()</code> or <code>CallStaticObjectMethod()</code>.</p>

<p>The JNI functions for calling back instance method and static method are:</p>

<pre class="color-syntax">
jmethodID <strong>GetMethodID</strong>(JNIEnv *env, jclass cls, const char *name, const char *sig);
   <span class="color-comment">// Returns the method ID for an instance method of a class or interface.</span>
   
NativeType <strong>Call&lt;<em>type</em>&gt;Method</strong>(JNIEnv *env, jobject obj, jmethodID methodID, ...);
NativeType <strong>Call&lt;<em>type</em>&gt;MethodA</strong>(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);
NativeType <strong>Call&lt;<em>type</em>&gt;MethodV</strong>(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
   <span class="color-comment">// Invoke an instance method of the object.
   // The &lt;type&gt; includes each of the eight primitive and Object.</span>
   
jmethodID <strong>GetStaticMethodID</strong>(JNIEnv *env, jclass cls, const char *name, const char *sig);
   <span class="color-comment">// Returns the method ID for an instance method of a class or interface.</span>
   
NativeType <strong>CallStatic&lt;<em>type</em>&gt;Method</strong>(JNIEnv *env, jclass clazz, jmethodID methodID, ...);
NativeType <strong>CallStatic&lt;<em>type</em>&gt;MethodA</strong>(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);
NativeType <strong>CallStatic&lt;<em>type</em>&gt;MethodV</strong>(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
   <span class="color-comment">// Invoke an instance method of the object.
   // The &lt;type&gt; includes each of the eight primitive and Object.</span></pre>

<h4>Callback Overridden Superclass' Instance Method</h4>


<p>JNI provides a set of <code>CallNonvirtual&lt;Type&gt;Method()</code> functions to invoke superclass' instance methods which has been overridden in this class (similar to a <code>super.<em>methodName</em>()</code> call inside a Java subclass):</p>

<ol>
<li>Get the Method ID, via <code>GetMethodID()</code>.</li>
<li>Based on the Method ID, invoke one of the <code>CallNonvirtual&lt;Type&gt;Method()</code>, with the object, superclass, and arguments.</li>
</ol>

<p>The JNI function for calling the overridden superclass' instance method are:</p>
<pre class="color-syntax">
NativeType <strong>CallNonvirtual&lt;<em>type</em>&gt;Method</strong>(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...);
NativeType <strong>CallNonvirtual&lt;<em>type</em>&gt;MethodA</strong>(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args);
NativeType <strong>CallNonvirtual&lt;<em>type</em>&gt;MethodV</strong>(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args);</pre>

<h3>Creating Objects and Object Arrays</h3>

<p>You can construct <code>jobject</code> and <code>jobjectArray</code> inside the native code, via <code>NewObject()</code> and <code>newObjectArray()</code> functions, and pass them back to the Java program.</p>

<h4>Callback the Constructor to Create a New Java Object in the Native Code</h4>

<p>Callback the constructor is similar to calling back method. First al first, Get the Method ID of the constructor by passing &quot;<code>&lt;init&gt;</code>&quot; as the method name and &quot;<code>V</code>&quot; as the return-type. You can then use methods like <code>NewObject()</code> to call the constructor to create a new java object.</p>

<h5>JNI Program - <span class="font-code">TestJavaConstructor.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre>
</td>
<td>
<pre>
public class TestJNIConstructor {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// Native method that calls back the constructor and return the constructed object.
   // Return an Integer object with the given int.</span>
   private native Integer getIntegerObject(int number);
 
   public static void main(String args[]) {
      TestJNIConstructor obj = new TestJNIConstructor();
      System.out.println(&quot;In Java, the number is :&quot; + obj.getIntegerObject(9999));
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>This class declares a <code>native</code> method <code>getIntegerObject()</code>. The native code shall create and return an Integer object, based on the argument given.</p>

<h5>C Implementation - <span class="font-code">TestJavaConstructor.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIConstructor.h&quot;
 
JNIEXPORT jobject JNICALL Java_TestJNIConstructor_getIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   <span class="color-comment">// Get a class reference for java.lang.Integer</span>
   jclass cls = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
 
   <span class="color-comment">// Get the Method ID of the constructor which takes an int</span>
   jmethodID midInit = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;);
   if (NULL == midInit) return NULL;
   <span class="color-comment">// Call back constructor to allocate a new instance, with an int argument</span>
   jobject newObj = (*env)-&gt;NewObject(env, cls, midInit, number);
 
   <span class="color-comment">// Try runnning the toString() on this newly create object</span>
   jmethodID midToString = (*env)-&gt;GetMethodID(env, cls, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;);
   if (NULL == midToString) return NULL;
   jstring resultStr = (*env)-&gt;CallObjectMethod(env, newObj, midToString);
   const char *resultCStr = (*env)-&gt;GetStringUTFChars(env, resultStr, NULL);
   printf(&quot;In C: the number is %s\n&quot;, resultCStr);
 
   return newObj;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The JNI functions for creating object (<code>jobject</code>) are:</p>
<pre class="color-syntax">
jclass <strong>FindClass</strong>(JNIEnv *env, const char *name);
 
jobject <strong>NewObject</strong>(JNIEnv *env, jclass cls, jmethodID methodID, ...);
jobject <strong>NewObjectA</strong>(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args);
jobject <strong>NewObjectV</strong>(JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
   <span class="color-comment">// Constructs a new Java object. The method ID indicates which constructor method to invoke</span>
 
jobject <strong>AllocObject</strong>(JNIEnv *env, jclass cls);
  <span class="color-comment">// Allocates a new Java object without invoking any of the constructors for the object.</span></pre>

<h4>Array of Objects</h4>

<h5>JNI Program - <span class="font-code">TestJNIObjectArray.java</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
import java.util.ArrayList;
 
public class TestJNIObjectArray {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
   <span class="color-comment">// Native method that receives an Integer[] and</span>
   <span class="color-comment">//  returns a Double[2] with [0] as sum and [1] as average</span>
   private native Double[] sumAndAverage(Integer[] numbers);
 
   public static void main(String args[]) {
      Integer[] numbers = {11, 22, 32};  <span class="color-comment">// auto-box</span>
      Double[] results = new TestJNIObjectArray().sumAndAverage(numbers);
      System.out.println(&quot;In Java, the sum is &quot; + results[0]);  <span class="color-comment">// auto-unbox</span>
      System.out.println(&quot;In Java, the average is &quot; + results[1]);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>For illustration, this class declares a <code>native</code> method that takes an array of <code>Integer</code>, compute their sum and average, and returns as an array of <code>Double</code>. Take note the arrays of objects are pass into and out of the native method.</p>

<h5>C Implementation - <span class="font-code">TestJNIObjectArray.c</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIObjectArray.h&quot;
 
JNIEXPORT jobjectArray JNICALL Java_TestJNIObjectArray_sumAndAverage
          (JNIEnv *env, jobject thisObj, jobjectArray inJNIArray) {
   <span class="color-comment">// Get a class reference for java.lang.Integer</span>
   jclass classInteger = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
   <span class="color-comment">// Use Integer.intValue() to retrieve the int</span>
   jmethodID midIntValue = (*env)-&gt;GetMethodID(env, classInteger, &quot;intValue&quot;, &quot;()I&quot;);
   if (NULL == midIntValue) return NULL;
 
   <span class="color-comment">// Get the value of each Integer object in the array</span>
   jsize length = (*env)-&gt;GetArrayLength(env, inJNIArray);
   jint sum = 0;
   int i;
   for (i = 0; i &lt; length; i++) {
      jobject objInteger = (*env)-&gt;GetObjectArrayElement(env, inJNIArray, i);
      if (NULL == objInteger) return NULL;
      jint value = (*env)-&gt;CallIntMethod(env, objInteger, midIntValue);
      sum += value;
   }
   double average = (double)sum / length;
   printf(&quot;In C, the sum is %d\n&quot;, sum);
   printf(&quot;In C, the average is %f\n&quot;, average);
 
   <span class="color-comment">// Get a class reference for java.lang.Double</span>
   jclass classDouble = (*env)-&gt;FindClass(env, &quot;java/lang/Double&quot;);
 
   <span class="color-comment">// Allocate a jobjectArray of 2 java.lang.Double</span>
   jobjectArray outJNIArray = (*env)-&gt;NewObjectArray(env, 2, classDouble, NULL);
 
   <span class="color-comment">// Construct 2 Double objects by calling the constructor</span>
   jmethodID midDoubleInit = (*env)-&gt;GetMethodID(env, classDouble, &quot;&lt;init&gt;&quot;, &quot;(D)V&quot;);
   if (NULL == midDoubleInit) return NULL;
   jobject objSum = (*env)-&gt;NewObject(env, classDouble, midDoubleInit, (double)sum);
   jobject objAve = (*env)-&gt;NewObject(env, classDouble, midDoubleInit, average);
   <span class="color-comment">// Set to the jobjectArray</span>
   (*env)-&gt;SetObjectArrayElement(env, outJNIArray, 0, objSum);
   (*env)-&gt;SetObjectArrayElement(env, outJNIArray, 1, objAve);
 
   return outJNIArray;
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Unlike primitive array which can be processed in bulk, for object array, you need to use the <code>Get|SetObjectArrayElement()</code> to process each of the elements.</p>

<p>The JNI functions for creating and manipulating object array (<code>jobjectArray</code>) are:</p>
<pre class="color-syntax">
jobjectArray <strong>NewObjectArray</strong>(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);
   <span class="color-comment">// Constructs a new array holding objects in class elementClass.
   // All elements are initially set to initialElement.</span>
 
jobject <strong>GetObjectArrayElement</strong>(JNIEnv *env, jobjectArray array, jsize index);
   <span class="color-comment">// Returns an element of an Object array.</span>
 
void <strong>SetObjectArrayElement</strong>(JNIEnv *env, jobjectArray array, jsize index, jobject value);
   <span class="color-comment">// Sets an element of an Object array.</span></pre>

<h3>Local and Global References</h3>
<p>Managing references is critical in writing efficient programs. For example, we often use <code>FindClass()</code>, <code>GetMethodID()</code>, <code>GetFieldID()</code> to retrieve a <code>jclass</code>, <code>jmethodID</code> and <code>jfieldID</code> inside native functions. Instead of performing repeated calls, the values should be obtained once and cached for subsequent usage, to eliminate the overheads.</p>

<p>The JNI divides object references (for <code>jobject</code>) used by the native code into two categories: local and global references:</p>

<ol>

<li>A <em>local reference</em> is created within the native method, and freed once the method exits. It is valid for the duration of a native method. You can also use JNI function <code>DeleteLocalRef()</code> to invalidate a local reference explicitly, so that it is available for garbage collection intermediately. Objects are passed to native methods as local references. All Java objects (<code>jobject</code>) returned by JNI functions are local references.</li>

<li>A <em>global reference</em> remains until it is explicitly freed by the programmer, via the <code>DeleteGlobalRef()</code> JNI function. You can create a new global reference from a local reference via JNI function <code>NewGlobalRef()</code>.</li>
</ol>


<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td>
<pre>
public class TestJNIReference {
   static {
      System.loadLibrary(&quot;myjni&quot;); <span class="color-comment">// myjni.dll (Windows) or libmyjni.so (Unixes)</span>
   }
 
   <span class="color-comment">// A native method that returns a java.lang.Integer with the given int.</span>
   private native Integer getIntegerObject(int number);
 
   <span class="color-comment">// Another native method that also returns a java.lang.Integer with the given int.</span>
   private native Integer anotherGetIntegerObject(int number);
 
   public static void main(String args[]) {
      TestJNIReference test = new TestJNIReference();
      System.out.println(test.getIntegerObject(1));
      System.out.println(test.getIntegerObject(2));
      System.out.println(test.anotherGetIntegerObject(11));
      System.out.println(test.anotherGetIntegerObject(12));
      System.out.println(test.getIntegerObject(3));
      System.out.println(test.anotherGetIntegerObject(13));
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The above JNI program declares two native methods. Both of them create and return a <code>java.lang.Integer</code> object.</p>

<p>In the C implementation, we need to get a class reference for <code>java.lang.Integer</code>, via <code>FindClass()</code>. We then find the method ID for the constructor of <code>Integer</code>, and invoke the constructor. However, we wish to cache both the class reference and method ID, to be used for repeated invocation.</p>

<p>The following C implementation does not work!</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre>
</td>
<td>
<pre>
#include &lt;jni.h&gt;
#include &lt;stdio.h&gt;
#include &quot;TestJNIReference.h&quot;
 
<span class="color-comment">// Global Reference to the Java class &quot;java.lang.Integer&quot;</span>
static jclass classInteger;
static jmethodID midIntegerInit;
 
jobject getInteger(JNIEnv *env, jobject thisObj, jint number) {
 
   <span class="color-comment">// Get a class reference for java.lang.Integer if missing</span>
   if (NULL == classInteger) {
      printf(&quot;Find java.lang.Integer\n&quot;);
      classInteger = (*env)-&gt;FindClass(env, &quot;java/lang/Integer&quot;);
   }
   if (NULL == classInteger) return NULL;
 
   <span class="color-comment">// Get the Method ID of the Integer's constructor if missing</span>
   if (NULL == midIntegerInit) {
      printf(&quot;Get Method ID for java.lang.Integer's constructor\n&quot;);
      midIntegerInit = (*env)-&gt;GetMethodID(env, classInteger, &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;);
   }
   if (NULL == midIntegerInit) return NULL;
 
   <span class="color-comment">// Call back constructor to allocate a new instance, with an int argument</span>
   jobject newObj = (*env)-&gt;NewObject(env, classInteger, midIntegerInit, number);
   printf(&quot;In C, constructed java.lang.Integer with number %d\n&quot;, number);
   return newObj;
}
 
JNIEXPORT jobject JNICALL Java_TestJNIReference_getIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}
 
JNIEXPORT jobject JNICALL Java_TestJNIReference_anotherGetIntegerObject
          (JNIEnv *env, jobject thisObj, jint number) {
   return getInteger(env, thisObj, number);
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In the above program, we invoke <code>FindClass()</code> to find the class reference for <code>java.lang.Integer</code>, and saved it in a global static variable. Nonetheless, in the next invocation, this reference is no longer valid (and not NULL). This is because <code>FindClass()</code> returns a local reference, which is invalidated once the method exits.</p>

<p>To overcome the problem, we need to create a global reference from the local reference returned by <code>FindClass()</code>. We can then free the local reference. The revised code is as follows:</p>

<pre class="color-example">
   <span class="color-comment">// Get a class reference for java.lang.Integer if missing</span>
   if (NULL == classInteger) {
      printf(&quot;Find java.lang.Integer\n&quot;);
      <span class="color-comment">// FindClass returns a local reference</span>
      jclass classIntegerLocal = (*env)->FindClass(env, &quot;java/lang/Integer&quot;);
      <span class="color-comment">// Create a global reference from the local reference</span>
      classInteger = (*env)->NewGlobalRef(env, classIntegerLocal);
      <span class="color-comment">// No longer need the local reference, free it!</span>
      (*env)->DeleteLocalRef(env, classIntegerLocal);
   }</pre>

<p>Take note that <code>jmethodID</code> and <code>jfieldID</code> are not <code>jobject</code>, and cannot create global reference.</p>

<h3>Debugging JNI Programs</h3>

<p>[TODO]</p>



<!-- @@ start change in v1 -->

<p class="references">REFERENCES &amp; RESOURCES</p>
<ol>
<li>Java Native Interface Specification @ <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/index.html</a>.</li>

<li>Wiki &quot;Java Native Interface&quot; @ <a href="http://en.wikipedia.org/wiki/Java_Native_Interface">http://en.wikipedia.org/wiki/Java_Native_Interface</a>.</li>
<li>Liang, &quot;The Java Native Interface - Programmer's Guide and Specification&quot;, Addison Wesley, 1999, available online @ <a href="http://java.sun.com/docs/books/jni/html/jniTOC.html">http://java.sun.com/docs/books/jni/html/jniTOC.html</a>.</li>
<li>JNI Tips @ <a href="http://developer.android.com/guide/practices/jni.html">http://developer.android.com/guide/practices/jni.html</a>.</li>
</ol>

</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 1.7.0, MinGW GCC 4.6.2, Eclipse 4.2 (Juno)<br />
Last modified: February, 2014</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
<!-- @@ end change in v1 -->
</body>
</html>
