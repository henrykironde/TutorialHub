<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>GUI Programming -  Java Programming Tutorial</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Java Programming Tutorial</h1>
<h2>Programming Graphical User Interface (GUI)</h2>
</div>

<div id="content-main">

<h3>Introduction</h3>
<p>So far, we have covered most of the basic constructs of Java and introduced the important concept of Object-Oriented Programming (OOP).  As discussed, OOP permits higher level of abstraction than the traditional procedural-oriented languages (such as C and Pascal).  OOP lets you think in the problem space rather than the computer's bits and bytes and instruction sequences.  You can create high-level abstract data types called <em>classes</em> to mimic real-life things and represent entities in the problem space.  These classes are self-contained and are reusable.</p>

<p>In this article, I shall show you how you can reuse the graphics classes provided in JDK for constructing your own Graphical User Interface (GUI) applications. Writing your own graphics classes (re-inventing the wheels) will take you many years! These  graphics classes, developed by expert programmers, are highly complex and  involve many advanced Java concepts.Â   However, re-using them are not so difficult, if you follow the API  documentation, samples and templates provided.</p>
<p>I shall assume you have a good grasp of OOP, including inheritance and polymorphism (otherwise, read the earlier articles). I will describe another important concept called <em>nested class</em> (or <em>inner class</em>) in this article.</p>

<p>There are two sets of Java APIs for graphics programming: AWT (<span class="underline">A</span>bstract <span class="underline">W</span>indowing <span class="underline">T</span>oolkit) and Swing.</p>
<ol>
<li>AWT API was introduced in JDK 1.0.  Most of the AWT components have become obsolete and should be replaced by newer Swing components.</li>
<li>Swing API, a much more comprehensive set of graphics libraries that enhances the AWT, was introduced as part of Java Foundation Classes (JFC) after the release of JDK 1.1. JFC consists of Swing, Java2D, Accessibility, Internationalization, and Pluggable Look-and-Feel Support APIs. JFC was an add-on to JDK 1.1 but has been integrated into core Java since JDK 1.2.</li>
</ol>

<p>Other than AWT/Swing Graphics APIs provided in JDK, others have also provided Graphics APIs that work with Java, such as Eclipse's Standard Widget Toolkit (SWT) (used in Eclipse), Google Web Toolkit (GWT) (used in Android), 3D Graphics API such as Java  bindings for OpenGL (JOGL) and Java3D.</p>

<p>You need to check the JDK API specification (<a href="http://docs.oracle.com/javase/8/docs/api/index.html">http://docs.oracle.com/javase/8/docs/api/index.html</a>) for the AWT and Swing APIs while reading this chapter. The best online reference for Graphics programming is the &quot;Swing Tutorial&quot; @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>. For advanced 2D graphics programming, read &quot;Java 2D Tutorial&quot; @ <a href="http://docs.oracle.com/javase/tutorial/2d/index.html">http://docs.oracle.com/javase/tutorial/2d/index.html</a>.</p>

<h3>Programming GUI with AWT</h3>
<p>Java Graphics APIs - AWT and Swing - provide a huge set of reusable GUI components, such as button, text field, label, choice, panel and frame for building GUI applications.  You can simply reuse these classes rather than re-invent the wheels.  I shall start with the AWT classes before moving into Swing to give you a complete picture.  I have to stress that AWT component classes are now obsoleted by Swing's counterparts.</p>

<h4>AWT Packages</h4>

<p>AWT is huge! It consists of 12 packages (Swing is even bigger, with 18 packages as of JDK 1.8). Fortunately, only 2 packages - <code>java.awt</code> and <code>java.awt.event</code> - are commonly-used.</p>

<ol>
<li>The <code>java.awt</code> package contains the <em>core</em> AWT graphics classes:
  <ul>
<li>GUI Component classes (such as <code>Button</code>, <code>TextField</code>, and <code>Label</code>),</li>
<li>GUI Container classes (such as <code>Frame</code>, <code>Panel</code>, <code>Dialog</code> and <code>ScrollPane</code>),</li>
<li>Layout managers (such as <code>FlowLayout</code>, <code>BorderLayout</code> and <code>GridLayout</code>),</li>
<li>Custom graphics classes (such as <code>Graphics</code>, <code>Color</code> and <code>Font</code>).</li>
</ul>
</li>
<li>The <code>java.awt.event</code> package supports event handling:
  <ul>
<li>Event classes (such as <code>ActionEvent</code>, <code>MouseEvent</code>, <code>KeyEvent</code> and <code>WindowEvent</code>),</li>
<li>Event Listener Interfaces (such as <code>ActionListener</code>, <code>MouseListener</code>, <code>KeyListener</code> and <code>WindowListener</code>),</li>
<li>Event Listener Adapter classes (such as <code>MouseAdapter</code>, <code>KeyAdapter</code>, and <code>WindowAdapter</code>).</li>
</ul>

</li>
</ol>

<p>AWT provides a <em>platform-independent</em> and <em>device-independent</em> interface to develop graphic programs that runs on all platforms, such as Windows, Mac, and Linux.</p>

<h4>Containers and Components</h4>

<img src="images/AWT_ContainerComponent.png" alt="AWT_ContainerComponent.png" />

<p>There are two types of GUI elements:</p>
<ol>
<li><em>Component</em>: Components are elementary GUI entities (such as <code>Button</code>, <code>Label</code>, and <code>TextField</code>.)</li>
<li><em>Container</em>: Containers (such as <code>Frame</code> and  <code>Panel</code>) are used to <em>hold components in a specific layout</em> (such as flow or grid). A container can also hold sub-containers.</li> 
</ol>

<p>GUI components are also called <em>controls</em> (Microsoft ActiveX Control), <em>widgets</em> (Eclipse's Standard Widget Toolkit, Google Web Toolkit), which allow users to interact with (or control) the application through these components (such as button-click and text-entry).</p>

<p>In the above figure, there are three containers: a <code>Frame</code> and two <code>Panel</code>s. A <code>Frame</code> is the <em>top-level container</em> of an AWT program. A <code>Frame</code> has a title bar (containing an icon, a title,  and the minimize/maximize/close buttons), an optional menu bar and the content display area. A <code>Panel</code> is a<em> rectangular area</em>  used to group related GUI components in a certain layout. In the above figure, the top-level <code>Frame</code> contains two  <code>Panel</code>s. There are five components: a <code>Label</code> (providing description), a <code>TextField</code> (for users to enter text), and three <code>Button</code>s (for user to trigger certain programmed actions).</p>

<p>In a GUI program, a component must be kept in a  container. 
 You need to identify a container to hold the components. Every container has a method called <code>add(Component c)</code>. A <code>container</code> (say <code>aContainer</code>) can invoke <code>aContainer.add(aComponent)</code> to add <code>aComponent</code> into itself. For example,</p>

<pre class="color-example">
Panel panel = new Panel();  <span class="color-comment">      // Panel is a Container</span>
Button btn = new Button(&quot;Press&quot;); <span class="color-comment">// Button is a Component</span>
panel.add(btn);                   <span class="color-comment">// The Panel Container adds a Button Component</span></pre>

<h4>AWT <span class="font-code">Container</span> Classes</h4>

<h5>Top-Level Containers: <span class="font-code">Frame</span>, <span class="font-code">Dialog</span> and <span class="font-code">Applet</span></h5> 
<p>Each GUI program has a <em>top-level container</em>. The commonly-used top-level containers in AWT are <code>Frame</code>, <code>Dialog</code> and <code>Applet</code>:</p>

<ul>
<li>
<img class="image-float-right" src="images/AWT_Frame.png" alt="AWT_Frame.png" />

A  <code>Frame</code> provides the &quot;main window&quot; for the GUI application, which has a title bar (containing an icon, a title, the minimize, maximize/restore-down and close buttons), an optional menu bar, and the content display area.

To write a GUI program, we typically start with a subclass extending from <code>java.awt.Frame</code> to inherit the main window as follows:
<pre class="color-example float-clear">
<span class="color-new">import java.awt.Frame;</span>  <span class="color-comment">// Using Frame class in package java.awt</span>

<span class="color-comment">// A GUI program is written as a subclass of Frame - the top-level container
// This subclass inherits all properties from Frame, e.g., title, icon, buttons, content-pane</span>
public class MyGUIProgram <span class="color-new">extends Frame</span> {
 
   <span class="color-comment">// Constructor to setup the GUI components</span>
   public MyGUIProgram() { ...... }

   <span class="color-comment">// Other methods</span>
   ......
   ......

   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Invoke the constructor (to setup the GUI) by allocating an instance</span>
      new MyGUIProgram();
   }
}</pre>
</li>


<li>
<img class="image-float-right" src="images/AWT_Dialog.gif" alt="AWT_Dialog.gif" />

An AWT <code>Dialog</code> is a <em>&quot;pop-up window</em>&quot; used for interacting with the users. A <code>Dialog</code> has a title-bar (containing an icon, a title and a close button) and a content display area, as illustrated.

</li>

<li>An AWT <code>Applet</code> (in package <code>java.applet</code>) is the top-level container for an applet, which is a Java program running inside a browser. Applet will be discussed in the later chapter.</li>
</ul>

<h5>Secondary Containers: <span class="font-code">Panel</span> and <span class="font-code">ScrollPane</span></h5>
<p>Secondary containers are placed inside a top-level container or another secondary container. AWT also provide these secondary containers:</p>

<ul>
<li><code>Panel</code>: a rectangular box under a higher-level container, used to <em>layout</em> a set of related GUI components in pattern such as grid or flow.</li>

<li><code>ScrollPane</code>: provides automatic horizontal and/or vertical scrolling for a single child component.</li>
<li>others.</li>
</ul>

<h5>Hierarchy of the AWT <span class="font-code">Container</span> Classes</h5>
<p>The hierarchy of the AWT <code>Container</code> classes is as follows:</p>

<img class="image-center" src="images/AWT_ContainerClassDiagram.png" alt="AWT_ContainerClassDiagram.png" />

<p>As illustrated, each <code>Container</code> has a layout.</p>

<h4>AWT <span class="font-code">Component</span> Classes</h4>

<p>AWT provides many ready-made  and reusable GUI components.  The frequently-used are: <code>Button</code>, <code>TextField</code>, <code>Label</code>, <code>Checkbox</code>, <code>CheckboxGroup</code> (radio buttons), <code>List</code>, and <code></code><code>Choice</code>, as illustrated below.</p>
<img class="image-center" src="images/AWT_Components.png" alt="AWT_Components.png" />

<h5>AWT GUI Component: <span class="font-code">java.awt.Label</span></h5>
<img class="image-float-right" src="images/AWT_Label.png" alt="AWT_Label.png" />

<p>A <code>java.awt.Label</code> provides a text description message. Take note that <code>System.out.println()</code> prints to the system console, not to the graphics screen. You could use  a <code>Label</code> to label another component (such as text field) or provide a text description.</p>

<p> Check the JDK API specification for <code>java.awt.Label</code>.</p>

<p class="float-clear"><span class="underline">Constructors</span></p>
<pre class="color-syntax">
public Label(String <em>strLabel</em>, int <em>alignment</em>); <span class="color-comment">// Construct a Label with the given text String, of the text alignment</span>
public Label(String <em>strLabel</em>);                <span class="color-comment">// Construct a Label with the given text String</span>
public Label();                               <span class="color-comment">// Construct an initially empty Label</span></pre>

<p>The <code>Label</code> class has three constructors:</p>
<ol>
<li>The first constructor constructs a <code>Label</code> object with the given text string in the given alignment.  Note that three <code>static</code> constants <code>Label.LEFT</code>, <code>Label.RIGHT</code>, and <code>Label.CENTER</code> are defined in the class for you to specify the alignment (rather than asking you to memorize arbitrary integer values).</li>
<li>The second constructor constructs a <code>Label</code> object with the given text string in default of left-aligned.</li>
<li>The third constructor constructs a <code>Label</code> object with an initially empty string. You could set the label text via the <code>setText()</code> method later.</li>
</ol>

<p><span class="underline">Constants</span></p>
<pre class="color-syntax">
public static final LEFT;    <span class="color-comment">// Label.LEFT</span>
public static final RIGHT;   <span class="color-comment">// Label.RIGHT</span>
public static final CENTER;  <span class="color-comment">// Label.CENTER</span></pre>

<p>These three constants are defined for specifying the alignment of the <code>Label</code>'s text.</p>

<p><span class="underline">Public Methods</span></p>
<pre class="color-syntax">
<span class="color-comment">// Examples</span>
public String getText();
public void setText(String <em>strLabel</em>);
public int getAlignment();
public void setAlignment(int <em>alignment</em>);</pre>

<p>The <code>getText()</code> and <code>setText()</code> methods can be used to read and modify the <code>Label</code>'s text.  Similarly, the <code>getAlignment()</code> and <code>setAlignment()</code> methods can be used to retrieve and modify the alignment of the text.</p>

<h5>Constructing a Component and Adding the Component into a Container</h5>

<p>Three steps are necessary to create and place a GUI component:</p>
<ol>
<li>Declare  the component with an <em>identifier</em> (<em>name</em>);</li>
<li>Construct the component by invoking an appropriate constructor via the <code>new</code> operator;</li>
<li>Identify the container (such as <code>Frame</code> or <code>Panel</code>) designed to hold this component. The container can then add this component onto itself via <code><em>aContainer</em>.add(<em>aComponent</em>)</code> method. Every container has a <code>add(Component)</code> method. Take note that it is the container that actively and explicitly adds a component onto itself, instead of the other way.</li>
</ol>

<p class="underline">Example</p>
<pre class="color-example">
Label lblInput;                     <span class="color-comment">// Declare an Label instance called lblInput</span>
lblInput = new Label(&quot;Enter ID&quot;);   <span class="color-comment">// Construct by invoking a constructor via the new operator</span>
add(lblInput);                      <span class="color-comment">// this.add(lblInput) - &quot;this&quot; is typically a subclass of Frame</span>
lblInput.setText(&quot;Enter password&quot;); <span class="color-comment">// Modify the Label's text string</span>
lblInput.getText();                 <span class="color-comment">// Retrieve the Label's text string</span><span class="color-comment"></span></pre>

<h5>An Anonymous Instance</h5>

<p>You can create a <code>Label</code> without specifying an identifier, called <em>anonymous instance</em>.  In the case, the Java compiler will assign an <em>anonymous identifier</em> for the allocated object.  You will not be able to reference an anonymous instance in your program after it is created.  This is usually alright for a <code>Label</code> instance as there is often no need to reference a <code>Label</code> after it is constructed.</p>

<p class="underline">Example</p>
<pre class="color-example">
<span class="color-comment">// Allocate an anonymous Label instance. &quot;this&quot; container adds the instance into itself.
// You CANNOT reference an anonymous instance to carry out further operations.</span>
add(new Label(&quot;Enter Name: &quot;, Label.RIGHT));
 
<span class="color-comment">// Same as</span>
Label lblXxx = new Label(&quot;Enter Name: &quot;, Label.RIGHT)); <span class="color-comment">// lblXxx assigned by compiler</span>
add(lblXxx);</pre>

<h5>AWT GUI Component: <span class="font-code">java.awt.Button</span></h5>
<img class="image-float-right" src="images/AWT_Button.png" alt="AWT_Button.png" />

<p>A <code>java.awt.Button</code> is a GUI component that triggers a certain programmed <em>action</em> upon clicking.</p>

<p class="float-clear"><span class="underline">Constructors</span></p> 

<pre class="color-syntax">
public Button(String <em>buttonLabel</em>);
   <span class="color-comment">// Construct a Button with the given label</span>
public Button();
   <span class="color-comment">// Construct a Button with empty label</span></pre>

<p>The <code>Button</code> class has two constructors.  The first constructor creates a <code>Button</code> object with the given label painted over the button.  The second constructor creates a <code>Button</code> object with no label.</p>

<p><span class="underline">Public Methods</span></p>
<pre class="color-syntax">
public String getLabel();
   <span class="color-comment">// Get the label of this Button instance</span>
public void setLabel(String <em>buttonLabel</em>);
   <span class="color-comment">// Set the label of this Button instance</span>
public void setEnable(boolean <em>enable</em>);   <span class="color-comment">
   // Enable or disable this Button. Disabled Button cannot be clicked.</span></pre>

<p>The <code>getLabel()</code> and <code>setLabel()</code> methods can be used to read the current label and modify the label of a button, respectively.</p>
<p>Note: The latest Swing's <code>JButton</code> replaces <code>getLabel()/setLabel()</code> with <code>getText()/setText()</code> to be consistent with all the  components. We will describe Swing later.</p>

<p><span class="underline">Event</span></p>
<p>Clicking a button fires a so-called <code>ActionEvent</code> and triggers a certain programmed action.  I will explain event-handling later.</p>

<p><span class="underline">Example</span></p>
<pre class="color-example">
Button btnColor = new Button(&quot;Red&quot;); <span class="color-comment">// Declare and allocate a Button instance called btnColor</span>
add(btnColor);                       <span class="color-comment">// &quot;this&quot; Container adds the Button</span>
...
btnColor.setLabel(&quot;green&quot;);          <span class="color-comment">// Change the button's label</span>
btnColor.getLabel();                 <span class="color-comment">// Read the button's label</span>
...
add(Button(&quot;Blue&quot;));    <span class="color-comment">// Create an anonymous Button. It CANNOT be referenced later</span>
</pre>

<h5>AWT GUI Component: <span class="font-code">java.awt.TextField</span></h5>
<img class="image-float-right" src="images/AWT_TextField.png" alt="AWT_TextField.png" />

<p>A <code>java.awt.TextField</code> is single-line text box for users to enter texts.  (There is a multiple-line text box called <code>TextArea</code>.) Hitting the &quot;ENTER&quot; key on a <code>TextField</code> object triggers an action-event.</p>

<p class="float-clear"><span class="underline">Constructors</span></p>
<pre class="color-syntax">
public TextField(String <em>strInitialText</em>, int <em>columns</em>);
   <span class="color-comment">// Construct a TextField instance with the given initial text string with the number of columns.</span>
public TextField(String <em>strInitialText</em>);
   <span class="color-comment">// Construct a TextField instance with the given initial text string.</span>
public TextField(int <em>columns</em>);
   <span class="color-comment">// Construct a TextField instance with the number of columns.</span></pre>

<p><span class="underline">Public Methods</span></p>
<pre class="color-syntax">
public String getText();
   <span class="color-comment">// Get the current text on this TextField instance</span>
public void setText(String <em>strText</em>);
   <span class="color-comment">// Set the display text on this TextField instance</span>
public void setEditable(boolean <em>editable</em>);
   <span class="color-comment">// Set this TextField to editable (read/write) or non-editable (read-only)</span></pre>

<p><span class="underline">Event</span></p>
<p>Hitting the &quot;ENTER&quot; key on a <code>TextField</code> fires a <code>ActionEvent</code>, and triggers a certain programmed action.</p>

<p><span class="underline">Example</span></p>
<pre class="color-example">
TextField tfInput = new TextField(30); <span class="color-comment">// Declare and allocate an TextField instance called tfInput</span>
add(tfInput);                          <span class="color-comment">// &quot;this&quot; Container adds the TextField</span>
TextField tfResult = new TextField();  <span class="color-comment">// Declare and allocate an TextField instance called tfResult</span>
tfResult.setEditable(false) ;          <span class="color-comment">// Set to read-only</span>
add(tfResult);                         <span class="color-comment">// &quot;this&quot; Container adds the TextField</span>
......
<span class="color-comment">// Read an int from TextField &quot;tfInput&quot;, square it, and display on &quot;tfResult&quot;.
// getText() returns a String, need to convert to int</span>
int number = Integer.parseInt(tfInput.getText());
number *= number;
<span class="color-comment">// setText() requires a String, need to convert the int number to String.</span>
tfResult.setText(number + &quot;&quot;);
</pre>

<p>Take note that <code>getText()/SetText()</code> operates on <code>String</code>. You can convert a <code>String</code> to a primitive, such as <code>int</code> or <code>double</code> via <code>static </code>method <code>Integer.parseInt()</code> or <code>Double.parseDouble()</code>. To convert a primitive to a <code>String</code>, simply concatenate the primitive with an empty <code>String</code>.</p>

<h4>Example 1: <span class="font-code">AWTCounter</span></h4>

<img class="image-float-right" src="images/AWT_Counter.png" alt="AWT_Counter.png" />

<p>Let's assemble some components together into a simple GUI counter program, as illustrated.  It has a top-level container <code>Frame</code>, which contains three  components - a <code>Label</code> &quot;Counter&quot;, a non-editable <code>TextField</code> to display the current count, and a &quot;Count&quot; <code>Button</code>.  The <code>TextField</code> displays <code>&quot;0&quot;</code> initially.  </p>
<p>Each time you click the button, the counter's value increases by 1.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment"> // Using AWT container and component classes</span>
import java.awt.event.*; <span class="color-comment"> // Using AWT event classes and listener interfaces</span>
 
<span class="color-comment">// An AWT program inherits from the top-level container java.awt.Frame</span>
public class AWTCounter <strong>extends Frame</strong> implements ActionListener {
   private Label lblCount;   <span class="color-comment"> // Declare a Label component</span> 
   private TextField tfCount;<span class="color-comment"> // Declare a TextField component </span>
   private Button btnCount;  <span class="color-comment"> // Declare a Button component</span>
   private int count = 0;    <span class="color-comment"> // Counter's value</span>
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTCounter () {
      setLayout(new FlowLayout());
        <span class="color-comment"> // &quot;super&quot; Frame (a Container) sets its layout to FlowLayout, which arranges</span>
        <span class="color-comment"> // the components from left-to-right, and flow to next row from top-to-bottom.</span>
 
      lblCount = new Label(&quot;Counter&quot;); <span class="color-comment"> // construct the Label component</span>
      add(lblCount);                   <span class="color-comment"> // &quot;super&quot; Frame adds Label</span>
 
      tfCount = new TextField(&quot;0&quot;, 10);<span class="color-comment"> // construct the TextField component</span>
      tfCount.setEditable(false);      <span class="color-comment"> // set to read-only</span>
      add(tfCount);                    <span class="color-comment"> // &quot;super&quot; Frame adds TextField</span>
 
      btnCount = new Button(&quot;Count&quot;);  <span class="color-comment"> // construct the Button component</span>
      add(btnCount);                   <span class="color-comment"> // &quot;super&quot; Frame adds Button</span>
 
      btnCount.addActionListener(this);
         <span class="color-comment">// btnCount is the source object that fires ActionEvent when clicked.</span>
         <span class="color-comment">// The source add &quot;this&quot; instance as an ActionEvent listener, which provides</span>
         <span class="color-comment">//  an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Clicking btnCount invokes actionPerformed().</span>
<span class="color-comment"></span> 
      setTitle(&quot;AWT Counter&quot;); <span class="color-comment"> // &quot;super&quot; Frame sets its title</span>
      setSize(250, 100);       <span class="color-comment"> // &quot;super&quot; Frame sets its initial window size</span>
 
     <span class="color-comment"> // For inspecting the components/container objects</span>
     <span class="color-comment"> // System.out.println(this);</span>
     <span class="color-comment"> // System.out.println(lblCount);</span>
     <span class="color-comment"> // System.out.println(tfCount);</span>
     <span class="color-comment"> // System.out.println(btnCount);</span>
 
      setVisible(true);        <span class="color-comment"> // &quot;super&quot; Frame shows</span>
 
     <span class="color-comment"> // System.out.println(this);</span>
     <span class="color-comment"> // System.out.println(lblCount);</span>
     <span class="color-comment"> // System.out.println(tfCount);</span>
     <span class="color-comment"> // System.out.println(btnCount);</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
     <span class="color-comment"> // Invoke the constructor to setup the GUI, by allocating an instance</span>
      AWTCounter app = new AWTCounter();
         <span class="color-comment">// or simply &quot;new AWTCounter();&quot; for an anonymous instance</span>
   }
 
   <span class="color-comment">// ActionEvent handler - Called back upon button-click.</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;<span class="color-comment"> // increase the counter value</span>
     <span class="color-comment"> // Display the counter value on the TextField tfCount</span>
      tfCount.setText(count + &quot;&quot;);<span class="color-comment"> // convert int to String</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>


<p>To exit this program, you have to close the CMD-shell (or press &quot;control-c&quot; on the CMD console); or push the &quot;red-square&quot; close button in Eclipse's Application Console.  This is because we have yet to write the handler for the <code>Frame</code>'s close button.  We shall do that in the later example.</p>

<p class="line-heading">Dissecting the <span class="font-code">AWTCounter.java</span></p>
<ul>
<li>The <code>import</code> statements (Lines 1-2) are needed, as AWT container and component classes, such as <code>Frame</code>, <code>Button</code>, <code>TextField</code>, and <code>Label,</code> are kept in the <code>java.awt</code> package; while AWT events and event-listener interfaces, such as <code>ActionEvent</code> and <code>ActionListener</code>  are kept in the <code>java.awt.event</code> package.</li>
<li>A GUI program needs a top-level container, and is often written as a subclass of <code>Frame</code> (Line 5). In other words, this class <code>AWTCounter</code> <em>is a</em> <code>Frame</code>, and inherits all the attributes and behaviors of a <code>Frame</code>, such as the title bar and content pane.</li>
<li>Lines 12 to 46 define a constructor, which is  used to setup and initialize the GUI components.</li>
<li>In Line 13, the <code>setLayout()</code> (inherited from the superclass <code>Frame</code>) is used to set the layout of the container. <code>FlowLayout</code> is used which arranges the components in left-to-right and flows into next row in a top-to-bottom manner.</li>
<li>A <code>Label</code>, <code>TextField</code> (non-editable), and <code>Button</code> are constructed. We invoke the <code>add()</code> method (inherited from the superclass <code>Frame</code>) to add these components into container<code></code>.</li>
<li>In Line 33-34, we invoke the <code>setSize()</code> and the <code>setTitle()</code> (inherited from the superclass <code>Frame</code>) to set the initial size and the title of the <code>Frame</code>. The <code>setVisible(true)</code> method (Line 42) is then invoked to show the display.</li>
<li>The statement <code>btnCount.addActionListener(this)</code> (Line 27) is used to setup the event-handling mechanism, which will be discussed in length later. In brief,  whenever the button is clicked, the <code>actionPerformed()</code> will be called. In the <code>actionPerformed()</code> (Lines 57-63), the counter value increases by 1 and displayed on the <code>TextField</code>.</li>
<li>In the entry<code> main()</code> method (Lines 51-55), an instance of <code>AWTCounter</code> is constructed. The constructor is executed to initialize the GUI components and setup the event-handling mechanism. The GUI program then waits for the user input.</li>
</ul>

<h5>Inspecting Container/Components via <span class="font-code">toString()</span></h5>
<p>It is interesting to inspect the GUI objects via the <code>toString()</code>, to gain an insight to these classes. (Alternatively, use a graphic debugger in Eclipse/NetBeans or study the JDK source code.) For example, if we insert the following code before and after the <code>setvisible()</code>:</p>
<pre class="color-example">
System.out.println(this);
System.out.println(lblCount);
System.out.println(tfCount);
System.out.println(btnCount);
 
setVisible(true);  <span class="color-comment">// &quot;super&quot; Frame shows</span>
 
System.out.println(this);
System.out.println(lblCount);
System.out.println(tfCount);
System.out.println(btnCount);</pre>

<p>The output (with my comments) are as follows. You could have an insight of the variables defined in the class.</p>
<pre class="output">
<span class="color-comment">// Before setVisible()</span>
AWTCounter[frame0,0,0,250x100,invalid,hidden,layout=java.awt.FlowLayout,title=AWT Counter,resizable,normal]
      <span class="color-comment">// name (assigned by compiler) is &quot;frame0&quot;; top-left (x,y) at (0,0); width/height is 250x100 (via setSize());</span>
java.awt.Label[label0,0,0,0x0,invalid,align=left,text=Counter]
      <span class="color-comment">// name is &quot;Label0&quot;; align is &quot;Label.LEFT&quot; (default); text is &quot;Counter&quot; (assigned in contructor)</span>
java.awt.TextField[textfield0,0,0,0x0,invalid,text=0,selection=0-0]
      <span class="color-comment">// name is &quot;Textfield0&quot;; text is &quot;0&quot; (assigned in contructor)</span>
java.awt.Button[button0,0,0,0x0,invalid,label=Count]
      <span class="color-comment">// name is &quot;button0&quot;; label text is &quot;Count&quot; (assigned in contructor)</span>
      <span class="color-comment">// Before setVisible(), all components are invalid (top-left (x,y), width/height are invalid) </span>
<span class="color-comment"> 
// After setVisible(), all components are valid</span>
AWTCounter[frame0,0,0,250x100,layout=java.awt.FlowLayout,title=AWT Counter,resizable,normal]
      <span class="color-comment">// valid and visible (not hidden)</span>
java.awt.Label[label0,20,41,58x23,align=left,text=Counter]
      <span class="color-comment">// Top-left (x,y) at (20,41) relative to the parent Frame; width/height = 58x23</span>
java.awt.TextField[textfield0,83,41,94x23,text=0,selection=0-0]
      <span class="color-comment">// Top-left (x,y) at (83,41) relative to the parent Frame; width/height = 94x23; no text selected (0-0)</span>
java.awt.Button[button0,182,41,47x23,label=Count]
      <span class="color-comment">// Top-left (x,y) at (182,41) relative to the parent Frame; width/height = 47x23</span></pre>

<h4>Example 2: <span class="font-code">AWTAccumulator</span></h4>

<img class="image-float-right" src="images/AWT_Accumulator.png" alt="AWT_Accumulator.png" />

<p>In this example, the top-level container is again the typical <code>java.awt.Frame</code>, which contains 4 components: a <code>Label</code> &quot;Enter an Integer&quot;, a <code>TextField</code> for accepting user input, another <code>Label</code> &quot;The Accumulated Sum is&quot;, and another non-editable <code>TextField</code> for displaying the sum. The components are arranged in <code>FlowLayout</code>.</p>

<p>The program shall accumulate the number entered into the <em>input</em> <code>TextField</code> and display the sum in the <em>output</em> <code>TextField</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></td>
<td>
<pre>
import java.awt.*;       <span class="color-comment"> // Using AWT container and component classes</span>
import java.awt.event.*; <span class="color-comment"> // Using AWT event classes and listener interfaces</span>
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class AWTAccumulator <strong>extends Frame</strong> implements ActionListener {
   private Label lblInput;    <span class="color-comment"> // Declare input Label</span>
   private Label lblOutput;   <span class="color-comment"> // Declare output Label</span>
   private TextField tfInput; <span class="color-comment"> // Declare input TextField</span>
   private TextField tfOutput;<span class="color-comment"> // Declare output TextField</span>
   private int sum = 0;       <span class="color-comment"> // Accumulated sum, init to 0</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTAccumulator() {
      setLayout(new FlowLayout());
        <span class="color-comment"> // &quot;super&quot; Frame (a Container) sets layout to FlowLayout, which arranges</span>
        <span class="color-comment"> // the components from left-to-right, and flow to next row from top-to-bottom.</span>
 
      lblInput = new Label(&quot;Enter an Integer: &quot;);<span class="color-comment"> // Construct Label</span>
      add(lblInput);              <span class="color-comment"> // &quot;super&quot; Frame adds Label</span>
 
      tfInput = new TextField(10);<span class="color-comment"> // Construct TextField</span>
      add(tfInput);               <span class="color-comment"> // &quot;super&quot; Frame adds TextField</span>
 
      tfInput.addActionListener(this);
         <span class="color-comment">// tfInput is the source object that fires ActionEvent when entered.</span>
         <span class="color-comment">// The source add &quot;this&quot; instance as an ActionEvent listener, which provides</span>
         <span class="color-comment">//  an ActionEvent handler called actionPerformed().</span>
         <span class="color-comment">// Hitting enter on tfInput invokes actionPerformed().</span>
<span class="color-comment"></span> 
      lblOutput = new Label(&quot;The Accumulated Sum is: &quot;); <span class="color-comment"> // allocate Label</span>
      add(lblOutput);              <span class="color-comment"> // &quot;super&quot; Frame adds Label</span>
 
      tfOutput = new TextField(10);<span class="color-comment"> // allocate TextField</span>
      tfOutput.setEditable(false); <span class="color-comment"> // read-only</span>
      add(tfOutput);               <span class="color-comment"> // &quot;super&quot; Frame adds TextField</span>
 
      setTitle(&quot;AWT Accumulator&quot;); <span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(350, 120); <span class="color-comment"> // &quot;super&quot; Frame sets initial window size</span>
      setVisible(true);  <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
     <span class="color-comment"> // Invoke the constructor to setup the GUI, by allocating an anonymous instance</span>
      new AWTAccumulator();
   }
 
   <span class="color-comment">// ActionEvent handler - Called back upon hitting enter key on TextField</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
     <span class="color-comment"> // Get the String entered into the TextField tfInput, convert to int</span>
      int numberIn = Integer.parseInt(tfInput.getText());
      sum += numberIn;     <span class="color-comment"> // Accumulate numbers entered into sum</span>
      tfInput.setText(&quot;&quot;); <span class="color-comment"> // Clear input TextField</span>
      tfOutput.setText(sum + &quot;&quot;);<span class="color-comment"> // Display sum on the output TextField</span>
                                 <span class="color-comment"> // convert int to String</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="line-heading">Dissecting the <span class="font-code">AWTAccumulator.java</span></p>

<ol>
<li>An AWT GUI program extends from <code>java.awt.Frame</code> (Line 5) - the top-level window container.</li>
<li>In the constructor (Line 13), we constructs 4 components - 2 <code>java.awt.Label</code> and 2 <code>java.awt.TextField</code>s. The <code>Frame</code> adds the components, in <code>FlowLayout</code>.</li>
<li><code>tfInput</code> (<code>TextField</code>) is the source object, which fires an <code>ActionEvent</code> upon hitting the Enter key. <code>tfInput</code> adds <code>this</code> instance as an <code>ActionEvent</code> handler (Line 24). The listener class (<code>this</code> or <code>AWTAccumulator</code>) needs to implement <code>ActionListener</code> interface and provides implementation to method <code>actionPerformed()</code>. Whenever an user hits Enter on the <code>tfInput</code> (<code>TextField</code>), the <code>actionPerformed()</code> will be invoked.</li>
</ol>

<h5>Inspecting Container/Components via <span class="font-code">toString()</span></h5>
<p>Printing the <code>toString()</code> after <code>setVisible()</code> produces:</p>
<pre class="output">
AWTAccumulator[frame0,0,0,350x120,layout=java.awt.FlowLayout,title=AWT Accumulator,resizable,normal]
java.awt.Label[label0,72,41,107x23,align=left,text=Enter an Integer: ]
java.awt.Label[label1,47,69,157x23,align=left,text=The Accumulated Sum is: ]
java.awt.TextField[textfield0,184,41,94x23,text=,editable,selection=0-0]
java.awt.TextField[textfield1,209,69,94x23,text=,selection=0-0]</pre>

<h3 id="awt_event_handling">AWT Event-Handling</h3>
<p>Java adopts the so-called &quot;Event-Driven&quot; (or &quot;Event-Delegation&quot;) programming model for  event-handling, similar to most of the visual programming languages (such as Visual Basic and Delphi).  </p>
<p>In event-driven programming, a piece of event-handling codes is executed (or called back by the graphics subsystem) when an event has been fired in response to an user input (such as clicking a mouse button or hitting the ENTER key). This is unlike the procedural model, where codes are executed in a sequential manner.</p>
<p>The AWT's event-handling classes are kept in package <code>java.awt.event</code>.</p>

<p>Three objects are involved in the event-handling: a <em>source</em>, <em>listener</em>(s) and an <em>event</em> object.</p>

<p>The <em>source</em> object (such as <code>Button</code> and <code>Textfield</code>) interacts with the user. Upon triggered, it creates an <em>event</em> object.  This <em>event</em> object will be messaged to all the <em>registered listener</em> object(s), and an appropriate event-handler method of the listener(s) is called-back to provide the response. In other words, <em>triggering a source fires an event to all its listener(s)</em>, <em>and invoke an appropriate handler of the listener(s)</em>.</p>
<p> To express interest for a certain source's event, the listener(s) must be registered with the source. In other words, the listener(s) &quot;subscribes&quot; to a source's event, and the source &quot;publishes&quot; the event to all its subscribers upon activation. This is known as <em>subscribe-publish</em> or <em>observable-observer</em> design pattern.</p>

<img class="image-center" src="images/AWT_EventHandling.png" alt="AWT_EventHandling.png" />

<p>The sequence of steps is illustrated above:</p>
<ol>
<li><em>The source object registers its listener(s)</em> for a certain type of <em>event</em>.
<p>Source object fires event event upon triggered. For example, clicking an <code>Button</code> fires an <code>ActionEvent</code>, mouse-click fires <code>MouseEvent</code>, key-type fires <code>KeyEvent</code>, etc.</p>
  <p>How the source and listener understand each other?  The answer is via an agreed-upon interface. For example, if a source is capable of firing an event called <code>XxxEvent</code> (e.g., <code>MouseEvent</code>) involving various operational modes (e.g., mouse-clicked, mouse-entered, mouse-exited, mouse-pressed, and mouse-released). Firstly, we need to declare an interface called <code>XxxListener</code> (e.g., <code>MouseListener</code>) containing the names of  the handler methods. Recall that an <code>interface</code> contains only <code>abstract</code> methods without implementation. For example,</p>
<pre class="color-example">
<span class="color-comment">// A MouseListener interface, which declares the signature of the handlers 
//  for the various operational modes.</span>
public <strong>interface MouseListener</strong> {
   public void <strong>mousePressed</strong>(MouseEvent evt);  <span class="color-comment">// Called back upon mouse-button pressed</span>
   public void <strong>mouseReleased</strong>(MouseEvent evt); <span class="color-comment">// Called back upon mouse-button released</span>
   public void <strong>mouseClicked</strong>(MouseEvent evt);  <span class="color-comment">// Called back upon mouse-button clicked (pressed and released)</span>
   public void <strong>mouseEntered</strong>(MouseEvent evt);  <span class="color-comment">// Called back when mouse pointer entered the component</span>
   public void <strong>mouseExited</strong>(MouseEvent evt);   <span class="color-comment">// Called back when mouse pointer exited the component</span>
}</pre>

<p>Secondly, all the listeners interested in the <code>XxxEvent</code> must implement the <code>XxxListener</code> interface. That is, the listeners must provide their own implementations (i.e., programmed responses) to all the <code>abstract</code> methods declared in the <code>XxxListener</code> interface. In this way, the listenser(s) can response to these events appropriately. For example,</p>

<pre class="color-example">
<span class="color-comment">// An example of MouseListener,  which provides implementation to the handler methods</span>
class MyMouseListener <strong>implement MouseListener</strong> {
   @Override
   public void <strong>mousePressed</strong>(MouseEvent e)  { 
      System.out.println(&quot;Mouse-button pressed!&quot;); 
   }
 
   @Override
   public void <strong>mouseReleased</strong>(MouseEvent e) {
      System.out.println(&quot;Mouse-button released!&quot;); 
   }
 
   @Override
   public void <strong>mouseClicked</strong>(MouseEvent e)  { 
      System.out.println(&quot;Mouse-button clicked (pressed and released)!&quot;); 
   }
 
   @Override
   public void <strong>mouseEntered</strong>(MouseEvent e)  { 
      System.out.println(&quot;Mouse-pointer entered the source component!&quot;); 
   }
 
   @Override
   public void <strong>mouseExited</strong>(MouseEvent e)   {
      System.out.println(&quot;Mouse exited-pointer the source component!&quot;);  
   }
}</pre>

<p>Thirdly, in the source, we need to maintain a list of listener object(s), and define two methods: <code>addXxxListener()</code> and <code>removeXxxListener()</code> to add and remove a listener from this list. The signature of the methods are:</p>

<pre class="color-syntax">
public void addXxxListener(XxxListener l);
public void removeXxxListener(XxxListener l);</pre>

<p>Take note that all the listener(s) interested in the <code>XxxEvent</code> must implement the <code>XxxListener</code> interface. That is, they are sub-type of the <code>XxxListener</code>. Hence, they can be upcasted to <code>XxxListener</code> and passed  as the argument of the above methods.</p>

<p>In summary, we identify the source, the event-listener interface,  and the listener object. The listener must implement the event-listener interface. The source object then registers listener object via the <code>addXxxListener()</code> method:</p>

<pre class="color-example">
<em>aSource</em>.addXxxListener(<em>alistener</em>);  <span class="color-comment">// <em>aSource</em> registers <em>aListener</em> for XxxEvent</span>
</pre>
</li>

<li>The source is  triggered by a user.</li>
<li>The source create an  <code>XxxEvent</code> object, which encapsulates the necessary information about the activation. For example, the <code>(x, y)</code> position of the mouse pointer, the text entered, etc.</li>

<li>Finally, for each of the listeners in the listener list, the source invokes the appropriate handler on the listener(s), which provides the programmed response.</li></ol>

<p>In brief, <em>triggering a source fires an event to all its registered listeners, and invoke an appropriate handler of the listener</em>.</p>

<h4>Revisit Example 1 <span class="font-code">AWTCounter</span>: <span class="font-code">ActionEvent</span> and <span class="font-code">ActionListener</span> Interface</h4>

<p>Clicking a <code>Button</code> (or hitting the &quot;Enter&quot; key on a <code>TextField</code>) fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s). An <code>ActionEvent</code> listener must implement <code>ActionListener</code> interface, which declares one <code>abstract</code> method <code>actionPerformed()</code> as follow:</p>

<pre class="color-syntax">
public interface ActionListener {
   public void <strong>actionPerformed</strong>(ActionEvent evt);
      <span class="color-comment">// Called back upon button-click (on Button), enter-key pressed (on TextField)</span>
}</pre>

<p>Here are the event-handling steps:</p>
<ul>
<li>We identify <code>btnCount</code> (<code>Button</code>) as the <em>source</em> object.</li>
<li>Clicking <code>Button</code> fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s).</li>

<li>The listener(s) is required to implement <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> method to provide the response. For simplicity, we choose &quot;<code>this</code>&quot; object (<code>AWTCounter</code>) as the <em>listener</em> for the <code>ActionEvent</code>. Hence, &quot;<code>this</code>&quot; class is required to implement <code>ActionListener</code> interface and provide the programmed response in the <code>actionPerformed()</code>.

  <pre class="color-example">
public class AWTCounter extends Frame <strong>implements ActionListener</strong> {
      <span class="color-comment">// &quot;this&quot; is chosen as the ActionEvent listener, hence, it is required 
      // to implement ActionListener interface</span>
   ......

   <span class="color-comment">// Implementing ActionListener interface requires this class to provide implementation
   // to the abstract method actionPerformed() declared in the interface.
</span>   @Override
   public void <strong>actionPerformed(ActionEvent evt)</strong> {
      <span class="color-comment">// Programmed response upon activation
      // Increment the count value and display on the TextField</span>
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }
}</pre>
</li>

<li>The source object registers listener via the <code>addActionListener()</code>.  In this example, the <em>source</em> <code>btnCount</code> (<code>Button</code>) adds &quot;<code>this</code>&quot; object as a <em>listener</em> via:

  <pre class="color-example">
btnCount.addActionListener(this);</pre>

<p>Note that <code>addActionListener()</code> takes an argument of the type <code>ActionListener</code>. &quot;<code>this</code>&quot;, which implements <code>ActionListener</code> interface (i.e., a subclass of <code>ActionListener</code>), is upcasted and passed to the <code>addActionListener()</code> method.</p>
</li>

<li>Upon button-click, the <code>btnCount</code> creates an <code>ActionEvent</code> object, and calls back the <code>actionPerformed(ActionEvent)</code> method of all its registered listener(s) with the <code>ActionEvent</code> object created:

  <pre class="color-example">
ActionEvent evt = new ActionEvent( ...... );<em>
listener</em>.actionPerformed(evt);   <span class="color-comment">// for all its listener(s)</span></pre>
</li>
</ul>

<p>The sequence diagram is as follows:</p>
<img class="image-center" src="images/AWT_ActionListener.png" alt="AWT_ActionListener.png" />
<img class="image-center" src="images/AWT_EventSeqDiagram.png" alt="AWT_EventSeqDiagram.png" />

<h4>Revisit Example 2 <span class="font-code">AWTAccumulator</span>: <span class="font-code">ActionEvent</span> and <span class="font-code">ActionListener</span> Interface</h4>

<p>In this example,</p>
<ol>
<li>We identify the <code>tfInput</code> (<code>TextField</code>) as the source object.</li>
<li>Hitting the &quot;Enter&quot; key on a <code>TextField</code> fires an <code>ActionEvent</code> to all its <code>ActionEvent</code> listener(s).</li>
<li>We choose <code>this</code> object as the <code>ActionEvent</code> listener (for simplicity).</li>
<li>The source object <code>tfInput</code> (<code>TextField</code>) registers the listener (<code>this</code> object) via the <code>tfInput.addActionListener(this)</code>.</li>
<li>The <code>ActionEvent</code> listener (<code>this</code> class) is required to implement the <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> method to provide the programmed response upon activation.</li>

</ol>

<h4>Example 3: <span class="font-code">WindowEvent</span> and <span class="font-code">WindowListener</span> Interface</h4>

<img class="image-float-right" src="images/AWT_WindowEventDemo.png" alt="AWT_WindowEventDemo.png" />

<p>A <code>WindowEvent</code> is fired (to all its <code>WindowEvent</code> listeners) when a window (e.g., <code>Frame</code>) has been opened/closed, activated/deactivated, iconified/deiconified via the 3 buttons at the top-right corner or other means. The source of  <code>WindowEvent</code> shall be a top-level window-container such as <code>Frame</code>.</p>

<p>A <code>WindowEvent</code> listener must implement <code>WindowListener</code> interface, which declares 7 <code>abstract</code> event-handling methods, as follows. Among them, the <code>windowClosing()</code>, which is called back upon clicking the window-close button, is the most commonly-used.</p>

<pre class="color-syntax float-clear">
public void <strong>windowClosing</strong>(WindowEvent evt)
   <span class="color-comment">// Called-back when the user attempts to close the window by clicking the window close button.
   // This is the most-frequently used handler.</span>
public void windowOpened(WindowEvent evt)
   <span class="color-comment">// Called-back the first time a window is made visible.</span>
public void windowClosed(WindowEvent evt)
   <span class="color-comment">// Called-back when a window has been closed as the result of calling dispose on the window.</span>
public void windowActivated(WindowEvent evt)
   <span class="color-comment">// Called-back when the Window is set to be the active Window.</span>
public void windowDeactivated(WindowEvent evt)
   <span class="color-comment">// Called-back when a Window is no longer the active Window.</span>
public void windowIconified(WindowEvent evt)
   <span class="color-comment">// Called-back when a window is changed from a normal to a minimized state.</span>
public void windowDeiconified(WindowEvent evt)
   <span class="color-comment">// Called-back when a window is changed from a minimized to a normal state.</span>
</pre>

<p>The following program added support for &quot;close-window button&quot; to Example 1: <code>AWTCounter</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></td>
<td>
<pre>
import java.awt.*;       <span class="color-comment"> // Using AWT containers and components</span>
import java.awt.event.*; <span class="color-comment"> // Using AWT events classes and listener interfaces</span>
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class <strong>WindowEventDemo</strong> extends Frame
      <span class="color-new">implements</span> ActionListener, <span class="color-new">WindowListener</span> {
     <span class="color-comment"> // This class acts as listener for ActionEvent and WindowEvent</span>
     <span class="color-comment"> // A Java class can extend</span> <span class="color-comment">one superclass, but can implement multiple interfaces.</span>
 
   private TextField tfCount;  <span class="color-comment">// Declare a TextField component</span>
   private Button btnCount;    <span class="color-comment">// Declare a Button component</span>
   private int count = 0;     <span class="color-comment"> // Counter's value</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemo() {
      setLayout(new FlowLayout());<span class="color-comment"> // &quot;super&quot; Frame sets to FlowLayout</span>
 
      add(new Label(&quot;Counter&quot;));  <span class="color-comment"> // &quot;super&quot; Frame adds an anonymous Label</span>
 
      tfCount = new TextField(&quot;0&quot;, 10);<span class="color-comment"> // Construct the TextField</span>
      tfCount.setEditable(false);      <span class="color-comment"> // read-only</span>
      add(tfCount);                    <span class="color-comment"> // &quot;super&quot; Frame adds TextField</span>
 
      btnCount = new Button(&quot;Count&quot;); <span class="color-comment"> // Construct the Button</span>
      add(btnCount);                  <span class="color-comment"> // &quot;super&quot; Frame adds Button</span>
 
      btnCount.addActionListener(this);
       <span class="color-comment"> // btnCount (source object) fires ActionEvent upon clicking</span>
       <span class="color-comment"> // btnCount adds &quot;this&quot; object as an ActionEvent listener</span>
 
      <span class="color-new">addWindowListener(this);</span>
       <span class="color-comment"> // &quot;super&quot; Frame (source object) fires WindowEvent.</span>
       <span class="color-comment"> // &quot;super&quot; Frame adds &quot;this&quot; object as a WindowEvent listener.</span>
 
      setTitle(&quot;WindowEvent Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(250, 100);           <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);            <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new WindowEventDemo(); <span class="color-comment"> // Let the construct do the job</span>
   }
 
   <span class="color-comment">/* ActionEvent handler */</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }
 
   <span class="color-comment">/* WindowEvent handlers */</span>
  <span class="color-comment"> // Called back upon clicking close-window button</span>
   <span class="color-new">@Override
   public void windowClosing(WindowEvent evt) {
      System.exit(0); <span class="color-comment"> // Terminate the program</span>
   }
 
  <span class="color-comment"> // Not Used, but need to provide an empty body to compile.</span>
   @Override public void windowOpened(WindowEvent evt) { }
   @Override public void windowClosed(WindowEvent evt) { }
   @Override public void windowIconified(WindowEvent evt) { }
   @Override public void windowDeiconified(WindowEvent evt) { }
   @Override public void windowActivated(WindowEvent evt) { }
   @Override public void windowDeactivated(WindowEvent evt) { }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example, we shall modify the earlier <code>AWTCounter</code> example to handle the <code>WindowEvent</code>. Recall that pushing the &quot;close-window&quot; button on the <code>AWTCounter</code> has no effect, as it did not handle the <code>WindowEvent</code> of <code>windowClosing()</code>. We included the <code>WindowEvent</code> handling codes in this example.</p>

<ol>
<li>We identify <code>super</code> <code>Frame</code> as the source object.</li>
<li>The <code>Frame</code> fires the <code>WindowEvent</code> to all its registered <code>WindowEvent</code> listener(s).</li>
<li>We select <code>this</code> object as the <code>WindowEvent</code> listener (for simplicity)</li>
<li>We register <code>this</code> object as the <code>WindowEvent</code> listener to the source <code>Frame</code> via method <code>addWindowListener(this)</code>.</li>
<li>The <code>WindowEvent</code> listener (<code>this</code> class) is required to implement the <code>WindowListener</code> interface, which declares 7 abstract methods: <code>windowOpened()</code>, <code>windowClosed()</code>, <code>windowClosing()</code>, <code>windowActivated()</code>, <code>windowDeactivated()</code>, <code>windowIconified()</code> and <code>windowDeiconified()</code>.</li>
<li>We override the <code>windowClosing()</code> handler to terminate the program using <code>System.exit(0)</code>. We ignore the other 6 handlers, but required to provide an empty body.</li>
</ol>

<p>The sequence diagram is as follow:</p>
<img class="image-center" src="images/AWT_WindowEventSeqDiagram.png" alt="AWT_WindowEventSeqDiagram.png" />

<h4 id="MouseEventDemo">Example 4: <span class="font-code">MouseEvent</span> and <span class="font-code">MouseListener</span> Interface</h4>
<p>A <code>MouseEvent</code> is fired to all its registered listeners, when you press, release, or click (press followed by release) a mouse-button (left or right button) at the source object; or position the mouse-pointer at (enter) and away (exit) from the source object.</p>

<p>A <code>MouseEvent</code> listener must implement the <code>MouseListener</code> interface, which declares the following five <code>abstract</code> methods:</p>
<pre class="color-syntax">
public void mouseClicked(MouseEvent evt)
   <span class="color-comment">// Called-back when the mouse-button has been clicked (pressed followed by released) on the source.</span>
public void mousePressed(MouseEvent evt)
public void mouseReleased(MouseEvent evt)
   <span class="color-comment">// Called-back when a mouse-button has been pressed/released on the source.
   // A mouse-click invokes mousePressed(), mouseReleased() and mouseClicked().</span>
public void mouseEntered(MouseEvent evt)
public void mouseExited(MouseEvent evt) 
   <span class="color-comment">// Called-back when the mouse-pointer has entered/exited the source.</span></pre>

<img class="image-center" src="images/AWT_MouseEventDemo.png" alt="AWT_MouseEventDemo.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
public class <strong>MouseEventDemo</strong> extends Frame <span class="color-new">implements MouseListener</span> {
   private TextField tfMouseX;<span class="color-comment"> // to display mouse-click-x</span>
   private TextField tfMouseY;<span class="color-comment"> // to display mouse-click-y</span>
 
  <span class="color-comment"> // Constructor - Setup the UI components and event handlers</span>
   public MouseEventDemo() {
      setLayout(new FlowLayout());<span class="color-comment"> // &quot;super&quot; frame sets its layout to FlowLayout</span>
 
     <span class="color-comment"> // Label (anonymous)</span>
      add(new Label(&quot;X-Click: &quot;));<span class="color-comment"> // &quot;super&quot; frame adds Label component</span>
 
     <span class="color-comment"> // TextField</span>
      tfMouseX = new TextField(10);<span class="color-comment"> // 10 columns</span>
      tfMouseX.setEditable(false); <span class="color-comment"> // read-only</span>
      add(tfMouseX);<span class="color-comment">                // &quot;super&quot; frame adds TextField component</span>
 
     <span class="color-comment"> // Label (anonymous)</span>
      add(new Label(&quot;Y-Click: &quot;));<span class="color-comment"> // &quot;super&quot; frame adds Label component</span>
 
     <span class="color-comment"> // TextField</span>
      tfMouseY = new TextField(10);
      tfMouseY.setEditable(false); <span class="color-comment"> // read-only</span>
      add(tfMouseY);<span class="color-comment">                // &quot;super&quot; frame adds TextField component</span>
 
      <span class="color-new">addMouseListener(this);</span>
         <span class="color-comment"> // &quot;super&quot; frame (source) fires the MouseEvent.</span>
         <span class="color-comment"> // &quot;super&quot; frame adds &quot;this&quot; object as a MouseEvent listener.</span>
 
      setTitle(&quot;MouseEvent Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(350, 100);          <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   public static void main(String[] args) {
      new MouseEventDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
 
  <span class="color-comment"> /* MouseEvent handlers */
   // Called back upon mouse clicked</span>
   <span class="color-new">@Override
   public void mouseClicked(MouseEvent evt) {
      tfMouseX.setText(evt.getX() + &quot;&quot;);
      tfMouseY.setText(evt.getY() + &quot;&quot;);
   }</span>
 
   <span class="color-comment">// Not used - need to provide an empty body to compile.</span>
   <span class="color-new">@Override public void mousePressed(MouseEvent evt) { }
   @Override public void mouseReleased(MouseEvent evt) { }
   @Override public void mouseEntered(MouseEvent evt) { }
   @Override public void mouseExited(MouseEvent evt) { }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example, we setup a GUI with 4 components (two <code>Label</code>s and two non-editable <code>TextField</code>s), inside a top-level container <code>Frame</code>, arranged in <code>FlowLayout</code>.</p>

<p>To demonstrate the <code>MouseEvent</code>:</p>
<ol>
<li>We identity <code>super</code> <code>Frame</code> as the source object.</li>
<li>The <code>Frame</code>  fires a <code>MouseEvent</code> to all its <code>MouseEvent</code> listener(s) when you click/press/release a mouse-button or enter/exit with the mouse-pointer.</li>
<li>We select <code>this</code> object as the <code>MouseEvent</code> listener (for simplicity).</li>
<li>We register <code>this</code> object as the <code>MouseEvent</code> listener to <code>super</code> <code>Frame</code> (source) via the method <code>addMouseListener(this)</code>.</li>
<li>The listener (<code>this</code> class) is required to implement the <code>MouseListener</code> interface, which declares 5 abstract methods: <code>mouseClicked()</code>, <code>mousePressed()</code>, <code>mouseReleased()</code>, <code>mouseEntered()</code>, and <code>mouseExit()</code>. We override the <code>mouseClicked()</code> to display the (x, y) co-ordinates of the mouse click on the two displayed <code>TextField</code>s. We ignore all the other handlers (for simplicity - but you need to provide an empty body for compilation).</li>
</ol>

<p><span class="line-heading">Try:</span> Include a <code>WindowListener</code> to handle the close-window button.</p>

<h4 id="MouseMotionDemo">Example 5: <span class="font-code">MouseEvent</span> and <span class="font-code">MouseMotionListener</span> Interface</h4>

<p>A <code>MouseEvent</code> is also fired when you moved and dragged the mouse pointer at the source object. But you need to use <code>MouseMotionListener</code> to handle the mouse-move and mouse-drag. The <code>MouseMotionListener</code> interface declares the following two abstract methods:</p>
<pre class="color-syntax">
public void mouseDragged(MouseEvent e)
   <span class="color-comment">// Called-back when a mouse-button is pressed on the source component and then dragged.</span>
public void mouseMoved(MouseEvent e)
   <span class="color-comment">// Called-back when the mouse-pointer has been moved onto the source component but no buttons have been pushed.</span></pre>

<img class="image-center" src="images/AWT_MouseMotionDemo.png" alt="AWT_MouseMotionDemo.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77</pre></td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class MouseMotionDemo extends Frame
      <span class="color-new">implements</span> MouseListener, <span class="color-new">MouseMotionListener</span> {
      <span class="color-comment">// This class acts as MouseListener and MouseMotionListener</span>
 
   <span class="color-comment">// To display the (x, y) of the mouse-clicked</span>
   private TextField tfMouseClickX;
   private TextField tfMouseClickY;
   <span class="color-comment">// To display the (x, y) of the current mouse-pointer position</span>
   private TextField tfMousePositionX;
   private TextField tfMousePositionY;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public MouseMotionDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; frame sets to FlowLayout</span>
 
      add(new Label(&quot;X-Click: &quot;));
      tfMouseClickX = new TextField(10);
      tfMouseClickX.setEditable(false);
      add(tfMouseClickX);
      add(new Label(&quot;Y-Click: &quot;));
      tfMouseClickY = new TextField(10);
      tfMouseClickY.setEditable(false);
      add(tfMouseClickY);
 
      add(new Label(&quot;X-Position: &quot;));
      tfMousePositionX = new TextField(10);
      tfMousePositionX.setEditable(false);
      add(tfMousePositionX);
      add(new Label(&quot;Y-Position: &quot;));
      tfMousePositionY = new TextField(10);
      tfMousePositionY.setEditable(false);
      add(tfMousePositionY);
 
      addMouseListener(this);
      <span class="color-new">addMouseMotionListener(this);</span>
        <span class="color-comment">// &quot;super&quot; frame (source) fires MouseEvent.</span>
        <span class="color-comment">// &quot;super&quot; frame adds &quot;this&quot; object as MouseListener and MouseMotionListener.</span>
 
      setTitle(&quot;MouseMotion Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(400, 120);            <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new MouseMotionDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/** MouseListener handlers */</span>
   <span class="color-comment">// Called back when a mouse-button has been clicked</span>
   @Override
   public void mouseClicked(MouseEvent evt) {
      tfMouseClickX.setText(evt.getX() + &quot;&quot;);
      tfMouseClickY.setText(evt.getY() + &quot;&quot;);
   }
 
   <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
   @Override public void mousePressed(MouseEvent evt) { }
   @Override public void mouseReleased(MouseEvent evt) { }
   @Override public void mouseEntered(MouseEvent evt) { }
   @Override public void mouseExited(MouseEvent evt) { }
 
   <span class="color-comment">/** MouseMotionEvent handlers */</span>
   <span class="color-comment">// Called back when the mouse-pointer has been moved</span>
   <span class="color-new">@Override
   public void mouseMoved(MouseEvent evt) {
      tfMousePositionX.setText(evt.getX() + &quot;&quot;);
      tfMousePositionY.setText(evt.getY() + &quot;&quot;);
   }
 
   <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
   @Override public void mouseDragged(MouseEvent evt) { }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example, we shall illustrate both the <code>MouseListener</code> and <code>MouseMotionListener</code>.</p>

<ol>
<li>We identify <code>super</code> <code>Frame</code> as the source, which fires the <code>MouseEvent</code> to its registered <code>MouseListener</code> and <code>MouseMotionListener</code><code></code>.</li>
<li>We select <code>this</code> object as the <code>MouseListener</code> and <code>MouseMotionListner</code> (for simplicity).</li>
<li>We register <code>this</code> object as the<code> </code>listener to <code>super</code> <code>Frame</code> via method <code>addMouseListener(this)</code> and <code>addMouseMotionListener(this)</code>.</li>
<li>The <code>MouseMotionListener</code> (<code>this</code> class) needs to implement 2 abstract methods: <code>mouseMoved()</code> and <code>mouseDragged()</code> declared in the <code>MouseMotionListener</code> interface.</li>
<li>We override the <code>mouseMoved()</code> to display the (x, y) position of the mouse pointer. We ignore the <code>MouseDragged()</code> handler by providing an empty body for compilation.</li>
</ol>

<p><span class="line-heading">Try:</span> Include a <code>WindowListener</code> to handle the close-window button.</p>

<h4 id="KeyEventDemo">Example 6: <span class="font-code">KeyEvent</span> and <span class="font-code">KeyListener</span> Interface</h4>

<p>A <code>KeyEvent</code> is fired (to all its registered <code>KeyListener</code>s) when you pressed, released, and typed (pressed followed by released) a key on the source object. A <code>KeyEvent</code> listener must implement <code>KeyListener</code> interface, which declares three abstract methods:</p>

<pre class="color-syntax">
public void keyTyped(KeyEvent e)
   <span class="color-comment">// Called-back when a key has been typed (pressed and released).</span>
public void keyPressed(KeyEvent e)
public void keyReleased(KeyEvent e)
   <span class="color-comment">// Called-back when a key has been pressed/released.</span></pre>

<img class="image-center" src="images/AWT_KeyEventDemo.png" alt="AWT_KeyEventDemo.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class KeyEventDemo extends Frame <span class="color-new">implements KeyListener</span> {
      <span class="color-comment">// This class acts as KeyEvent Listener</span>
 
   private TextField tfInput;  <span class="color-comment">// Single-line TextField to receive tfInput key</span>
   private TextArea taDisplay; <span class="color-comment">// Multi-line TextArea to taDisplay result</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public KeyEventDemo() {
      setLayout(new FlowLayout()); <span class="color-comment">// &quot;super&quot; frame sets to FlowLayout</span>
 
      add(new Label(&quot;Enter Text: &quot;));
      tfInput = new TextField(10);
      add(tfInput);
      taDisplay = new TextArea(5, 40); <span class="color-comment">// 5 rows, 40 columns</span>
      add(taDisplay);
 
      <span class="color-new">tfInput.addKeyListener(this);</span>
         <span class="color-comment">// tfInput TextField (source) fires KeyEvent.</span>
         <span class="color-comment">// tfInput adds &quot;this&quot; object as a KeyEvent listener.</span>
 
      setTitle(&quot;KeyEvent Demo&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(400, 200);         <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);          <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new KeyEventDemo();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/** KeyEvent handlers */</span>
   <span class="color-comment">// Called back when a key has been typed (pressed and released)</span>
   <span class="color-new">@Override
   public void keyTyped(KeyEvent evt) {
      taDisplay.append(&quot;You have typed &quot; + evt.getKeyChar() + &quot;\n&quot;);
   }
 
   <span class="color-comment">// Not Used, but need to provide an empty body for compilation</span>
   @Override public void keyPressed(KeyEvent evt) { }
   @Override public void keyReleased(KeyEvent evt) { }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this example:</p>

<ol>
<li>We identify the <code>tfInput</code> (<code>TextField</code>) as the source object.</li>
<li>The source fires a <code>KeyEvent</code> when you press/release/type a key to all its <code>KeyEvent</code> listener(s).</li>
<li>We select <code>this</code> object as the <code>KeyEvent</code> listener.</li>
<li>We register <code>this</code> object as the <code>KeyEvent</code> listener to the source <code>TextField</code> via method <code>input.addKeyListener(this)</code>.</li>
<li>The <code>KeyEvent</code> listener (<code>this</code> class) needs to implement the <code>KeyListener</code> interface, which declares 3 abstract methods: <code>keyTyped()</code>, <code>keyPressed()</code>, <code>keyReleased()</code>.</li>
<li>We override the <code>keyTyped()</code> to display key typed on the display <code>TextArea</code>. We ignore the <code>keyPressed()</code> and <code>keyReleased()</code>.</li>
</ol>

<h3>(Advanced) Observer Design Pattern</h3>

<img class="image-center" src="images/DesignPattern_Observer.png" alt="DesignPattern_Observer.png" />

<p>The <em>Observer</em> design pattern (aka <em>Publish-Subscribe</em> or <em>Observable-Observer</em>) is one of the 23 GoF's design patterns. Whenever the source's state changes, it notifies all its registered listener.</p>
<p>The source and listener are <em>bound</em> via the interface <code>XxxListener</code>, which defines a set of handlers. The source maintain a list of registered listeners, and two methods: <code>addXxxListener()</code> and <code>removeXxxListener()</code>. Both <code>addXxxListener()</code> and <code>removeXxxListener()</code> takes an argument of <code>XxxListener</code>. Hence, a listener object must implement <code>XxxListener</code> in order to be registered. Whenever the source's state changes, it invokes a particular handler of all the registered listeners. The interface guarantees the existence of such handler in the listener.</p>

<h4>Example: Creating  Your Own Event, Source and Listener</h4>
<p>Suppose that we have a source called <code>Light</code>, with two states - on and off. This source is capable of notifying its registered listener(s), whenever its state changes.</p>
<ul>
<li>First, we define the <code>LightEvent</code> class (extends from <code>java.util.EventObject</code>).</li>
<li>Next, we define a <code>LightListener</code> interface to <em>bind</em> the source and its listeners. This interface specifies the signature of the handlers, <code>lightOn(LightEvent)</code> and <code>lightOff(LightEvent)</code>.</li>
<li>In the source <code>Light</code>, we use an <code>ArrayList</code> to maintain its listeners, and create two methods: <code>addLightListner(LightListener)</code> and <code>removeLightListener(LightListener)</code>. An method called <code>notifyListener()</code> is written to invoke the appropriate handlers of each of its registered listeners, whenever the state of the <code>Light</code> changes.</li>
<li>A listener class called <code>LightWatcher</code> is written, which implements the <code>LightListener</code> interface and provides implementation for the handlers.</li>
</ul>

<h5>Event: <span class="font-code">LightEvent.java</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7</pre>
</td>
<td>
<pre>
<span class="color-comment">/** LightEvent */</span>
import java.util.EventObject;
public class <strong>LightEvent extends EventObject</strong> {
   public LightEvent (Object src) {
      super(src);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Listener Interface: <span class="font-code">LightListener.java</span></h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6</pre>
</td>
<td>
<pre>
<span class="color-comment">/** The LightListener interface define the expected behevior of LightEvent listeners */</span>
import java.util.EventListener;
public interface <strong>LightListener extends EventListener</strong> {
   public void lightOn(LightEvent evt);  <span class="color-comment">// Called-back upon light on</span>
   public void lightOff(LightEvent evt); <span class="color-comment">// Called-back upon light off</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Source: <span class="font-code">Light.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre>
</td>
<td>
<pre>
<span class="color-comment">/** The Light Source, which maintains a list of listeners and fires LightEvent to its listeners */</span>
import java.util.*;
public class <strong>Light</strong> {
   <span class="color-comment">// Status - on (true) or off (false)</span>
   private boolean on;
   <span class="color-comment">// Listener list</span>
   private List&lt;LightListener&gt; listeners = new ArrayList&lt;LightListener&gt;();
 
   <span class="color-comment">/** Constructor */</span>
   public Light() {
      on = false;   <span class="color-comment">// initially off</span>
      System.out.println(&quot;Light: constructed and off&quot;);
   }
 
   <span class="color-comment">/** Add the given LightListener */</span>
   public void addLightListener(LightListener listener) {
      listeners.add(listener);
      System.out.println(&quot;Light: added a listener&quot;);
   }
 
   <span class="color-comment">/** Remove the given LightListener */</span>
   public void removeLightListener(LightListener listener) {
      listeners.remove(listener);
      System.out.println(&quot;Light: removed a listener&quot;);
   }
 
   <span class="color-comment">/** Turn on this light */</span>
   public void turnOn() {
      if (!on) {
         on = !on;
         System.out.println(&quot;Light: turn on&quot;);
         notifyListener();
      }
   }
 
   <span class="color-comment">/** Turn off this light */</span>
   public void turnOff() {
      if (on) {
         on = !on;
         System.out.println(&quot;Light: turn off&quot;);
         notifyListener();
      }
   }
 
   <span class="color-comment">/** Construct an LightEvent and trigger the appropriate handler on its registered listeners */</span>
   private void notifyListener() {
      LightEvent evt = new LightEvent(this);
      for (LightListener listener : listeners) {
         if (on) {
            listener.lightOn(evt);
         } else {
            listener.lightOff(evt);
         }
      }
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>A Listener: <span class="font-code">LightWatcher.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td>
<pre>
<span class="color-comment">/** A LightEvent listener, which is required to implement LightListener interface. */</span>
public class <strong>LightWatcher implements LightListener</strong> {
   private int id;  <span class="color-comment">// ID of this listener</span>
 
   <span class="color-comment">/** Constructor */</span>
   public LightWatcher(int id) {
      this.id = id;
      System.out.println(&quot;LightWatcher-&quot; + id + &quot;: created&quot;);
   }
 
   <span class="color-comment">/** LightEvent handlers - Called back with LightEvent is fired */</span>
   @Override
   public void lightOn(LightEvent evt) {
      System.out.println(&quot;LightWatcher-&quot; + id
         + &quot;: I am notified that light is on&quot;);
   }
 
   @Override
   public void lightOff(LightEvent evt) {
      System.out.println(&quot;LightWatcher-&quot; + id
         + &quot;: I am notified that light is off&quot;);
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>A Test Driver: <span class="font-code">TestLight.java</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre>
</td>
<td>
<pre>
<span class="color-comment">/** A Test Driver */</span>
public class <strong>TestLight</strong> {
   public static void main(String[] args) {
      Light light = new Light();
      LightWatcher lw1 = new LightWatcher(1);
      LightWatcher lw2 = new LightWatcher(2);
      LightWatcher lw3 = new LightWatcher(3);
      light.addLightListener(lw1);
      light.addLightListener(lw2);
      light.turnOn();
      light.addLightListener(lw3);
      light.turnOff();
      light.removeLightListener(lw1);
      light.removeLightListener(lw3);
      light.turnOn();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The expected outputs are:</p>
<pre class="output">
Light: constructed and off
LightWatcher-1: created
LightWatcher-2: created
LightWatcher-3: created
Light: added a listener
Light: added a listener
Light: turn on
LightWatcher-1: I am notified that light is on
LightWatcher-2: I am notified that light is on
Light: added a listener
Light: turn off
LightWatcher-1: I am notified that light is off
LightWatcher-2: I am notified that light is off
LightWatcher-3: I am notified that light is off
Light: removed a listener
Light: removed a listener
Light: turn on
LightWatcher-2: I am notified that light is on</pre>

<h3 id="innerclass">Nested (Inner) Classes</h3>
<p>A <em>nested class</em> (or commonly called <em>inner class</em>) is <em>a class defined inside another class</em> - introduced in JDK 1.1.  As an illustration, two nested classes <code>MyNestedClass1</code> and <code>MyNestedClass2</code> are defined <em>inside</em> the definition of an outer class called <code>MyOuterClass</code>.</p>

<pre class="color-example">
public <span class="color-new">class</span> MyOuterClass {   <span class="color-comment">// outer class defined here</span>
   ......
   private <span class="color-new">class</span> MyNestedClass1 { ...... }  <span class="color-comment">// an nested class defined inside the outer class</span>
   public static <span class="color-new">class</span> MyNestedClass2 { ...... }  <span class="color-comment">// an &quot;static&quot; nested class defined inside the outer class</span>
   ......
}</pre>

<p>A nested class has these properties:</p>

<ol>
<li>A nested class is a proper class. That is, it could contain constructors, member variables and member methods. You can create an instance of a nested class via the <code>new</code> operator and constructor.</li>
<li>A nested class is a <em>member</em> of the outer class, just like any member variables and methods defined inside a class.</li>

<li>Most importantly, a nested class can access the <code>private</code> members (variables/methods) of the enclosing outer class, as it is at the <em>same level</em> as these <code>private</code> members. This is the property that makes inner class useful.</li>
<li>A nested class can have <code>private</code>, <code>public</code>, <code>protected</code>, or the <em>default</em> access, just like any member variables and methods defined inside a class. A <code>private</code> inner class is only accessible by the enclosing outer class, and is not accessible by any other classes.  [An top-level outer class cannot be declared <code>private</code>, as no one can use a <code>private</code> outer class.]</li>
<li>A nested class can also be declared <code>static</code>, <code>final</code> or <code>abstract</code>, just like any ordinary class.</li>

<li>A nested class is NOT a <em>subclass</em> of the outer class.  That is, the nested class does not inherit the variables and methods of the outer class.  It is an <em>ordinary</em> self-contained class. [Nonetheless, you could declare it as a subclass of the outer class, via keyword &quot;<code>extends <em>OuterClassName</em></code>&quot;, in the nested class's definition.]</li>
</ol>

<p>The usages of nested class are:</p>
<ol>
<li>To control visibilities (of the member variables and methods) between inner/outer class.  The nested class, being defined inside an outer class, can access <code>private</code> members of the outer class.</li>
<li>To place a piece of class definition codes <em>closer</em> to where it is going to be used, to make the program clearer and easier to understand.</li>
<li>For namespace management.</li>
</ol>

<h4>Example 7: A Named Inner Class as Event Listener</h4>

<p>A nested class is useful if you need a <em>small</em> class which relies on the enclosing outer class for its private variables and methods.  It is ideal in an event-driven environment for implementing event handlers.  This is because the event handling methods (in a listener) often require access to the private variables (e.g., a private <code>TextField</code>) of the outer class.</p>

<p>In this example (modified from Example 1 <code>AWTCounter</code>), instead of using &quot;<code>this</code>&quot; as the <code>ActionEvent</code> listener for the <code>Button</code>, we define a new class called <code>BtnCountListener</code>, and create an  instance of <code>BtnCountListener</code> as the <code>ActionEvent</code> listener for the <code>btnCount</code>. The <code>BtnCountListener</code> needs to implement the <code>ActionListener</code> interface, and override the <code>actionPerformed()</code> handler. Since &quot;<code>this</code>&quot; is no long a <code>ActionListener</code>, we remove the &quot;<code>implements ActionListener</code>&quot; from &quot;<code>this</code>&quot; class's definition.</p>
<p><code>BtnCountListener</code> needs to be defined as an inner class, as it needs to access private variables (<code>count</code> and <code>tfCount</code>) of the outer class.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class AWTCounterNamedInnerClass extends Frame {
   <span class="color-comment">// This class is NOT a ActionListener, hence, it does not implement ActionListener interface</span>
 
   <span class="color-comment">// The event-handler actionPerformed() needs to access these &quot;private&quot; variables</span>
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounterNamedInnerClass () {
      setLayout(new FlowLayout());  <span class="color-comment">// &quot;super&quot; Frame sets to FlowLayout</span>
      add(new Label(&quot;Counter&quot;));    <span class="color-comment">// An anonymous instance of Label</span>
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);   <span class="color-comment">// read-only</span>
      add(tfCount);                 <span class="color-comment">// &quot;super&quot; Frame adds tfCount</span>
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);                <span class="color-comment">// &quot;super&quot; Frame adds btnCount</span>
 
      <span class="color-comment">// Construct an anonymous instance of BtnCountListener (a named inner class).</span>
      <span class="color-comment">// btnCount adds this instance as a ActionListener.</span>
      <span class="color-new">btnCount.addActionListener(new BtnCountListener());</span>
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounterNamedInnerClass(); <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnCountListener is a &quot;named inner class&quot; used as ActionListener.
    * This inner class can access private variables of the outer class.
    */</span>
   <span class="color-new">private class BtnCountListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         ++count;
         tfCount.setText(count + &quot;&quot;);
      }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>An inner class named <code>BtnCountListener</code> is used as the <code>ActionListner</code>.</li>
<li>An anonymous instance of the <code>BtnCountListener</code> inner class is constructed. The <code>btnCount</code> source object adds this instance as a listener, as follows:
  <pre class="color-example">
btnCount.addActionListener(new BtnCountListener());
</pre>
</li>

<li>The inner class can access the <code>private</code> variable <code>tfCount</code> and <code>count</code> of the outer class.</li>
<li>Since &quot;<code>this</code>&quot; is no longer a listener, we remove the &quot;<code>implements ActionListener</code>&quot; from <code>this</code> class' definition.</li>
<li>The inner class is compiled into <code>AWTCount$BtnCountListener.class</code>, in the format of <code><em>OuterClassName$InnerClassName</em>.class</code>.</li>
</ul>

<h5>Using an Ordinary (Outer) Class as Listener</h5>
<p>Try moving the <code>BtnCountListener</code> class outside, and define it as an ordinary class. You would need to pass a reference of the <code>AWTConnter</code> into the constructor of <code>BtnCountListener</code>, and use this reference to access variables <code>tfCount</code> and <code>count</code>, through <code>public</code> getters or granting them to <code>public</code> access.</p>
<pre class="color-example">
<span class="color-comment">// An ordinary outer class used as ActionListener for the Button</span>
public class BtnCountListener implements ActionListener {
   AWTCounter frame;
   public BtnCountListener(AWTCounter frame) {
      this.frame = frame;
   }
   
   @Override
   public void actionPerformed(ActionEvent evt) {
      frame.count++;
      frame.tfCount.setText(frame.count + &quot;&quot;);
   }
}</pre>

<p>This code is messy!</p>

<h4>Example 8: An Anonymous Inner Class as Event Listener</h4>

<p>Instead of using a <em>named inner class</em> (called <code>BtnCountListner</code> in the previous example), we shall use an inner class without a name, known as <em>anonymous inner class</em> as the <code>ActionListener</code> in this example.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits from the top-level container java.awt.Frame</span>
public class AWTCounterAnonymousInnerClass extends Frame {
   <span class="color-comment">// This class is NOT a ActionListener, hence, it does not implement ActionListener interface</span>
 
   <span class="color-comment">// The event-handler actionPerformed() needs to access these private variables</span>
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounterAnonymousInnerClass () {
      setLayout(new FlowLayout());  <span class="color-comment">// &quot;super&quot; Frame sets to FlowLayout</span>
      add(new Label(&quot;Counter&quot;));    <span class="color-comment">// An anonymous instance of Label</span>
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);   <span class="color-comment">// read-only</span>
      add(tfCount);                 <span class="color-comment">// &quot;super&quot; Frame adds tfCount</span>
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);                <span class="color-comment">// &quot;super&quot; Frame adds btnCount</span>
 
      <span class="color-comment">// Construct an anonymous instance of an anonymous class.</span>
      <span class="color-comment">// btnCount adds this instance as a ActionListener.</span>
      btnCount.addActionListener(<span class="color-new">new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      }</span>);
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounterAnonymousInnerClass(); <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>
<ul>
<li>Again, &quot;<code>this</code>&quot; class is NOT used as the <code>ActionEvent</code> listener. Hence, we remove the &quot;<code>implements ActionListener</code>&quot; from <code>this</code> class' definition.</li>
<li>The anonymous inner class is given a name generated by the compiler, and compiled into <code><em>OuterClassName</em>$<em>n</em>.class</code>, where <em><code>n</code></em> is a running number of the inner classes of this outer class.</li>

<li>An anonymous instance of an anonymous inner class is constructed, and passed as the argument of the <code>addActionListener()</code> method as follows:

<pre class="color-example">
btnCount.addActionListener(<span class="color-new">new ActionListener() {
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }
}</span>);</pre>

<p>The above codes is equivalent to and compiled as:</p>
<pre class="color-example">
private class <em><strong>N</strong></em> implements ActionListener {  <span class="color-comment">// <em>N</em> is a running number of the inner classes created</span>
   @Override
   public void actionPerformed(ActionEvent evt) {
      ++count;
      tfCount.setText(count + &quot;&quot;);
   }
}
btnCount.addActionListener(new <em><strong>N</strong></em>());

<span class="color-comment">// Or</span>
<em><strong>N</strong></em> <strong><em>n</em></strong> = new <em><strong>N</strong></em>()
btnCount.addActionListener(<strong><em>n</em></strong>);</pre></li>
</ul>

<h5>Properties of Anonymous Inner Class</h5>
<ol>
<li>The anonymous inner class is define inside a method, instead of a member of the outer class (class member). It is <em>local</em> to the method and cannot be marked with access modifier (such as <code>public</code>, <code>private</code>) or <code>static</code>, just like any local variable of a method.</li>

<li>An anonymous inner class must always extend a superclass or implement an interface. The keyword &quot;<code>extends</code>&quot; or &quot;<code>implements</code>&quot; is NOT required in its declaration. An anonymous inner class must implement all the abstract methods in the superclass or in the interface.</li>
<li>An anonymous inner class always uses the default (no-arg) constructor from its superclass to create an instance. If an anonymous inner class implements an interface, it uses the <code>java.lang.Object()</code>.</li>
<li>An anonymous inner class is compiled into a class named <code>OuterClassName$<em>n</em>.class</code>, where <code><em>n</em></code> is a running number of inner classes within the outer class.</li>
<li>An instance of an anonymous inner class is constructed via this syntax:
<pre class="color-syntax">
new <em>SuperClassName</em>/<em>InterfaceName</em>() {  <span class="color-comment">// extends superclass or implements interface
                                      // invoke the default no-arg constructor or Object[]</span>
  <span class="color-comment">// Implement abstract methods in superclass/interface
  // More methods if necessary
  ......</span>
}</pre>

<p>The created instance can be assigned to a variable or used as an argument of a method.</p>
</li>
</ol>

<h4>Example 9: An Anonymous Inner Class for Each Source</h4>

<img class="image-float-right" src="images/AWT_Counter3Buttons.png" alt="AWT_Counter3Buttons.png" />
<p>Let's modify our <code>AWTCounter</code> example to include 3 buttons for counting up, counting down, and reset the count, respectively. We shall attach an anonymous inner class as the listener to each of buttons.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre></td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTCounter3Buttons extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3Buttons () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));   <span class="color-comment">// an anonymous instance of Label</span>
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfCount);                <span class="color-comment">// &quot;super&quot; Frame adds tfCount</span>
 
      btnCountUp = new Button(&quot;Count Up&quot;);
      add(btnCountUp);
      <span class="color-comment">// Construct an anonymous instance of an anonymous inner class.</span>
      <span class="color-comment">// The source Button adds the anonymous instance as ActionEvent listener</span>
      <span class="color-new">btnCountUp.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });</span>
 
      btnCountDown = new Button(&quot;Count Down&quot;);
      add(btnCountDown);
      <span class="color-new">btnCountDown.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            count--;
            tfCount.setText(count + &quot;&quot;);
         }
      });</span>
 
      btnReset = new Button(&quot;Reset&quot;);
      add(btnReset);
      <span class="color-new">btnReset.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            count = 0;
            tfCount.setText(&quot;0&quot;);
         }
      });</span>
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3Buttons();  <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Dissecting the Program</h5>

<ol>
<li>Each of the <code>Button</code>s uses an anonymous instance of an anonymous inner class as its <code>ActionEvent</code> listener.</li>
</ol>

<h4>Example 10: Using the Same Listener Instance for All the Buttons</h4>

<p>If you use the same instance as the listener for the 3 buttons, you need to determine which button has fired the event. It is because all the 3 buttons trigger the same event-handler method.</p>

<h5>Using <span class="font-code">ActionEvent</span>'s <span class="font-code">getActionCommand()</span></h5>

<p>In the following example, we use the same instance of a named inner class as the listener for all the 3 buttons. The listener needs to determine which button has fired the event. This can be accomplished via the <code>ActionEvent</code>'s <code>getActionCommonad()</code> method, which returns the button's label.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTCounter3Buttons1Listener extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3Buttons1Listener () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      <span class="color-comment">// Construct Buttons</span>
      btnCountUp = new Button(&quot;Count Up&quot;);
      add(btnCountUp);
      btnCountDown = new Button(&quot;Count Down&quot;);
      add(btnCountDown);
      btnReset = new Button(&quot;Reset&quot;);
      add(btnReset);
 
      <span class="color-comment">// Allocate an instance of named inner class BtnListener.</span>
      BtnListener listener = new BtnListener();
      <span class="color-comment">// Use the same listener instance to all the 3 Buttons.</span>
      btnCountUp.addActionListener(listener);
      btnCountDown.addActionListener(listener);
      btnReset.addActionListener(listener);
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3Buttons1Listener();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnListener is a named inner class used as ActionEvent listener for all the Buttons.
    */</span>
   <span class="color-new">private class BtnListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Need to determine which button fired the event.</span>
         <span class="color-comment">// the getActionCommand() returns the Button's label</span>
         String btnLabel = evt.getActionCommand();
         if (btnLabel.equals(&quot;Count Up&quot;)) {
            ++count;
         } else if (btnLabel.equals(&quot;Count Down&quot;)) {
            --count;
         } else {
            count = 0;
         }
         tfCount.setText(count + &quot;&quot;);
      }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Using <span class="font-code">getSource()</span> of <span class="font-code">EventObject</span></h5>
<p>Besides the <code>getActionCommand()</code>, which is only available for <code>ActionEvent</code>, you can use the <code>getSource()</code> method, which is available to all event objects, to retrieve a reference to the source object that has fired the event. <code>getSource()</code> returns a <code>java.lang.Object</code>. You may need to downcast it to the proper type of the source object. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
public class AWTCounter3ButtonsGetSource extends Frame {
   private TextField tfCount;
   private Button btnCountUp, btnCountDown, btnReset;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public AWTCounter3ButtonsGetSource () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      <span class="color-comment">// Construct Buttons</span>
      btnCountUp = new Button(&quot;Count Up&quot;);
      add(btnCountUp);
      btnCountDown = new Button(&quot;Count Down&quot;);
      add(btnCountDown);
      btnReset = new Button(&quot;Reset&quot;);
      add(btnReset);
 
      <span class="color-comment">// Allocate an instance of inner class BtnListener.</span>
      BtnListener listener = new BtnListener();
      <span class="color-comment">// Use the same listener instance to all the 3 Buttons.</span>
      btnCountUp.addActionListener(listener);
      btnCountDown.addActionListener(listener);
      btnReset.addActionListener(listener);
 
      setTitle(&quot;AWT Counter&quot;);
      setSize(400, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new AWTCounter3ButtonsGetSource();  <span class="color-comment">// Let the constructor do the job</span>
   }
 
   <span class="color-comment">/**
    * BtnListener is a named inner class used as ActionEvent listener for all the Buttons.
    */</span>
   <span class="color-new">private class BtnListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent evt) {
         <span class="color-comment">// Need to determine which button has fired the event.</span>
         Button source = (Button)evt.getSource();
               <span class="color-comment">// Get a reference of the source that has fired the event.</span>
               <span class="color-comment">// getSource() returns a java.lang.Object. Downcast back to Button.</span>
         if (source == btnCountUp) {
            ++count;
         } else if (source == btnCountDown) {
            --count;
         } else {
            count = 0;
         }
         tfCount.setText(count + &quot;&quot;);
      }
   }</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h3>(Advanced) More on Nested Classes</h3>
<p>There are 4 types of nested classes:</p>
<ol>
<li><code>static</code> nested class (as a outer class member),</li>
<li>non-<code>static</code> (instance) inner class (as a outer class member),</li>
<li>local inner class (defined inside a method),</li>
<li>anonymous local inner class (defined inside a method).</li>
</ol>

<h4>Static vs. Instance Nested Classes</h4>
<p>A nested class can be declared <code>static</code> (belonging to the class instead of an instance). Recall that a <code>static</code> member can be used without instantiating the class and can be referenced via the classname in the form of <code><em>Classname.memberName</em></code> (e.g., <code>Math.PI</code>, <code>Integer.parseInt()</code>). Similarly, a <code>static</code> nested class can be used without instantiating the outer class and can be referenced via <code><em>OuterClassName.InnerClassName</em></code>.</p>
<p>On the other hand, a non-<code>static</code> nested class belongs to an instance of the outer class, just like any instance variable or method. It can be referenced via <code><em>outerClassInstanceName.innerClassInstanceName</em></code>. A non-<code>static</code> nested class is formally called an <em>inner class</em>.</p>

<h5>Example of non-<span class="font-code">static</span> (instance) inner class</h5>

<p>In this example, a non-<code>static</code> (instance) inner class called <code>MyInnerClass</code> is defined inside the outer class. The inner class can access <code>private</code> members (variables/methods) of the outer class. This outer class also declares and constructs an instance of inner class as its member variable.</p>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td>
<pre>
public class MyOuterClassWithInnerClass {
   <span class="color-comment">// Private member variable of the outer class</span>
   private String msgOuter = &quot;Hello from outer class&quot;;
 
   <span class="color-comment">// Define an inner class as a member of the outer class</span>
   <span class="color-comment">// This is merely an definition.</span>
   <span class="color-comment">// Not instantiation takes place when an instance of outer class is constructed</span>
   <span class="color-new">public class MyInnerClass {</span>
      <span class="color-comment">// Private variable of the inner class</span>
      private String msgInner;
      <span class="color-comment">// Constructor of the inner class</span>
      public MyInnerClass(String msgInner) {
         this.msgInner = msgInner;
         System.out.println(&quot;Constructing an inner class instance: &quot; + msgOuter);
               <span class="color-comment">// can access private member variable of outer class</span>
      }
      <span class="color-comment">// A method of inner class</span>
      public void printMessage() {
         System.out.println(msgInner);
      }
   <span class="color-new">}</span>
 
   <span class="color-comment">// Declare and construct an instance of the inner class, inside the outer class</span>
   <span class="color-new">MyInnerClass anInner = new MyInnerClass(&quot;Hi from inner class&quot;);</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>Two class files are produced: <code>MyOuterClassWithInnerClass.class</code> and <code>MyOuterClassWithInnerClass$MyInnerClass.class</code>.</p>

<p>The following test program:</p>
<ol>
<li>Allocates an instance of outer class, which implicitly allocates an inner class (called <code>anInner</code>) as its member variable. You can access this inner class via <code><em>outerClassInstanceName.innerClassInstanceName</em></code>.</li>

<li>Explicitly constructs another instance of the inner class, under the same outer class instance created in the previous step.</li>
<li>Explicitly constructs one more instance of the inner class, under a new instance of outer class. This new outer class instance also implicitly allocates an inner class instance as its member, as seen from the output.</li>
</ol>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre>
</td>
<td>
<pre>
public class TestInnerClass {
   public static void main(String[] args) {
      <span class="color-comment">// Construct an instance of outer class, which create anInner</span>
      MyOuterClassWithInnerClass anOuter = new MyOuterClassWithInnerClass();
      <span class="color-comment">// Invoke inner class's method from this outer class instance</span>
      anOuter.anInner.printMessage();
 
      <span class="color-comment">// Explicitly construct another instance of inner class</span>
      MyOuterClassWithInnerClass.MyInnerClass inner2
           = anOuter.new MyInnerClass(&quot;Inner class 2&quot;);
      inner2.printMessage();
 
      <span class="color-comment">// Explicitly construct an instance of inner class, under another instance of outer class</span>
      MyOuterClassWithInnerClass.MyInnerClass inner3
           = new MyOuterClassWithInnerClass().new MyInnerClass(&quot;Inner class 3&quot;);
      inner3.printMessage();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Constructing an inner class instance: Hello from outer class
Hi from inner class
Constructing an inner class instance: Hello from outer class
Inner class 2
Constructing an inner class instance: Hello from outer class
Constructing an inner class instance: Hello from outer class
Inner class 3</pre>

<p>An inner class definition is merely a definition of a class. The outer class does not create an inner class instance, when it is instantiated. Nonetheless, you could declare it as member of the outer class, as illustrated in the above example. In many situations, we declare the inner class <code>private</code>. In this cases, the inner class can only be used (declare and construct) within the outer class.</p>

<p>You can set the inner class to <code>private</code> access. In this case, the inner class can only be accessed within the outer class, and not by other classes.</p>

<h5>Example of <span class="font-code">static</span> nested class</h5>

<p>In this example, a <code>static</code> nested class is defined inside the outer class, which can access the <code>private</code> <code>static</code> variables of the outer class.</p>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td>
<pre>
public class MyOuterClassWithStaticNestedClass {
   <span class="color-comment">// Private &quot;static&quot; member variable of the outer class</span>
   private static String msgOuter = &quot;Hello from outer class&quot;;
 
   <span class="color-comment">// Define a &quot;static&quot; nested class as a member of the outer class</span>
   <span class="color-comment">// It can access private &quot;static&quot; variable of the outer class</span>
   <span class="color-new">public static class MyStaticNestedClass {</span>
      <span class="color-comment">// Private variable of inner class</span>
      private String msgInner;
      <span class="color-comment">// Constructor of inner class</span>
      public MyStaticNestedClass(String msgInner) {
         this.msgInner = msgInner;
         System.out.println(msgOuter); <span class="color-comment">// access private member of the outer class</span>
      }
      <span class="color-comment">// A method of inner class</span>
      public void printMessage() {
         System.out.println(msgInner);
      }
   <span class="color-new">}</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p>You can access the <code>static</code> nested class via the outer classname, in the form of <code><em>OuterClassName.NestedClassName</em></code>, just like any static variables/methods (e.g., <code>Math.PI</code>, <code>Integer.parseInt()</code>). You can instantiate a <code>static</code> nested class without instantiate the outer class, as <code>static</code> members are associated with the class, instead of instances.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10</pre>
</td>
<td>
<pre>
public class TestStaticNestedClass {
   public static void main(String[] args) {
      <span class="color-comment">// Construct an instance of static nested class</span>
      <span class="color-comment">// A &quot;static&quot; nested class, like other &quot;static&quot; members, can be accessed via</span>
      <span class="color-comment">// the Classname.membername</span>
      MyOuterClassWithStaticNestedClass.MyStaticNestedClass aNestedInner =
            new MyOuterClassWithStaticNestedClass.MyStaticNestedClass(&quot;Hi from inner class&quot;);
      aNestedInner.printMessage();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Hello from outer class
Hi from inner class</pre>

<p>As seen from the example, a <code>static</code> nested class is really like a top-level class with a modified name (<em><code>OuterClassname</code></em><code>.<em>InnerClassname</em></code>). It can be used as an extension to package for <em>namespace management</em>.</p>

<h4>Local Inner Class Defined Inside a Method</h4>
<p>Java allows you to define an inner class inside a method, just like defining a method's local variable. Like local variable, a local inner class does not exist until the method is invoked, and goes out of scope when the method exits.</p>

<p>A local inner class has these properties:</p>
<ol>
<li>A local inner class cannot have access modifier (such as <code>private</code> or <code>public</code>). It also cannot be declared <code>static</code>.</li>
<li>A local inner class can access all the variables/methods of the enclosing outer class.</li>
<li>A local inner class can have access to the local variables of the enclosing method only if they are declared <code>final</code> (to prevent undesirable side-effects).</li>
</ol>

<h5>Example</h5>
<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre>
</td>
<td>
<pre>
public class MyOuterClassWithLocalInnerClass {
   <span class="color-comment">// Private member variable of the outer class</span>
   private String msgOuter = &quot;Hello from outer class&quot;;
 
   <span class="color-comment">// A member method of the outer class</span>
   public void doSomething() {
 
      <span class="color-comment">// A local variable of the method</span>
      final String msgMethod = &quot;Hello from method&quot;;
 
      <span class="color-comment">// Define a local inner class inside the method</span>
      class MyInnerClass {
         <span class="color-comment">// Private variable of the inner class</span>
         private String msgInner;
         <span class="color-comment">// Constructor of the inner class</span>
         public MyInnerClass(String msgInner) {
            this.msgInner = msgInner;
            System.out.println(&quot;Constructing an inner class instance: &quot; + msgOuter);
               <span class="color-comment">// can access private member variable of outer class</span>
            System.out.println(&quot;Accessing final variable of the method: &quot; + msgMethod);
               <span class="color-comment">// can access final variable of the method</span>
         }
         <span class="color-comment">// A method of inner class</span>
         public void printMessage() {
            System.out.println(msgInner);
         }
      }
 
      <span class="color-comment">// Create an instance of inner class and invoke its method</span>
      MyInnerClass anInner = new MyInnerClass(&quot;Hi, from inner class&quot;);
      anInner.printMessage();
   }
 
   <span class="color-comment">// Test main() method</span>
   public static void main(String[] args) {
       <span class="color-comment">// Create an instance of the outer class and invoke the method.</span>
       new MyOuterClassWithLocalInnerClass().doSomething();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Constructing an inner class instance: Hello from outer class
Accessing final variable of the method: Hello from method
Hi, from inner class</pre>

<h4>An Anonymous Inner Class</h4>
<p>An anonymous inner class is a local inner class (of a method) without assigning an explicit classname. It must either &quot;<code>extends</code>&quot; an existing superclass or &quot;<code>implements</code>&quot; an interface. It is declared and instantiated in one statement via the <code>new</code> keyword.</p>

<h5>Example</h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td>
<pre>
public class MyOuterClassWithAnonymousInnerClass {
   <span class="color-comment">// Private member variable of the outer class</span>
   private String msgOuter = &quot;Hello from outer class&quot;;
 
   <span class="color-comment">// A member method of the outer class</span>
   public void doSomething() {
      <span class="color-comment">// A local variable of the method</span>
      final String msgMethod = &quot;Hello from method&quot;;
 
      Thread thread = new Thread() { <span class="color-comment">// create an instance of an anonymous inner class that extends Thread class</span>
         @Override
         public void run() {
            System.out.println(&quot;Constructing an inner class instance: &quot; + msgOuter);
               <span class="color-comment">// can access private member variable of outer class</span>
            System.out.println(&quot;Accessing final variable of the method: &quot; + msgMethod);
               <span class="color-comment">// can access final variable of the method</span>
            System.out.println(&quot;Hi, from inner class!&quot;);
         }
      };
      thread.start();
   }
 
   <span class="color-comment">// Test main() method</span>
   public static void main(String[] args) {
       <span class="color-comment">// Create an instance of the outer class and invoke the method.</span>
       new MyOuterClassWithAnonymousInnerClass().doSomething();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">
Constructing an inner class instance: Hello from outer class
Accessing final variable of the method: Hello from method
Hi, from inner class</pre>

<p>The anonymous inner class definition is equivalent to:</p>
<pre class="color-example">
public void doSomething()
   ......
   class <em>OuterClassName.n</em> extends Thread {  <span class="color-comment">// where <em>n</em> is a running number of anonymous inner classes</span>
      ......
   }
   Thread thread = new <em>OuterClassName.n</em>();  <span class="color-comment">// create an instance of the anonymous inner class</span>
   ......
}</pre>

<p>Clearly, you can only create one instance for each anonymous inner class.</p>

<h4>Example of Static Nested Class in JDK: <span class="font-code">Point2D</span>, <span class="font-code">Point2D.Double</span>, <span class="font-code">Point2D.Float</span>, <span class="font-code">Point</span></h4>

<p>The <code>abstract</code> class <code>Point2D</code> (in package <code>java.awt.geom</code> of Java 2D API), which models a 2D point, declares <code>abstract</code> methods such as <code>getX()</code> and <code>getY()</code>. The <code>Point2D</code> cannot be instantiated. <code>Point2D</code> does not define any instance variable, in particular, the x and y location of the point.  This is because it is not sure about the <em>type</em> of x and y (which could be <code>int</code>, <code>float</code>, or <code>double</code>).  The instance variables, therefore, are left to the   implementation subclasses.</p>
<p>Three subclasses were implemented for types   of <code>int</code>, <code>float</code> and <code>double</code>, respectively. <code>Point2D</code> cannot be designed as a pure abstract-method-only <code>interface</code>, as it   contains non-abstract methods.</p>
<p>The subclass <code>Point</code> defines instance variables x and y in <code>int</code> precision and provides implementation to abstract methods such as <code>getX()</code> and <code>getY()</code>. <code>Point</code> (of <code>int</code>-precision) is a straight-forward implementation of inheritance and polymorphism. <code>Point</code> is a legacy class (since JDK 1.1) and retrofitted when Java 2D was introduced.</p>
<p>Two subclasses <code>Point2D.Float</code> and <code>Point2D.Double</code> define instance variables x and y in <code>float</code> and <code>double</code> precision, respectively. These two subclasses, are also declared as <code>public</code> <code>static</code> nested class of the outer class <code>Point2D</code>. Since they are <code>static</code>, they can be referenced as <code>Point2D.Double</code> and <code>Point2D.Float</code>. They are implemented as nested <code>static</code> subclasses within the <code>Point2D</code> outer class to keep the codes together and for namespace management. There is no access-control (of private variables of the outer class) involved.</p>

<pre class="color-syntax">
package java.awt.geom;
abstract public class <strong>Point2D</strong>  {

   <span class="color-comment">// abstract methods</span>
   abstract public double getX();
   abstract public double getY();
   abstract public void setLocation(double x, double y);

   public double distance(double x, double y) { ... }
   public double distance(Point2D p) { ... }
   public static double distance(double x1, double y1, double x2, double y2) { ... }
   ......
   
   public static class <strong>Double</strong> <strong>extends Point2D</strong> {
      public double x;
      public double y;

      public Double(double x, double y) { ... }
      @Override public double getX() { return x; }
      @Override public double getY() { return y; }
      @Override public void setLocation(double x, double y) { ... }
      ......
   }

   public static class <strong>Float</strong> <strong>extends Point2D</strong> {
      public float x;
      public float y;
      public Double(float x, float y) { ... }
      @Override public double getX() { ... }
      @Override public double getY() { ... }
      @Override public void setLocation(double x, double y) { ... }
      public void setLocation(float x, float y) { ... }
      ......
   }
}</pre>

<pre class="color-syntax">
package java.awt.geom;
public class <strong>Point extends Point2D</strong> {
   public int x;
   public int y;
   public Point(int x, int y) { ... }
   @Override public double getX() { return x; }
   @Override public double getY() { return y; }
   @Override public void setLocation(double x, double y) { ... }
   ......
}</pre>

<p><code>Point2D.Double</code> and <code>Point2D.Float</code> are <code>public</code> <code>static</code> classes. In other words, they can be used directly without instantiating the outer class, just like any <code>static</code> variable or method (which can be referenced directly via the classname, e.g., <code>Math.PI</code>, <code>Math.sqrt()</code> and <code>Integer.parseInt()</code>). Since they are subclass of <code>Point2D</code>, they can be upcast to <code>Point2D</code>.</p>

<pre class="color-example">
Point2D.Double p1 = new Point2D.Double(1.1, 2.2);
Point2D.Float p2 = new Point2D.Float(1.1f, 2.2f);
Point p3 = new Point(1, 2);
<span class="color-comment">// Using polymorphism</span>
Point2D p1 = new Point2D.Double(1.1, 2.2);   <span class="color-comment">// upcast</span>
Point2D p2 = new Point2D.Float(1.1f, 2.2f);  <span class="color-comment">// upcast</span>
Point2D p3 = new Point(1, 2);                <span class="color-comment">// upcast</span></pre>

<p>Note: These classes were designed before the introduction of generic in JDK 1.5, which supports the passing of type as argument.</p>

<h4>&quot;Cannot refer to a non-final variable inside an inner class defined in a different method&quot;</h4>

<p>Java specification 8.1.3: &quot;Any local variable, formal method parameter or exception handler parameter used but not declared in an inner class must be declared final.&quot;</p>
<p>By allowing inner class to access non-<code>final</code> local variables inside a method, the local variable could be modified by the inner class, and causes a strange side-effect.</p>
<p>Solution:</p>
<ol>
  <li>Declare the variable <code>final</code> if permissible.</li>
<li>Declare the variable outside the method, e.g., as <em>member variables</em> of the class, instead of a local variable within a method. Both the method and the inner class could access the variable.</li>
<li>Use a wrapper class to wrap the variable inside a class. Declare the instance <code>final</code>.</li>
</ol>

<h4>Referencing Outer-class's &quot;<span class="font-code">this</span>&quot; from Inner-class</h4>
<p>Inside the inner class, &quot;<code>this</code>&quot; refers to the inner class. To refer to the &quot;<code>this</code>&quot; of the outer class, use &quot;<em><code>OuterClassName</code></em><code>.this</code>&quot;. But you can reference outer class's members directly without this clumsy syntax. For example,</p>

<pre class="color-example">
......
public class <span class="color-new">MyOuterClassName</span> {
   private String msg = &quot;Hello&quot;;
   ......
   public MyOuterClassName() {  <span class="color-comment">// constructor</span>
      ......
      Button btn = new Button(&quot;TEST&quot;);
      btn.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            <span class="color-comment">// Need OuterClassName.this to refer to the outer class.
            // But can reference outer class members (e.g., msg) directly.</span>
            JOptionPane.showMessageDialog(<span class="color-new">MyOuterClassName.this</span>, msg);
         }
      });
   }
}</pre>


<h3>Event Listener's Adapter Classes</h3>

<h4>Example 11: <span class="font-code">WindowAdapter</span> for <span class="font-code">WindowListener</span></h4>

<h5>Using <span class="font-code">WindowListener</span> Interface</h5>

<p>Refer to the <code>WindowEventDemo</code>, a <code>WindowEvent</code> listener is required to implement the <code>WindowListener</code> interface, which declares 7 <code>abstract</code> methods. Although we are only interested in <code>windowClosing()</code>, we need to provide an empty body to the other 6 <code>abstract</code> methods in order to compile the program. This is tedious, e.g., we can rewrite the <code>WindowEventDemo</code> using an inner class implementing <code>ActionListener</code> as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class WindowEventDemoWithInnerClass extends Frame {
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemoWithInnerClass () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class</span>
      <span class="color-comment">// that implements WindowListener.</span>
      <span class="color-comment">// &quot;super&quot; Frame adds this instance as WindowEvent listener.</span>
      <span class="color-new">addWindowListener(new WindowListener() {
         @Override
         public void windowClosing(WindowEvent evt) {
            System.exit(0);  <span class="color-comment">// terminate the program</span>
         }
         <span class="color-comment">// Need to provide an empty body for compilation</span>
         @Override public void windowOpened(WindowEvent evt) { }
         @Override public void windowClosed(WindowEvent evt) { }
         @Override public void windowIconified(WindowEvent evt) { }
         @Override public void windowDeiconified(WindowEvent evt) { }
         @Override public void windowActivated(WindowEvent evt) { }
         @Override public void windowDeactivated(WindowEvent evt) { }
      });</span>
 
      setTitle(&quot;WindowEvent Demo&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">// The entry main method</span>
   public static void main(String[] args) {
      new WindowEventDemoWithInnerClass();   <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5>Using <span class="font-code">WindowAdapter</span> Superclass</h5>

<p>An <em>adapter</em> class called <code>WindowAdapter</code> is therefore provided, which implements the <code>WindowListener</code> interface and provides default  implementations to all the 7 <code>abstract</code> methods.  You can then derive a subclass from <code>WindowAdapter</code> and override only methods of interest and leave the rest to their default implementation. For example,</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class WindowEventDemoAdapter extends Frame {
   private TextField tfCount;
   private Button btnCount;
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public WindowEventDemoAdapter () {
      setLayout(new FlowLayout());
      add(new Label(&quot;Counter&quot;));
      tfCount = new TextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      add(tfCount);
 
      btnCount = new Button(&quot;Count&quot;);
      add(btnCount);
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class</span>
      <span class="color-comment">// that extends WindowAdapter.</span>
      <span class="color-comment">// &quot;super&quot; Frame adds the instance as WindowEvent listener.</span>
      <span class="color-new">addWindowListener(new WindowAdapter() {
         @Override
         public void windowClosing(WindowEvent evt) {
            System.exit(0);  <span class="color-comment">// Terminate the program</span>
         }
      });</span>
 
      setTitle(&quot;WindowEvent Demo&quot;);
      setSize(250, 100);
      setVisible(true);
   }
 
   <span class="color-comment">/** The entry main method */</span>
   public static void main(String[] args) {
      new WindowEventDemoAdapter();   <span class="color-comment">// Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Other Event-Listener Adapter Classes</h4>
<p>Similarly, adapter classes such as <code>MouseAdapter</code>,<code> MouseMotionAdapter</code>, <code>KeyAdapter</code>, <code>FocusAdapter</code> are available for <code>MouseListener</code>, <code>MouseMotionListener</code>, <code>KeyListener</code>, and <code>FocusListener</code>, respectively.</p>

<p>There is no <code>ActionAdapter</code> for <code>ActionListener</code>, because there is only one <code>abstract</code> method (i.e. <code>actionPerformed()</code>) declared in the <code>ActionListener</code> interface. This method has to be overridden and there is no need for an adapter.</p>

<h3>Layout Managers and Panel</h3>
<p>A container has a so-called <em>layout manager</em> to arrange its components. The layout managers provide a level of abstraction to map your user interface on all windowing
systems, so that the layout can be <em>platform-independent</em>.</p>

<p>AWT provides the following layout managers (in package <code>java.awt</code>): <code>FlowLayout</code>, <code>GridLayout</code>, <code>BorderLayout</code>, <code>GridBagLayout</code>, <code>BoxLayout</code>, <code>CardLayout</code>, and others. (Swing added more layout manager in package <code>javax.swing</code>, to be described later.)</p>

<h5><span class="font-code">Container's setLayout()</span></h5>
<p>A container has a <code>setLayout()</code> method to set its layout manager:</p>
<pre class="color-syntax">
<span class="color-comment">// java.awt.Container</span>
public void setLayout(LayoutManager mgr)</pre>

<p>To set up the layout of a <code>Container</code> (such as <code>Frame</code>, <code>JFrame</code>, <code>Panel</code>, or  <code>JPanel</code>), you have to:</p>
<ol>
<li>Construct an instance of the chosen layout object, via <code>new</code> and constructor, e.g., <code>new FlowLayout()</code>)</li>
<li>Invoke the <code>setLayout()</code> method of the <code>Container</code>, with the layout object created as the argument;</li>
<li>Place the GUI components into the <code>Container</code> using the <code>add()</code> method in the correct order; or into the correct zones.</li>
</ol>

<p>For example,</p>
<pre class="color-example">
<span class="color-comment">// Allocate a Panel (container)</span>
Panel p = new Panel();  
<span class="color-comment">// Allocate a new Layout object. The Panel container sets to this layout.</span>
p.setLayout(new FlowLayout());
<span class="color-comment">// The Panel container adds components in the proper order.</span>
p.add(new JLabel(&quot;One&quot;));
p.add(new JLabel(&quot;Two&quot;));
p.add(new JLabel(&quot;Three&quot;));
......</pre>

<h5><span class="font-code">Container's getLayout()</span></h5>
<p>You can get the current layout via <code>Container</code>'s <code>getLayout()</code>.</p>

<pre class="color-example">
Panel awtPanel = new Panel();
System.out.println(awtPanel.getLayout());
      <span class="color-comment">// java.awt.FlowLayout[hgap=5,vgap=5,align=center]</span></pre>
   
<h5>Panel's Initial Layout</h5>

<p><code>Panel</code> (and Swing's <code>JPanel</code>) provides a constructor to set its initial layout manager. It is because a primary function of <code>Panel</code> is to layout a group of component in a particular layout.</p>
<pre class="color-syntax">
public void Panel (LayoutManager <em>layout</em>)  
   <span class="color-comment">// Construct a Panel in the given layout
   // By default, Panel (and JPanel) has FlowLayout</span>
 
<span class="color-comment">// For example, create a Panel in BorderLayout</span>
Panel mainPanel = new Panel(new BorderLayout());</pre>

<h4><span class="font-code">FlowLayout</span></h4>

<img class="image-float-right" src="images/AWT_FlowLayout.gif" alt="AWT_FlowLayout.gif" />
<p>In the <code>java.awt.FlowLayout</code>, components are arranged from left-to-right inside the container in the order that they are added (via method <code>aContainer.add(aComponent)</code>).  When one row is filled, a new row will be started.  The actual appearance depends on the width of the display window.</p>


<p class="underline float-clear">Constructors</p>
<pre class="color-syntax">
public FlowLayout();
public FlowLayout(int <em>align</em>);
public FlowLayout(int <em>align</em>, int <em>hgap</em>, int <em>vgap</em>);
<span class="color-comment">  // <em>align</em>: FlowLayout.LEFT (or LEADING), FlowLayout.RIGHT (or TRAILING), or FlowLayout.CENTER
  // <em>hgap</em>, <em>vgap</em>: horizontal/vertical gap between the components
  // By default: hgap=5, vgap=5, align=CENTER</span>
</pre>
  
<p class="underline">Example</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTFlowLayoutDemo extends Frame {
   private Button btn1, btn2, btn3, btn4, btn5, btn6;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTFlowLayoutDemo () {
      setLayout(new FlowLayout());
        <span class="color-comment"> // &quot;super&quot; Frame sets layout to FlowLayout, which arranges the components</span>
        <span class="color-comment"> // from left-to-right, and flow from top-to-bottom.</span>
 
      btn1 = new Button(&quot;Button 1&quot;);
      add(btn1);
      btn2 = new Button(&quot;This is Button 2&quot;);
      add(btn2);
      btn3 = new Button(&quot;3&quot;);
      add(btn3);
      btn4 = new Button(&quot;Another Button 4&quot;);
      add(btn4);
      btn5 = new Button(&quot;Button 5&quot;);
      add(btn5);
      btn6 = new Button(&quot;One More Button 6&quot;);
      add(btn6);
 
      setTitle(&quot;FlowLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(280, 150);          <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTFlowLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4><span class="font-code">GridLayout</span></h4>

<img class="image-float-right" src="images/AWT_GridLayout.gif" alt="AWT_GridLayout.gif" />

<p>In <code>java.awt.GridLayout</code>, components are arranged in a grid (matrix) of rows and columns inside the <code>Container</code>.  Components are added in a left-to-right, top-to-bottom manner in the order they are added (via method <code><em>aContainer</em>.add(<em>aComponent</em>)</code>).</p>


<p class="underline float-clear">Constructors</p>
<pre class="color-syntax">
public GridLayout(int <em>rows</em>, int <em>columns</em>);
public GridLayout(int <em>rows</em>, int <em>columns</em>, int <em>hgap</em>, int <em>vgap</em>);
      <span class="color-comment">// By default: rows=1, cols=0, hgap=0, vgap=0</span></pre>

<p class="underline">Example</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTGridLayoutDemo extends Frame {
   private Button btn1, btn2, btn3, btn4, btn5, btn6;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTGridLayoutDemo () {
      setLayout(new GridLayout(3, 2, 3, 3));
        <span class="color-comment"> // &quot;super&quot; Frame sets layout to 3x2 GridLayout, horizontal and verical gaps of 3 pixels</span>
 
     <span class="color-comment"> // The components are added from left-to-right, top-to-bottom</span>
      btn1 = new Button(&quot;Button 1&quot;);
      add(btn1);
      btn2 = new Button(&quot;This is Button 2&quot;);
      add(btn2);
      btn3 = new Button(&quot;3&quot;);
      add(btn3);
      btn4 = new Button(&quot;Another Button 4&quot;);
      add(btn4);
      btn5 = new Button(&quot;Button 5&quot;);
      add(btn5);
      btn6 = new Button(&quot;One More Button 6&quot;);
      add(btn6);
 
      setTitle(&quot;GridLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(280, 150);          <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);           <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTGridLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>If <code>rows</code> or <code>cols</code> is 0, but not both, then any number of components can be placed in that column or row. If both the <code>rows</code> and <code>cols</code> are specified, the <code>cols</code> value is ignored. The actual <code>cols</code> is determined by the actual number of components and <code>rows</code>.</p>

<h4><span class="font-code">BorderLayout</span></h4>

<img class="image-float-right" src="images/AWT_BorderLayout.gif" alt="AWT_BorderLayout.gif" />

<p>In <code>java.awt.BorderLayout</code>, the container is divided into 5 zones: <code>EAST</code>, <code>WEST</code>, <code>SOUTH</code>, <code>NORTH</code>, and <code>CENTER</code>.  Components are added using method <code><em>aContainer</em>.add(<em>acomponent</em>, <em>aZone</em>)</code>, where <code><em>azone</em></code> is either <code>BorderLayout.NORTH</code> (or <code>PAGE_START</code>), <code></code><code>BorderLayout.SOUTH</code> (or <code>PAGE_END</code>), <code>BorderLayout.WEST</code> (or <code>LINE_START</code>), <code>BorderLayout.EAST</code> (or <code>LINE_END</code>), or <code>BorderLayout.CENTER</code>. The method <code><em>aContainer</em>.add(<em>aComponent</em>)</code> without specifying the zone adds the component to the <code>CENTER</code>.</p>

<p>You need not add components to all the 5 zones. The <code>NORTH</code> and <code>SOUTH</code> components may be stretched horizontally; the <code>EAST</code> and <code>WEST</code> components may be stretched vertically; the <code>CENTER</code> component may stretch both horizontally and vertically to fill any space left over.</p>

<p class="underline float-clear">Constructors</p>
<pre class="color-syntax">
public BorderLayout();
public BorderLayout(int <em>hgap</em>, int <em>vgap</em>);
      <span class="color-comment">// By default hgap=0, vgap=0</span></pre>

<p class="underline">Example</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTBorderLayoutDemo extends Frame {
   private Button btnNorth, btnSouth, btnCenter, btnEast, btnWest;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTBorderLayoutDemo () {
      setLayout(new BorderLayout(3, 3));
        <span class="color-comment"> // &quot;super&quot; Frame sets layout to BorderLayout,</span>
        <span class="color-comment"> // horizontal and vertical gaps of 3 pixels</span>
 
     <span class="color-comment"> // The components are added to the specified zone</span>
      btnNorth = new Button(&quot;NORTH&quot;);
      add(btnNorth, BorderLayout.NORTH);
      btnSouth = new Button(&quot;SOUTH&quot;);
      add(btnSouth, BorderLayout.SOUTH);
      btnCenter = new Button(&quot;CENTER&quot;);
      add(btnCenter, BorderLayout.CENTER);
      btnEast = new Button(&quot;EAST&quot;);
      add(btnEast, BorderLayout.EAST);
      btnWest = new Button(&quot;WEST&quot;);
      add(btnWest, BorderLayout.WEST);
 
      setTitle(&quot;BorderLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(280, 150);            <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTBorderLayoutDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>Using <span class="font-code">Panel</span>s as Sub-Container to Organize Components</h4>

<img class="image-float-right" src="images/Swing_JPanel.gif" alt="Swing_JPanel.gif" />

<p>An AWT <code>Panel</code>  is a rectangular pane, which can be used as sub-container to organized a group of related components in a specific layout (e.g., <code>FlowLayout</code>, <code>BorderLayout</code>). <code>Panel</code>s are secondary containers, which shall be added into a top-level container (such as <code>Frame</code>), or another <code>Panel</code>.</p>

<p>For example, the following figure shows a <code>Frame</code> (in <code>BorderLayout</code>) containing two <code>Panels</code>, <code>panelResult</code> in <code>FlowLayout</code>  and <code>panelButtons</code> in <code>GridLayout</code>. <code>panelResult</code> is added to the <code>NORTH</code>, and <code>panelButtons</code> is added to the <code>CENTER</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
 
<span class="color-comment">// An AWT GUI program inherits the top-level container java.awt.Frame</span>
public class AWTPanelDemo extends Frame {
   private Button[] btnNumbers; <span class="color-comment"> // Array of 10 numeric Buttons</span>
   private Button btnHash, btnStar;
   private TextField tfDisplay;
 
   <span class="color-comment">// Constructor to setup GUI components and event handlers</span>
   public AWTPanelDemo () {
     <span class="color-comment"> // Set up display panel</span>
      Panel panelDisplay = new Panel(new FlowLayout());
      tfDisplay = new TextField(&quot;0&quot;, 20);
      panelDisplay.add(tfDisplay);
 
     <span class="color-comment"> // Set up button panel</span>
      Panel panelButtons = new Panel(new GridLayout(4, 3));
      btnNumbers = new Button[10];  <span class="color-comment">// Construct an array of 10 numeric Buttons</span>
      btnNumbers[1] = new Button(&quot;1&quot;);  <span class="color-comment">// Construct Button &quot;1&quot;</span>
      panelButtons.add(btnNumbers[1]);  <span class="color-comment">// The Panel adds this Button</span>
      btnNumbers[2] = new Button(&quot;2&quot;);
      panelButtons.add(btnNumbers[2]);
      btnNumbers[3] = new Button(&quot;3&quot;);
      panelButtons.add(btnNumbers[3]);
      btnNumbers[4] = new Button(&quot;4&quot;);
      panelButtons.add(btnNumbers[4]);
      btnNumbers[5] = new Button(&quot;5&quot;);
      panelButtons.add(btnNumbers[5]);
      btnNumbers[6] = new Button(&quot;6&quot;);
      panelButtons.add(btnNumbers[6]);
      btnNumbers[7] = new Button(&quot;7&quot;);
      panelButtons.add(btnNumbers[7]);
      btnNumbers[8] = new Button(&quot;8&quot;);
      panelButtons.add(btnNumbers[8]);
      btnNumbers[9] = new Button(&quot;9&quot;);
      panelButtons.add(btnNumbers[9]);
        <span class="color-comment">    // You should use a loop for the above statements!!!</span>
      btnStar = new Button(&quot;*&quot;);
      panelButtons.add(btnStar);
      btnNumbers[0] = new Button(&quot;0&quot;);
      panelButtons.add(btnNumbers[0]);
      btnHash = new Button(&quot;#&quot;);
      panelButtons.add(btnHash);
 
      setLayout(new BorderLayout()); <span class="color-comment"> // &quot;super&quot; Frame sets to BorderLayout</span>
      add(panelDisplay, BorderLayout.NORTH);
      add(panelButtons, BorderLayout.CENTER);
 
      setTitle(&quot;BorderLayout Demo&quot;);<span class="color-comment"> // &quot;super&quot; Frame sets title</span>
      setSize(200, 200);            <span class="color-comment"> // &quot;super&quot; Frame sets initial size</span>
      setVisible(true);             <span class="color-comment"> // &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      new AWTPanelDemo(); <span class="color-comment"> // Let the constructor do the job</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4><span class="font-code">BoxLayout</span></h4>
<p>BoxLayout arrange components in a single row or column. It respects components' requests on the minimum sizes.</p>

<p>[TODO] Example and diagram</p>

<h3>(Advanced) Composite Design Pattern</h3>

<img class="image-center" src="images/AWT_ComponentClassDiagram.png" alt="AWT_ComponentClassDiagram.png" />

<p>As mentioned earlier, there are two groups of classes in the AWT hierarchy: containers and components. A container (e.g., <code>Frame</code>, <code>Panel</code>, <code>Dialog</code>, <code>java.applet.Applet</code>) holds components (e.g., <code>Label</code>, <code>Button</code>, <code>TextField</code>). A container (e.g., <code>Frame</code> and <code>Panel</code>) can also hold sub-containers (e.g. <code>Panel</code>). Hence, we have a situation that &quot;a container can contain containers or components&quot;.</p>

<p>This is quite a common problem: e.g., a directory contains (sub)directories or files; a group contains (sub)groups or elementary elements; the tree structure.  A <em>design pattern</em> has been proposed for this problem.  A design pattern is a proven and possibly the best solution for a specific class of problems.</p>

<p>As shown in the class diagram, there are two sets of relationship between <code>Container</code> and <code>Component</code> classes.</p>
<ol>
<li><em>One-to-many aggregation</em>:  A <code>Container</code> contains zero or more <code>Component</code>s.  Each <code>Component</code> is contained in exactly one <code>Container</code>.</li>
<li><em>Generalization (or Inheritance)</em>:  <code>Container</code> is a <em>subclass</em> of <code>Component</code>.  In other words, a <code>Container</code> is a <code>Component</code>, which possesses all the properties of <code>Component</code> and can be substituted in place of a <code>Component</code>.</li>
</ol>

<p>Combining both relationships, we have: A <code>Container</code> contains <code>Component</code>s.  Since a <code>Container</code> is a <code>Component</code>, a <code>Container</code> can also contain <code>Containers</code>.  Consequently, a <code>Container</code> can contain <code>Container</code>s and <code>Component</code>s.</p>

<p>The <em>Gof</em> calls this <em>recursive composition</em> class design &quot;<em>composite design pattern</em>&quot;, which is illustrated as follows:</p>

<img class="image-center" src="images/DesignPattern_Composite.png" alt="DesignPattern_Composite.png" />

<h3>Swing</h3>

<h4>Introduction</h4>
<p>Swing is part of the so-called &quot;Java Foundation Classes (JFC)&quot; (have you heard of MFC?), which was introduced in 1997 after the release of JDK 1.1.  JFC was subsequently included as an integral part of JDK since JDK 1.2. JFC consists of:</p>
<ul>
<li>Swing API: for advanced graphical programming.</li>
<li>Accessibility API: provides assistive technology for the disabled.</li>
<li>Java 2D API: for high quality 2D graphics and images.</li>
<li>Pluggable look and feel supports.</li>
<li>Drag-and-drop support between Java and native applications.</li>
</ul>

<p>The goal of Java GUI programming is to allow the programmer to build GUI that looks good on ALL platforms. JDK 1.0's AWT was awkward and non-object-oriented (using many <code>event.getSource()</code>). JDK 1.1's AWT introduced event-delegation (event-driven) model, much clearer and object-oriented. JDK 1.1 also introduced inner class and JavaBeans â a component programming model for visual programming environment (similar to Visual Basic and Dephi).</p>

<p>Swing appeared after JDK 1.1. It was introduced into JDK 1.1 as part of an add-on JFC (Java Foundation Classes). Swing is a rich set of easy-to-use, easy-to-understand JavaBean GUI components that can be dragged and dropped as &quot;GUI builders&quot; in visual programming environment. Swing is now an integral part of Java since JDK 1.2.</p>

<h4>Swing's Features</h4>
<p>Swing is huge (consists of 18 API packages as in JDK 1.7) and has great depth.  Compared with AWT, Swing provides a huge and comprehensive collection of reusable GUI components, as shown in the Figure below (extracted form Swing Tutorial).</p>

<img class="image-center" src="images/Swing_Components.png" alt="Swing_Components.png" />

<p>The main features of Swing are (extracted from the Swing website):</p>
<ol>
  <li>Swing is written in pure Java (except a few classes) and therefore is 100% portable.</li>
<li>Swing components are <em>lightweight</em>. The AWT components are <em>heavyweight</em> (in terms of system resource utilization). Each AWT component has its own opaque native display, and always displays on top of the lightweight components. AWT components rely heavily on the underlying windowing subsystem of the native operating system.  For example, an AWT button ties to an actual button in the underlying native windowing subsystem, and relies on the native windowing subsystem for their rendering and processing.  Swing components (<code>JComponent</code>s) are written in Java.  They are generally not &quot;weight-down&quot; by complex GUI considerations imposed by the underlying windowing subsystem.</li>
<li>Swing components support <em>pluggable look-and-feel</em>.  You can choose between <em>Java look-and-feel</em> and the <em>look-and-feel of the underlying OS</em> (e.g., Windows, UNIX or Mac).  If the later is chosen, a Swing button runs on the Windows looks like a Windows' button and feels like a Window's button.  Similarly, a Swing button runs on the UNIX looks like a UNIX's button and feels like a UNIX's button.<br />
<img src="images/Swing_LaFJava.png" alt="Swing_LaFJava.png" />
<img src="images/Swing_LaFNativeSystem.png" alt="Swing_LaFNativeSystem.png" /><br />
<img src="images/Swing_LaFNimbus.png" alt="Swing_LaFNimbus.png" />
<img src="images/Swing_LaFMotif.png" alt="Swing_LaFMotif.png" />
</li>

<li>Swing supports <em>mouse-less operation</em>, i.e., it can operate entirely using keyboard.</li>
<li>Swing components support &quot;tool-tips&quot;.</li>
<li>Swing components are <em>JavaBeans</em> â a Component-based Model used in Visual Programming (like Visual Basic).  You can drag-and-drop a Swing component into a &quot;design form&quot; using a &quot;GUI builder&quot; and double-click to attach an event handler.</li>
<li>Swing application uses AWT event-handling classes (in package <code>java.awt.event</code>).  Swing added some new classes in package <code>javax.swing.event</code>, but they are not frequently used.</li>
<li>Swing application uses AWT's layout manager (such as <code>FlowLayout</code> and <code>BorderLayout</code> in package <code>java.awt</code>).  It added new layout managers, such as <code>Springs</code>, <code>Struts</code>, and <code>BoxLayout</code> (in package <code>javax.swing</code>).</li>
<li>Swing implements <em>double-buffering</em> and automatic repaint batching for smoother screen repaint.</li>
<li>Swing introduces <code>JLayeredPane</code> and <code>JInternalFrame</code> for creating Multiple Document Interface (MDI) applications.</li>
<li>Swing supports floating toolbars (in <code>JToolBar</code>), splitter control, &quot;undo&quot;.</li>
<li>Others - check the Swing website.</li>
</ol>

<h4>Using Swing API</h4>

<p>If you understood the AWT programming (such as container/component, event-handling, layout manager), switching over to Swing (or any other Graphics packages) is straight-forward.</p>

<h5>Swing's Components</h5>
<p>Compared with the AWT classes (in package <code>java.awt</code>), Swing component classes (in package <code>javax.swing</code>) begin with a prefix <code>&quot;J&quot;</code>, e.g., <code>JButton</code>, <code>JTextField</code>, <code>JLabel</code>, <code>JPanel</code>, <code>JFrame</code>, or <code>JApplet</code>.</p>

<img class="image-center" src="images/Swing_ClassDiagram.png" alt="Swing_ClassDiagram.png" />

<p>The above figure shows the class hierarchy of the swing GUI classes.  Similar to AWT, there are two groups of classes: <em>container</em>s and <em>component</em>s.  A container is used to hold components.  A container can also hold containers because it is a (subclass of) component.</p>

<p>As a rule, do not mix heavyweight AWT components and lightweight Swing components in the same program, as the heavyweight components will always be painted <em>on top of</em> the lightweight components.</p>

<h5>Swing's Top-Level and Secondary Containers</h5>

<img class="image-float-right" src="images/Swing_ContentPane.png" alt="Swing_ContentPane.png" />

<p>Just like AWT application, a Swing application requires a <em>top-level container</em>.  There are three top-level containers in Swing:</p>
<ol>
<li><code>JFrame</code>:  used for the application's main window (with an icon, a title, minimize/maximize/close buttons, an optional menu-bar, and a content-pane), as illustrated.</li>
<li><code>JDialog</code>:  used for secondary pop-up window (with a title, a close button, and a content-pane).</li>
<li><code>JApplet</code>:  used for the applet's display-area (content-pane) inside a browserâs window.</li>
</ol>

<p>Similarly to AWT, there are <em>secondary containers</em> (such as <code>JPanel</code>) which can be used to group and layout relevant components.</p>

<h5>The Content-Pane of Swing's Top-Level Container</h5>

<p>However, unlike AWT, the <code>JComponents</code> shall not be added onto the top-level container (e.g., <code>JFrame</code>, <code>JApplet</code>) directly because they are lightweight components.  The <code>JComponents</code> must be added onto the so-called <em>content-pane</em> of the top-level container. Content-pane is in fact a <code>java.awt.Container</code> that can be used to group and layout components.</p>
<p>You could:</p>

<ol>
<li>get the content-pane via <code>getContentPane()</code> from a top-level container, and add components onto it. For example,
<pre class="color-example">
public class TestGetContentPane <strong>extends JFrame</strong> {
   <span class="color-comment">// Constructor</span>
   public TestGetContentPane() {
      <span class="color-comment">// Get the content-pane of this JFrame, which is a java.awt.Container
      // All operations, such as setLayout() and add() operate on the content-pane</span> 
      Container <strong>cp = this.getContentPane()</strong>; 
      <strong>cp.setLayout</strong>(new FlowLayout());
      <strong>cp.add</strong>(new JLabel(&quot;Hello, world!&quot;));
      <strong>cp.add</strong>(new JButton(&quot;Button&quot;));
      ......
   }
   .......
}</pre>

</li>
<li>set the content-pane to a <code>JPanel</code> (the main panel created in your application which holds all your GUI components) via <code>JFrame</code>'s <code>setContentPane()</code>.
<pre class="color-example">
public class TestSetContentPane <strong>extends JFrame</strong> {
   <span class="color-comment">// Constructor</span>
   public TestSetContentPane() {
      <span class="color-comment">// The &quot;main&quot; JPanel holds all the GUI components</span>
      <strong>JPanel mainPanel</strong> = new JPanel(new FlowLayout());
      mainPanel.add(new JLabel(&quot;Hello, world!&quot;));
      mainPanel.add(new JButton(&quot;Button&quot;));

      <span class="color-comment">// Set the content-pane of this JFrame to the main JPanel</span>
      <strong>this.setContentPane(mainPanel);</strong>
      ......
   }
   .......
}</pre>
</li>
</ol>

<p>Notes: If a component is added directly into a <code>JFrame</code>, it is added into the content-pane of <code>JFrame</code> instead, i.e.,</p>

<pre class="color-example">
<span class="color-comment">// &quot;this&quot; is a JFrame</span>
add(new JLabel(&quot;add to JFrame directly&quot;));
<span class="color-comment">// is executed as</span>
getContentPane().add(new JLabel(&quot;add to JFrame directly&quot;));</pre>

<h5>Event-Handling in Swing</h5>
<p>Swing uses the AWT event-handling classes (in package <code>java.awt.event</code>).  Swing introduces a few new event-handling classes (in package <code>javax.swing.event</code>) but they are not frequently used.</p>

<h5>Writing Swing Applications</h5>

<p>In summary, to write a Swing application, you have:</p>
<ol>
<li>Use the Swing components with prefix <code>&quot;J&quot;</code> in package <code>javax.swing</code>, e.g., <code>JFrame</code>, <code>JButton</code>, <code>JTextField</code>, <code>JLabel</code>, etc.</li>
<li>A top-level container (such as <code>JFrame</code> or  <code>JApplet</code>) is needed.  The <code>JComponents</code> should be added directly onto the top-level container. They shall be added onto the <em>content-pane</em> of the top-level container.  You can retrieve a reference to the content-pane by invoking method <code>getContentPane()</code> from the top-level container, or set the content-pane to the main <code>JPanel</code> created in your program.</li>
<li>Swing applications uses AWT event-handling classes, e.g., <code>ActionEvent/ActionListener</code>, <code>MouseEvent/MouseListener</code>, etc.</li>
<li>Run the constructor in the Event Dispatcher Thread (instead of Main thread) for thread safety, as shown in the following program template.</li>
</ol>

<h4>Swing Program Template</h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre></td>
<td>
<pre>
import java.awt.*;        <span class="color-comment">// Using AWT layouts</span>
import java.awt.event.*;  <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;     <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits from top-level container javax.swing.JFrame</span>
public class ...... extends <span class="color-new">JFrame</span> {
 
   <span class="color-comment">// Private instance variables</span>
   <span class="color-comment">// ......</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public ......() {
      <span class="color-comment">// Retrieve the top-level content-pane</span>
      <span class="color-new">Container cp = this.getContentPane();</span>
 
      <span class="color-comment">// Content-pane sets layout</span>
      <span class="color-new">cp.</span>setLayout(new ....Layout());
 
      <span class="color-comment">// Allocate the GUI components</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-comment">// Content-pane adds components</span>
      <span class="color-new">cp.</span>add(....);
 
      <span class="color-comment">// Source object adds listener</span>
      <span class="color-comment">// .....</span>
 
      <span class="color-new">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span>
         <span class="color-comment">// Exit the program when the close-window button clicked</span>
      setTitle(&quot;......&quot;);  <span class="color-comment">// &quot;super&quot; JFrame sets title</span>
      setSize(300, 150);   <span class="color-comment">// &quot;super&quot; JFrame sets initial size (or pack())</span>
      setVisible(true);    <span class="color-comment">// &quot;super&quot; JFrame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run GUI codes in Event-Dispatching thread for thread-safety</span>
      <span class="color-new">SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new ......();  <span class="color-comment">// Let the constructor do the job</span>
         }
      });</span>
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>I will explain this template in the following Swing example.</p>

<h4>Swing Example 1: <span class="font-code">SwingCounter</span></h4>

<img class="image-float-right" src="images/Swing_Counter.gif" alt="Swing_Counter.gif" />

<p>Let's convert the earlier AWT application example into Swing.  Compare the two source files and note the changes (which are highlighted).  The display is shown below.  Note the differences in <em>look and feel</em> between the AWT GUI components and Swing's.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre>
</td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using AWT layout</span>s
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits from top-level container javax.swing.JFrame</span>
public class SwingCounter extends JFrame {   <span class="color-comment">// JFrame instead of Frame</span>
   private JTextField tfCount;  <span class="color-comment">// Use Swing's JTextField instead of AWT's TextField</span>
   private JButton btnCount;    <span class="color-comment">// Using Swing's JButton instead of AWT's Button</span>
   private int count = 0;
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingCounter () {
      <span class="color-comment">// Retrieve the content-pane of the top-level container JFrame</span>
      <span class="color-comment">// All operations done on the content-pane</span>
      Container cp = getContentPane();
      cp.setLayout(new FlowLayout());   <span class="color-comment">// The content-pane sets its layout</span>
 
      cp.add(new JLabel(&quot;Counter&quot;));
      tfCount = new JTextField(&quot;0&quot;, 10);
      tfCount.setEditable(false);
      cp.add(tfCount);
 
      btnCount = new JButton(&quot;Count&quot;);
      cp.add(btnCount);
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class that</span>
      <span class="color-comment">//  implements ActionListener as ActionEvent listener</span>
      btnCount.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            ++count;
            tfCount.setText(count + &quot;&quot;);
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="color-comment">// Exit program if close-window button clicked</span>
      setTitle(&quot;Swing Counter&quot;); <span class="color-comment">// &quot;super&quot; JFrame sets title</span>
      setSize(300, 100);         <span class="color-comment">// &quot;super&quot; JFrame sets initial size</span>
      setVisible(true);          <span class="color-comment">// &quot;super&quot; JFrame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingCounter(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h5><span class="font-code">JFrame</span>'s Content-Pane</h5>
<p>The <code>JFrams</code>'s method <code>getContentPane()</code> returns the content-pane (which is a <code>java.awt.Containter</code>) of the <code>JFrame</code>. You can then set its layout (the default layout is <code>BorderLayout</code>), and add components into it. For example,</p>

<pre class="color-example">Container cp = getContentPane(); <span class="color-comment">// Get the content-pane of this JFrame</span>
cp.setLayout(new FlowLayout());  <span class="color-comment">// content-pane sets to FlowLayout</span>
cp.add(new JLabel(&quot;Counter&quot;));   <span class="color-comment">// content-pane adds a JLabel component</span>
......
cp.add(tfCount);    <span class="color-comment">// content-pane adds a JTextField component</span>
......
cp.add(btnCount);   <span class="color-comment">// content-pane adds a JButton component</span></pre>

<p>You can also use the <code>JFrame</code>'s <code>setContentPane()</code> method to directly set the content-pane to a <code>JPanel</code> (or a <code>JComponent</code>). For example,</p>

<pre class="color-example">
JPanel displayPanel = new JPanel();
this.setContentPane(displayPanel);  
      <span class="color-comment">// &quot;this&quot; JFrame sets its content-pane to a JPanel directly</span>
.....
 
<span class="color-comment">// The above is different from:</span>
this.getContentPane().add(displayPanel);  
    <span class="color-comment">  // Add a JPanel into the content-pane. Appearance depends on the JFrame's layout.</span></pre>


<h5 class="font-code">JFrame's setDefaultCloseOperation()</h5>
<p>Instead of writing a <code>WindowEvent</code> listener with a <code>windowClosing()</code> handler to process the &quot;close-window&quot; button, <code>JFrame</code> provides a method called <code>setDefaultCloseOperation()</code> to sets the default operation when   the user initiates a &quot;close&quot; on this frame. Typically, we choose the option <code>JFrame.EXIT_ON_CLOSE</code>, which terminates the application via a <code>System.exit()</code>.</p>
<pre class="color-example">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
</pre>

<h5>Running the GUI Construction Codes on the Event-Dispatching Thread</h5>

<p>In the previous examples, we invoke the constructor directly in the entry <code>main()</code> method to setup the GUI components. For example,</p>

<pre class="color-example">
<span class="color-comment">// The entry main method</span>
public static void main(String[] args) {
   <span class="color-comment">// Invoke the constructor (by allocating an instance) to setup the GUI</span>
   new SwingCounter();
}</pre>

<p>The constructor will be executed in the so-called &quot;Main-Program&quot; thread. This may cause multi-threading issues (such as unresponsive user-interface and deadlock).</p>
<p>It is recommended to execute the GUI setup codes in the so-called &quot;Event-Dispatching&quot; thread, instead of &quot;Main-Program&quot; thread, for thread-safe operations. Event-dispatching thread, which processes events, should be used when the codes updates the GUI.</p>
<p> To run the constructor on the event-dispatching thread, invoke <code>static</code> method <code>SwingUtilities.invokeLater()</code> to asynchronously queue the constructor on the event-dispatching thread. The codes will be run after all pending  events have been processed. For example,</p>


<pre class="color-example">public static void main(String[] args) {
   <span class="color-comment">// Run the GUI codes in the Event-dispatching thread for thread-safety</span>
   SwingUtilities.invokeLater(new Runnable() {
      @Override
      public void run() {
         new SwingCounter();  <span class="color-comment">// Let the constructor do the job</span>
      }
   });
}</pre>

<p>Note: <code>javax.swing.SwingUtilities.invokeLater()</code> is a cover for <code>java.awt.EventQueue.invokeLater()</code> (which is used in the NetBeans' Visual GUI Builder).</p>

<p>At times, for example in game programming, the <em>constructor</em> or the <code>main()</code> may contains non-GUI codes. Hence, it is a common practice to create a dedicated method called <code>initComponents()</code> (used in NetBeans visual GUI builder) or <code>createAndShowGUI()</code> (used in Swing tutorial) to handle all the GUI codes (and another method called <code>initGame()</code> to handle initialization of the game's objects). This GUI init method shall be run in the event-dispatching thread.</p>

<h5>Warning Message &quot;The serialization class does not declare a static final serialVersionUID field of type long&quot;</h5>

<p>This warning message is triggered because <code>java.awt.Frame</code> (via its superclass <code>java.awt.Component</code>) implements the <code>java.io.Serializable</code> interface. This interface enables the object to be written out to an output stream <em>serially</em> (via method <code>writeObject()</code>); and read back into the program (via method <code>readObject()</code>). The serialization runtime uses a number (called <code>serialVersionUID</code>) to ensure that the object read into the program is compatible with the class definition, and not belonging to another version.</p>

<p>You have these options:</p>
<ol>
<li>Simply ignore this warning message.  If a <code>serializable</code> class does not explicitly declare a <code>serialVersionUID</code>, then the serialization runtime will calculate a default <code>serialVersionUID</code> value for that class based on various aspects of the class.</li>

<li>Add a <code>serialVersionUID</code> (Recommended), e.g.
  <pre class="color-example">
private static final long <strong>serialVersionUID</strong> = 1L;  <span class="color-comment">// version 1</span></pre></li>

<li>Suppress this particular warning via annotation <code>@SuppressWarmomgs</code> (in package <code>java.lang</code>) (JDK 1.5):
<pre class="color-example">
<strong>@SuppressWarnings(&quot;serial&quot;)</strong>
public class MyFrame extends JFrame { ...... }</pre>
</li>


</ol>



<h4>Swing Example 2: <span class="font-code">SwingAccumulator</span></h4>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54</pre></td>
<td>
<pre>
import java.awt.*;       <span class="color-comment">// Using layouts</span>
import java.awt.event.*; <span class="color-comment">// Using AWT event classes and listener interfaces</span>
import javax.swing.*;    <span class="color-comment">// Using Swing components and containers</span>
 
<span class="color-comment">// A Swing GUI application inherits the top-level container javax.swing.JFrame</span>
public class SwingAccumulator extends JFrame {
   private JTextField tfInput, tfOutput;
   private int sum = 0;    <span class="color-comment">// accumulated sum, init to 0</span>
 
   <span class="color-comment">// Constructor to setup the GUI components and event handlers</span>
   public SwingAccumulator() {
      <span class="color-comment">// Retrieve the content-pane of the top-level container JFrame</span>
      <span class="color-comment">// All operations done on the content-pane</span>
      Container cp = getContentPane();
      cp.setLayout(new GridLayout(2, 2, 5, 5));  <span class="color-comment">// The content-pane sets its layout</span>
 
      add(new JLabel(&quot;Enter an Integer: &quot;));
      tfInput = new JTextField(10);
      add(tfInput);
      add(new JLabel(&quot;The Accumulated Sum is: &quot;));
      tfOutput = new JTextField(10);
      tfOutput.setEditable(false);  <span class="color-comment">// read-only</span>
      add(tfOutput);
 
      <span class="color-comment">// Allocate an anonymous instance of an anonymous inner class that</span>
      <span class="color-comment">//  implements ActionListener as ActionEvent listener</span>
      tfInput.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent evt) {
            <span class="color-comment">// Get the String entered into the input TextField, convert to int</span>
            int numberIn = Integer.parseInt(tfInput.getText());
            sum += numberIn;      <span class="color-comment">// accumulate numbers entered into sum</span>
            tfInput.setText(&quot;&quot;);  <span class="color-comment">// clear input TextField</span>
            tfOutput.setText(sum + &quot;&quot;); <span class="color-comment">// display sum on the output TextField</span>
         }
      });
 
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="color-comment">// Exit program if close-window button clicked</span>
      setTitle(&quot;Swing Accumulator&quot;); <span class="color-comment">// &quot;super&quot; Frame sets title</span>
      setSize(350, 120);  <span class="color-comment">// &quot;super&quot; Frame sets initial size</span>
      setVisible(true);   <span class="color-comment">// &quot;super&quot; Frame shows</span>
   }
 
   <span class="color-comment">// The entry main() method</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI construction in the Event-Dispatching thread for thread-safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new SwingAccumulator(); <span class="color-comment">// Let the constructor do the job</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<h3>Using Visual GUI Builder - NetBeans/Eclipse</h3>

<p>If you have a complicated layout for your GUI application, you should use a GUI Builder, such as NetBeans or Eclipse to layout your GUI components in a drag-and-drop manner, similar to the popular visual languages such as Visual Basic and Dephi.</p>

<h4>NetBeans</h4>

<p>For using NetBeans GUI Builder, read my &quot;<a href="../howto/NetBeans_HowTo.html#netbeans-swing">Writing Java GUI (AWT/Swing) Application in NetBeans</a>&quot;; or Swing Tutorial's &quot;<a href="http://docs.oracle.com/javase/tutorial/uiswing/learn/index.html">Learning Swing with the NetBeans IDE</a>&quot;.</p>

<h4>Eclipse</h4>

<p>For using Eclipse GUI Builder, read &quot;<a href="../howto/EclipseJava_HowTo.html#GUIBuider">Writing Swing Applications using Eclipse GUI Builder</a>&quot;.</p>

<a class="references" href="../howto/References.html#java">LINK TO JAVA REFERENCES &amp; RESOURCES</a>

<p class="references">MORE REFERENCES &amp; RESOURCES</p>
<ol>
<li>&quot;Creating a GUI With JFC/Swing&quot; (aka &quot;The Swing Tutorial&quot;) @ <a href="http://docs.oracle.com/javase/tutorial/uiswing/">http://docs.oracle.com/javase/tutorial/uiswing/</a>.</li>
<li>JFC Demo (under JDK demo &quot;<code>jfc</code>&quot; directory).</li>
<li>Java2D Tutorial @ <a href="http://docs.oracle.com/javase/tutorial/2d/index.html">http://docs.oracle.com/javase/tutorial/2d/index.html</a>.</li>
<li>JOGL (Java Binding on OpenGL) @ <a href="http://java.net/projects/jogl/">http://java.net/projects/jogl/</a>.</li>
<li>Java3D (@ <a href="http://java3d.java.net/">http://java3d.java.net/</a>).</li>
</ol>


</div> <!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JDK 1.8.0<br />
Last modified: April, 2016</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
</body>
</html>
