<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>A Tutorial on JOGL 2.0 with Nehe JOGL Port</title>
<link href="../css/programming_notes_v1.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../scripts/programming_notes_v1.js"></script>
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" /></head>

<body>

<div id="wrap-outer">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p>&nbsp;</p></div>

<div id="wrap-inner">

<div id="wrap-toc">
<h5>TABLE OF CONTENTS <a id="show-toc" href="#show-toc">(HIDE)</a></h5>
<div id="toc"></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header">
<h1>Yet Another Tutorial on JOGL 2.1</h1>
<h2>Including Nehe JOGL Port</h2>

</div>

<div id="content-main">

<h3>Introduction to JOGL</h3>
<p><acronym title="Open Graphics Library">OpenGL</acronym> is a cross-platform, language-independent, industrial standard <acronym title="Application Programmer Interface">API</acronym> for producing 3D (and 2D) computer graphics. Graphics cards that claim OpenGL-compliance make use of the hardware acceleration when possible to speed up the graphics rendering process. OpenGL competes with Direct3D on Microsoft Windows platform. The OpenGL mother site is at <a href="http://www.opengl.org/">http://www.opengl.org</a>. </p>

<p>The JOGL (Java Bindings for the OpenGL) allows Java applications to access the OpenGL API for graphics programming. In other words, it is simply a <em>wrapper library</em> for Java application to use OpenGL API. JOGL is open-source and currently maintained by &quot;JogAmp&quot; (Java on Graphics, Audio, Media and Processing) @ <a href="http://jogamp.org/">http://jogamp.org</a>. JogAMP provides JOGL (3D graphics), JOAL (Java Bindings for <acronym title="Open Audio Library">OpenAL</acronym> for 3D Audio) and JOCL (Java Bindings for <acronym title="Open Computing Language">OpenCL</acronym> - a Common  Language for Graphics Processors). </p>
<p>Alternatives to JOGL include open-source LWJGL (Light-Weight Java Game Library) @ <a href="http://lwjgl.org">http://lwjgl.org</a>.</p>
<p> This tutorial assumes that you have sufficient knowledge on OpenGL, but new to JOGL. To learn OpenGL, find a good OpenGL book (e.g., the  Red book &quot;OpenGL Programming Guide&quot; or Blue Book &quot;OpenGL Superbible&quot;). Nehe production  maintains an excellent OpenGL Tutorials (@ <a href="http://nehe.gamedev.net/">http://nehe.gamedev.net</a>). You may also read my OpenGL tutorials.</p>
<p>JOGL 2 supports OpenGL 1.3 to 4.0 and OpenGL ES 1.x and 2.x. JOGL integrates with the AWT, Swing and SWT. It also provides its own native windowing toolkit called NEWT.</p>
<p>This guide is meant for JOGL 2.0 (tested on rc8), which is not compatible with the older (and obsoleted) JOGL 1.x. For JOGL 1.x, read &quot;<a href="JOGL1.1.html">A Tutorial on JOGL 1.1</a>&quot;.</p>

<h3 id="Install">Setting Up  JOGL 2.0_rc8</h3>
<p><span class="line-heading">Reference:</span> &quot;Downloading and installing JOGL&quot; @ <a href="http://jogamp.org/wiki/index.php/Downloading_and_installing_JOGL">http://jogamp.org/wiki/index.php/Downloading_and_installing_JOGL</a>.</p>

<h5>Step 0: Install JDK</h5>
<p>Install JDK, an IDE such as Eclipse/NetBeans or a programming text editor. <span class="line-heading"></span>You need a working Java programming environment to write JOGL programs.</p>

<h5>Step 1: Download JOGL</h5>
<p>Download the latest &quot;stable&quot; release from JogAMP @ <a href="http://jogamp.org/deployment/jogamp-current/archive/">http://jogamp.org/deployment/jogamp-current/archive</a> (or from JogAMP @ <a href="http://jogamp.org">http://jogamp.org</a> &rArr; Builds/Downloads &rArr; Current &rArr; zip). Select &quot;<code>jogamp-all-platforms.7z</code>&quot;, which contains the JOGL and gluegen JAR-files, Java Native Library (JNI) for all the platforms (e.g., Win32, Win64, Linux, Mac OS), and source-files.</p>
<p> You are also recommended to download the &quot;<code>javadocs</code>&quot; (<code>jogl-javadoc.7z</code> and <code>gluegen-javadoc.7z</code>), &quot;<code>demos</code>&quot; (<code>jogl-demos.7z</code>) and sources.</p>

<h5>Step 2: Setup JOGL</h5>

<ol>
<li>Unzip &quot;<code>jogamp-all-platforms.7z</code>&quot; (you can unzip &quot;<code>.7z</code>&quot; file using WinRAR, WinZip, or <a href="http://www.7-zip.org/">http://www.7-zip.org/</a>).
<ul>
<li>The <code>jogl</code>'s and <code>gluegen</code>'s jar-files are kept in the &quot;<code>jar</code>&quot; sub-directory.</li>
<li>The Java Native JNI Libraries  (&quot;<code>.dll</code>&quot; for Windows, &quot;<code>.so</code>&quot; for Linux, or &quot;<code>.jnilib</code>&quot; for MacOS) are kept in the &quot;<code></code><code>lib</code>&quot; sub-directories.</li></ul>

</li>

<li>Create a JOGL binary directory, says &quot;<code>jogl-2.1</code>&quot; - I shall denote the binary directory as <code>$JOGL_HOME</code>. Create sub-directories &quot;<code>jar</code>&quot;, &quot;<code>lib</code>&quot;, &quot;<code>src</code>&quot; (optional), &quot;<code>javadoc</code>&quot; (optional) under the <code>$JOGL_HOME</code>.<br />
Copy the necessary jar-file, native libraries of your operating platform, and source-files into the appropriate sub-directories. Read &quot;<a href="http://jogamp.org/wiki/index.php/Downloading_and_installing_JOGL">http://jogamp.org/wiki/index.php/Downloading_and_installing_JOGL</a>&quot;.<br />
For example, for Win64, copy &quot;<code>jar\gluegen-rt.jar</code>&quot;, &quot;<code>jar\jogl.all.jar</code>&quot;, &quot;<code>jar\gluegen-rt-natives-windows-amd64.jar</code>&quot; and &quot;<code>jar\jogl-all-natives-windows-amd64.jar</code>&quot; into &quot;<code>jar</code>&quot;; &quot;<code>lib\windows-amd64\gluegen-rt.dll</code>&quot;, &quot;<code>lib\windows-amd64\jogl_desktop.dll</code>&quot;, &quot;<code>lib\windows-amd64\nativewindow_awt.dll</code>&quot;, &quot;<code>lib\windows-amd64\nativewindow_win32.dll</code>&quot;, &quot;<code>lib\windows-amd64\newt.dll</code>&quot; into &quot;<code>lib</code>&quot;; and  &quot;<code>gluegen-java-src.zip</code>&quot;, &quot;<code>jogl-java-src.zip</code>&quot; into &quot;<code>src</code>&quot;. Unzip the <code>javadocs</code> downloaded into &quot;<code>javadoc</code>&quot;.</li>
</ol>

<p>Read the &quot;<code>jogl.README.txt</code>&quot;.</p>

<p>This step is optional, but it is good to organize the JOGL JAR-files and Java Native Libraries for your operating platform in a single directory.</p>

<h5>Step 3a: Customize for Eclipse 4.3</h5>
<ol>
<li><span class="line-heading">Create a User Library:</span> We shall first create a Eclipse's <em>User Library</em> called &quot;<code>jogl-2.1</code>&quot;, which specifies the jar-files, native libraries, javadoc, and source files for the JOGL API. All the JOGL projects can then include this <em>user library</em> in its build path.

  <ol>
<li>From &quot;Window&quot; menu  ⇒ Preferences  ⇒ Java  ⇒ Build Path ⇒ User Libraries  ⇒ New  ⇒ In &quot;User library name&quot;, enter &quot;<code>jogl-2.1</code>&quot;.</li>

<li>In &quot;User Library&quot; dialog ⇒ Select &quot;<code>jogl-2.1</code>&quot;  ⇒ &quot;Add External JAR...&quot; ⇒ Navigate to &quot;<code>$JOGL_HOME\jar</code>&quot;, and select &quot;<code>gluegen-rt.jar</code>&quot; and  &quot;<code>jogl.all.jar</code>&quot;.</li>

<li>Expand the &quot;<code>jogl.all.jar</code>&quot; node, select &quot;Native library location: (none)&quot; &rArr; &quot;Edit...&quot; &rArr; External Folder... &rArr; select &quot;<code>$JOGL_HOME\lib</code>&quot; to provide the path for the native library code (such as &quot;<code>jogl_desktop.dll</code>&quot; for Windows).<br />
Repeat for &quot;<code>gluegen-rt.jar</code>&quot; (for &quot;<code>gluegen-rt.dll</code>&quot;).</li>

<li>(Optional But Recommended) Expand the &quot;<code>jogl.all.jar</code>&quot; node again  ⇒ Select &quot;Javadoc location<code>&quot; </code>&rArr; &quot;Edit...&quot;

<ul>
<li>Specify the javadoc's path (either file: or http:) in &quot;Javadoc URL&quot; if you use an unzip version of the javadoc.</li>

<li>Specify the javadoc's archive file (either zip or jar) in &quot;Javadoc in archive&quot; if you use a zip file.</li></ul>

Choose &quot;Validate&quot;, which search for an &quot;<code>index.html</code>&quot; file.<br />
This is needed for Eclipse to display javadoc information about classes and methods.</li>

<li>(Optional But Recommended) You may provide the source files by editing &quot;Source attachment&quot; &rArr; &quot;Edit...&quot; &rArr; &quot;External File...&quot; &rArr; Select the source file in zip form. Source is needed only if you are interested to debug into the JOGL source codes.</li>
</ol>
</li>

<li><span class="line-heading">Include the User Library:</span> For EACH JAVA PROJECT created that uses JOGL, right-click on the project &rArr; &quot;Build Path&quot; &rArr; &quot;Add Libraries&quot; &rArr; Select &quot;User Library&quot; ⇒ Check &quot;<code>jogl-2.1</code>&quot;.</li>
</ol>

<p>Read &quot;<a href="../howto/ErrorMessages.html#JNIError">Java Native Library (JNI) Error</a>&quot; if you encounter error &quot;<code>SEVERE: java.lang.UnsatisfiedLinkError: no <em>xxx</em> in java.library.path</code>&quot;.</p>

<h5>Step 3b: Customize for NetBeans 7.0 (To Check!)</h5>
<p>There was a so-called &quot;NetBeans  OpenGL Pack&quot;, but it seems to be out-dated and does not support JOGL 2 (?!).</p>
<p>We shall create our own <em>JOGL Library</em> as follows:</p>

<ol>
<li><span class="line-heading">Create a JOGL Library:</span>
  <ol>
<li>From &quot;Tool&quot; &rArr; &quot;Library&quot; &rArr; Click &quot;New Libraries...&quot; &rArr; Enter &quot;<code>jogl2.0</code>&quot;.</li>
<li>Click &quot;Add JAR/Folder...&quot; &rArr; Select &quot;<code>jogl.all.jar</code>&quot; and &quot;<code>gluegen-rt.jar</code>&quot;.</li>
<li>Under the &quot;JavaDoc&quot; tab &rArr; Select the JOGL's javadoc. You could use the zip version for better performance.</li>
<li>Under the &quot;Source&quot; tab &rArr; Select the JOGL's source. You could use the zip version for better performance.</li>
</ol></li>

<li><span class="line-heading">Include the JOGL Library:</span>
<ol>
<li>For EACH of the JOGL project, include the JOGL library. Right-click on the project &rArr; &quot;Properties&quot; &rArr; &quot;Library&quot; &rArr; Under &quot;Compile&quot; tab &rArr; &quot;Add Libraries...&quot; &rArr; Choose the library &quot;<code>jogl2.0</code>&quot; created earlier.</li>

<li>You also need to include the native library path for each of the project. Right-click the project ⇒ &quot;Set Configuration&quot; ⇒ &quot;Customize...&quot; ⇒ &quot;Run&quot; ⇒ In &quot;VM options&quot;, enter &quot;<code>-Djava.library.path=<em>xxx</em></code>&quot;, where <em>xxx</em> is <em>directory path</em> (e.g., <code>d:\bin\jogl2.0\lib</code>), that contains the Java Native JNI Libraries (&quot;<code>*.dll</code>&quot; for Windows, &quot;<code>*.so</code>&quot; for Linux or &quot;<code>*.jnilib</code>&quot; for MacOS).</li></ol></li>
</ol>

<p>Read &quot;<a href="../howto/ErrorMessages.html#JNIError">Java Native Library (JNI) Error</a>&quot; if you encounter error &quot;<code>SEVERE: java.lang.UnsatisfiedLinkError: no <em>xxx</em> in java.library.path</code>&quot;.</p>

<h5>Step 3c: Customize for JDK/Editor</h5>
<p>You need to modify two environment variables - <code>CLASSPATH</code> and <code>PATH</code>. Read <a href="../howto/Environment_Variables.html">&quot;Environment Variables For Java Applications&quot;</a> on how to set these environment variables.</p>
<p>Modify the <code>CLASSPATH</code> environment variable to include the full-path filenames of &quot;<code>jogl.all.jar</code>&quot; and &quot;<code>gluegen-rt.jar</code>&quot;, for example,</p>
<pre class="color-command">
shell&gt; <strong>set classpath=.;$JOGL_HOME\lib\jogl.all.jar;$JOGL_HOME\lib\gluegen-rt.jar</strong></pre>

<p>where <code>$JOGL_HOME</code> denotes the JOGL installed directory. Take note that you should include the current working directory <code>'.'</code>.</p>
<p>Modified the <code>PATH</code> environment variable to include the full path to the JOGL's &quot;<code>lib</code>&quot; directory for accessing the native libraries (e.g., &quot;<code>jogl_xxx.dll</code>&quot;, &quot;<code>gluegen-rt.dll</code>&quot;), for example,</p>
<pre class="color-command">
shell&gt; <strong>set path=$JOGL_HOME\lib;......</strong></pre>

<p>Alternatively, you could include the <em>directory path</em> of the native libraries in Java system's property &quot;<code>java.library.path</code>&quot;, via the VM command-line option <code>-Djava.library.path=<em>pathname</em></code>, for example,</p>
<pre class="color-command">
shell&gt; java <strong>-Djava.library.path=d:\bin\jogl2.0\lib</strong> myjoglapp</pre>

<p>Read &quot;<a href="../howto/ErrorMessages.html#JNIError">Java Native Library (JNI) Error</a>&quot; if you encounter error &quot;<code>SEVERE: java.lang.UnsatisfiedLinkError: no <em>xxx</em> in java.library.path</code>&quot;.</p>

<h3 id="GetStarted">Getting Started with JOGL 2.1</h3>

<h4>OpenGL Drawable: <span class="font-code">GLCanvas</span> and <span class="font-code">GLJPanel</span></h4>

<img class="image-center" src="images/GLCanvasGLJPanel.png" />
<p>An OpenGL drawable is a surface (or canvas) for graphics rendering. JOGL provides two drawables in package <code>javax.media.opengl.awt</code>: <code>GLCanvas</code> and <code>GLJPanel</code>.</p>

<ol>
<li><code>GLCanvas</code>: A heavyweight AWT component which is a subclass of <code>java.awt.Canvas</code>.<br />
You can create a <code>GLCanvas</code> via the default constructor <code>GLCanvas()</code>, which construct a new <code>GLCanvas</code> component with a default set of OpenGL capabilities, using the default OpenGL capabilities selection mechanism, on the default screen device. For example,

<pre class="color-example">
GLCanvas canvas = new GLCanvas();
JFrame frame = new JFrame();         <span class="color-comment">// or AWT's Frame</span>
frame.getContentPane().add(canvas);  <span class="color-comment">// add Component</span>
canvas.addGLEventListener(.....);</pre>
</li>
  
<li><code>GLJPanel</code>: A lightweight Swing component which is a subclass of <code>javax.swing.JPanel</code>.<br />
Again, You can create a <code>GLJPanel</code> via the default constructor <code>GLJPanel()</code>, which construct a new <code>GLJPanel</code> component with a default set of OpenGL capabilities, using the default OpenGL capabilities selection mechanism. For example,

<pre class="color-example">
GLJPanel canvas = new GLJPanel();
JFrame frame = new JFrame();
frame.getContentPane().add(canvas);  <span class="color-comment">// or frame.setContentPane(canvas);</span>
canvas.addGLEventListener(.....);</pre></li>
</ol>

<p>The <code>GLCanvas</code> is a heavyweight AWT component which supports hardware acceleration. It is designed as the <em>primary widget</em> for JOGL applications. On the other hand, <code>GLJPanel</code> is a swing-compatible lightweight component, which supports hardware acceleration but is not as fast as <code>GLCanvas</code>. <code>GLJPanel</code> is intended to provide 100% swing integration when the heavyweight <code>GLCanvas</code> cannot be used. Both the <code>GLCanvas</code> and <code>GLJPanel</code> implement a common interface <code>GLAutoDrawable</code> (which in turn implements the interface <code>GLDrawable</code>). These interfaces define the common behaviors expected on <code>GLCanvas</code> and <code>GLJPanel</code>, so that applications can switch between them with minimal code changes.</p>

<p>Beside supporting AWT, Swing and SWT, JOGL 2 also provide its own Native Window Toolkit called NEWT via drawable <code>GLWindow</code> (in package <code>com.jogamp.newt.opengl</code>). I shall discuss NEWT later.</p>


<h4><span class="font-code">GLEventListener</span> and <span class="font-code">GLAutoDrawable</span></h4>
<p>The interface <code>GLEventListener</code> (in package <code>javax.media.opengl</code>) declares the following 4 OpenGL event handlers:</p>

<ol>
  <li><code>init(GLAutoDrawable <em>drawable</em>)</code>: called by the <code> <em>drawable</em></code> immediately after the OpenGL context is initialized. It can be used to perform one-time initialization tasks such as setting up of lights and display lists. <code>init()</code> runs only once.</li>

<li><code>dispose(GLAutoDrawable <em>drawable</em>)</code>: called by the<code> <em>drawable</em></code> before the OpenGL context is destroyed. It can be used to release all OpenGL resources, such as memory buffers.</li>

<li><code>display(GLAutoDrawable <em>drawable</em>)</code>: called by the<code> <em>drawable</em></code> to  render OpenGL graphics. It is the most important method.</li>

<li><code>reshape(GLAutoDrawable <em>drawable</em>, int <em>x</em>, int <em>y</em>, int <em>width</em>, int <em>height</em>)</code>: called by the <code><em>drawable</em></code> when it is first set to visible, and during the first repaint after the it has been resized. It is used to set the view port and projection mode, and view volume.</li>
</ol>

<p>All these methods are call-back methods. When an OpenGL event is posted on the event-queue, the graphics sub-system calls back the corresponding handler. An OpenGL renderer shall implement the <code>GLEventListener</code> interface.</p>
<p>Recall that <code>GLCanvas</code> and <code>GLJPanel</code> are <code>GLAutoDrawable</code>. The interface <code>GLAutoDrawable</code> defines these <code>abstract</code> methods to add or remove a <code>GLEventListener</code>:</p>
<pre class="color-syntax">
public void addGLEventListener(GLEventListener <em>listener</em>)
public void removeGLEventListener(GLEventListener <em>listener</em>)</pre>

<p>For example,</p>
<pre class="color-example">
GLCanvas canvas = new GLCanvas();
canvas.addGLEventListener(<em>renderer</em>);  <span class="color-comment">// add a GLEventListener called renderer</span>
   <span class="color-comment">// renderer shall provides these handlers
   //   init(GLAutoDrawable drawable)
   //   destroy(GLAutoDrawable drawable)
   //   display(GLAutoDrawable drawable)
   //   reshape(GLAutoDrawable drawable, int x, int y, int width, int height)</span></pre>
   
<p>Whenever an OpenGL event is fired (e.g., init, display), <code>GLCanvas</code> or <code>GLJPanel</code> invokes the corresponding handler  of all its registered <code>GLEventListener</code>(s) (such as <code>init()</code> and <code>display()</code>) with itself as the argument for <code>GLAutoDrawable</code>, as illustrated.</p>

<img class="image-center" src="images/GLEventHandlers.png"  />

<h4>Animator</h4>
<img class="image-center" src="images/AnimatorClassDiagram.png" />
<p>To perform animation, we need an <em>animator</em> to drive the drawable's <code>display()</code> method in a loop to refresh the display regularly. JOGL provides two animator classes: <code>Animator</code> and <code>FPSAnimator</code> (in package <code>com.jogamp.opengl.util</code>). The commonly-used <code>FPSAnimator</code> can drive the <code>display()</code> of the given drawable at the specified number of frame per seconds (fps). For example,</p>
<pre class="color-example">
<span class="color-comment">// Construct a drawable</span>
GLCanvas canvas = new GLCanvas();   <span class="color-comment">// or GLJPanle</span>
<span class="color-comment">// Construct an FPS animator, which drives drawable's display() at the specified frames per second</span>
FPSAnimator animator = new FPSAnimator(canvas, 60);
 
animator.start();       <span class="color-comment">// start the animator</span>
animator.pause();       <span class="color-comment">// pause the animator if started</span>
animator.resume();      <span class="color-comment">// resume the animator if paused</span>
animator.stop();        <span class="color-comment">// stop the animator</span>
animator.isStarted();   <span class="color-comment">// started?</span>
animator.isAnimating(); <span class="color-comment">// started and not pause?</span>
animator.isPause();     <span class="color-comment">// started and pause?</span>
</pre>

<p>The commonly-used constructors are:</p>
<pre class="color-syntax">
FPSAnimator(GLAutoDrawable drawable, int fps)
      <span class="color-comment">// Creates an FPSAnimator with a given target frames-per-second value 
      //  and an initial drawable to animate.</span>
FPSAnimator(GLAutoDrawable drawable, int fps, boolean scheduleAtFixedRate)
      <span class="color-comment">// Creates an FPSAnimator with a given target frames-per-second value, 
      //  an initial drawable to animate, 
      //  and a flag indicating whether to use fixed-rate scheduling.</span>
Animator(GLAutoDrawable drawable)
      <span class="color-comment">// Creates a new Animator for a particular drawable.</span></pre>

<h4>OpenGL Graphics Context</h4>

<p>In order to perform rendering, an so-called OpenGL rendering context is required. You can retrieve the graphics context from a drawable as follow:</p>

<pre class="color-example">
javax.media.opengl.GL  gl = drawable.getGL();
javax.media.opengl.GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// up to OpenGL 3.0</span>
javax.media.opengl.GL3 gl = drawable.getGL().getGL3();  <span class="color-comment">// up to OpenGL 3.1</span>
javax.media.opengl.GL4 gl = drawable.getGL().getGL4();  <span class="color-comment">// up to OpenGL 4</span>
......
// Others: GL2GL3, GL2bc, GL4bc, GLES1, GLES2, GL2ES1, GL2ES2</pre>

<p>[TODO] To Revise.</p>

<h4>JOGL 2.0/2.1 Program Templates</h4>

<h5><span class="font-code">GLCanvas</span></h5>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.awt.GLCanvas;
import javax.media.opengl.glu.GLU;
import com.jogamp.opengl.util.FPSAnimator;
import static javax.media.opengl.GL.*;  <span class="color-comment">// GL constants</span>
import static javax.media.opengl.GL2.*; <span class="color-comment">// GL2 constants</span>
 
<span class="color-comment">/**
 * JOGL 2.0 Program Template (GLCanvas)
 * This is a &quot;Component&quot; which can be added into a top-level &quot;Container&quot;.
 * It also handles the OpenGL events to render graphics.
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JOGL2Setup_GLCanvas extends GLCanvas implements GLEventListener {
   <span class="color-comment">// Define constants for the top-level container</span>
   private static String TITLE = &quot;JOGL 2.0 Setup (GLCanvas)&quot;;  <span class="color-comment">// window's title</span>
   private static final int CANVAS_WIDTH = 640;  <span class="color-comment">// width of the drawable</span>
   private static final int CANVAS_HEIGHT = 480; <span class="color-comment">// height of the drawable</span>
   private static final int FPS = 60; <span class="color-comment">// animator's target frames per second</span>
 
   <span class="color-comment">/** The entry main() method to setup the top-level container and animator */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes in the event-dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            <span class="color-comment">// Create the OpenGL rendering canvas</span>
            GLCanvas canvas = new JOGL2Setup_GLCanvas();
            canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
 
            <span class="color-comment">// Create a animator that drives canvas' display() at the specified FPS.</span>
            final FPSAnimator animator = new FPSAnimator(canvas, FPS, true);
 
            <span class="color-comment">// Create the top-level container</span>
            final JFrame frame = new JFrame(); <span class="color-comment">// Swing's JFrame or AWT's Frame</span>
            frame.getContentPane().add(canvas);
            frame.addWindowListener(new WindowAdapter() {
               @Override
               public void windowClosing(WindowEvent e) {
                  <span class="color-comment">// Use a dedicate thread to run the stop() to ensure that the</span>
                  <span class="color-comment">// animator stops before program exits.</span>
                  new Thread() {
                     @Override
                     public void run() {
                        if (animator.isStarted()) animator.stop();
                        System.exit(0);
                     }
                  }.start();
               }
            });
            frame.setTitle(TITLE);
            frame.pack();
            frame.setVisible(true);
            animator.start(); <span class="color-comment">// start the animation loop</span>
         }
      });
   }
 
   <span class="color-comment">// Setup OpenGL Graphics Renderer</span>
 
   private GLU glu;  <span class="color-comment">// for the GL Utility</span>
 
   <span class="color-comment">/** Constructor to setup the GUI for this Component */</span>
   public JOGL2Setup_GLCanvas() {
      this.addGLEventListener(this);
   }
 
   <span class="color-comment">// ------ Implement methods declared in GLEventListener ------</span>
 
   <span class="color-comment">/**
    * Called back immediately after the OpenGL context is initialized. Can be used
    * to perform one-time initialization. Run only once.
    */</span>
   @Override
   public void init(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();      <span class="color-comment">// get the OpenGL graphics context</span>
      glu = new GLU();                         <span class="color-comment">// get GL Utilities</span>
      gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <span class="color-comment">// set background (clear) color</span>
      gl.glClearDepth(1.0f);      <span class="color-comment">// set clear depth value to farthest</span>
      gl.glEnable(GL_DEPTH_TEST); <span class="color-comment">// enables depth testing</span>
      gl.glDepthFunc(GL_LEQUAL);  <span class="color-comment">// the type of depth test to do</span>
      gl.glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); <span class="color-comment">// best perspective correction</span>
      gl.glShadeModel(GL_SMOOTH); <span class="color-comment">// blends colors nicely, and smoothes out lighting</span>
 
      <span class="color-comment">// ----- Your OpenGL initialization code here -----</span>
   }
 
   <span class="color-comment">/**
    * Call-back handler for window re-size event. Also called when the drawable is
    * first set to visible.
    */</span>
   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
 
      if (height == 0) height = 1;   <span class="color-comment">// prevent divide by zero</span>
      float aspect = (float)width / height;
 
      <span class="color-comment">// Set the view port (display area) to cover the entire window</span>
      gl.glViewport(0, 0, width, height);
 
      <span class="color-comment">// Setup perspective projection, with aspect ratio matches viewport</span>
      gl.glMatrixMode(GL_PROJECTION);  <span class="color-comment">// choose projection matrix</span>
      gl.glLoadIdentity();             <span class="color-comment">// reset projection matrix</span>
      glu.gluPerspective(45.0, aspect, 0.1, 100.0); <span class="color-comment">// fovy, aspect, zNear, zFar</span>
 
      <span class="color-comment">// Enable the model-view transform</span>
      gl.glMatrixMode(GL_MODELVIEW);
      gl.glLoadIdentity(); <span class="color-comment">// reset</span>
   }
 
   <span class="color-comment">/**
    * Called back by the animator to perform rendering.
    */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
      gl.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="color-comment">// clear color and depth buffers</span>
      gl.glLoadIdentity();  <span class="color-comment">// reset the model-view matrix</span>
 
      <span class="color-comment">// ----- Your OpenGL rendering code here (Render a white triangle for testing) -----</span>
      gl.glTranslatef(0.0f, 0.0f, -6.0f); <span class="color-comment">// translate into the screen</span>
      gl.glBegin(GL_TRIANGLES); <span class="color-comment">// draw using triangles</span>
         gl.glVertex3f(0.0f, 1.0f, 0.0f);
         gl.glVertex3f(-1.0f, -1.0f, 0.0f);
         gl.glVertex3f(1.0f, -1.0f, 0.0f);
      gl.glEnd();
   }
 
   <span class="color-comment">/**
    * Called back before the OpenGL context is destroyed. Release resource such as buffers.
    */</span>
   @Override
   public void dispose(GLAutoDrawable drawable) { }
}</pre>
</td>
</tr>
</tbody>
</table>

<img class="image-float-right" src="images/GLSetup.png" />

<p>Try running the above program, which will show a white triangle on a black screen.</p>

<p>In this template:</p>
<ul>
<li>I follow the design of &quot;<a href="../java/J4c_AppletWebstart.html#javaria">Component-based Architecture for Rich Internet Applications (RIA)</a>&quot;, where the GUI &quot;<code>Component</code>&quot; (<code>GLCanvas</code> or <code>GLJPanel</code>) and &quot;<code>Container</code>&quot; (<code>JFrame</code>, <code>Frame</code>, <code>JApplet</code>, <code>Applet</code>) are clearly separated. The &quot;<code>Component</code>&quot; can be easily plugged into any of the &quot;<code>Container</code>&quot;.</li>
<li>The main class extends <code>GLCanvas</code> (<code>Component</code>) to provide the OpenGL graphics rendering canvas. It also implements <code>GLEventListener</code> and provides handlers for <code>init()</code>, <code>display()</code>, <code>dispose()</code> and <code>reshape()</code>.</li>

<li>The <code>main()</code> method:
  <ul>
<li>Allocates a <code>GLCanvas</code> component.</li>
<li>Allocates an <code>Animator</code> to drive the <code>display()</code> method of the <code>GLCanvas</code> in a loop to refresh the display.</li>
<li>Allocates a top-level container (Swing's <code>JFrame</code> or AWT's <code>Frame</code>), and adds the <code>GLCanvas</code> component into the container..</li>
  </ul> 
 </li>
</ul>

<h5>Using AWT's <span class="font-code">Frame</span> as Top-Level Container</h5>

<p>The above template uses Swing's <code>JFrame</code> as the top-level container. To use AWT's <code>Frame</code> as the top-level window, modify the <code>main()</code> method as follows:</p>
<pre class="color-example">
<span class="color-comment">/** The entry main() method to setup the top-level container and animator */</span>
public static void main(String[] args) {
   GLCanvas canvas = new GLCanvas();
   ......
   <span class="color-new">final Frame frame = new Frame();</span> <span class="color-comment">// instead of Swing's JFrame</span>
   <span class="color-new">frame.add(canvas);</span>               <span class="color-comment">// instead of Swing's frame.setContentPane()</span>
   .......
}</pre>

<p>[TODO] Check whether <code>GLCanvas</code> is better to use with AWT's <code>Frame</code> or Swing's <code>JFrame</code> if there is no other light-weight components.</p>

<h5>Separating the <span class="font-code">Component</span> and <span class="font-code">Container</span> Classes</h5>

<p>Alternatively, you could separate the renderer <code>Component</code> and the top-level <code>Container</code> into two classes:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre>
</td>
<td>
<pre>
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.awt.GLCanvas;
import javax.media.opengl.glu.GLU;
import static javax.media.opengl.GL.*;  <span class="color-comment">// GL constants</span>
import static javax.media.opengl.GL2.*; <span class="color-comment">// GL2 constants</span>
 
<span class="color-comment">/**
 * JOGL 2.0 Program Template (GLCanvas)
 * This is a &quot;Component&quot; which can be added into a top-level &quot;Container&quot;.
 * It also handles the OpenGL events to render graphics.
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JOGL2Setup_Renderer extends GLCanvas implements GLEventListener {
   private GLU glu;  <span class="color-comment">// for the GL Utility</span>
 
   <span class="color-comment">/** Constructor to setup the GUI for this Component */</span>
   public JOGL2Setup_Renderer() {
      this.addGLEventListener(this);
   }
 
   <span class="color-comment">// ------ Implement methods declared in GLEventListener ------</span>
 
   <span class="color-comment">/**
    * Called back immediately after the OpenGL context is initialized. Can be used
    * to perform one-time initialization. Run only once.
    */</span>
   @Override
   public void init(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();      <span class="color-comment">// get the OpenGL graphics context</span>
      glu = new GLU();                         <span class="color-comment">// get GL Utilities</span>
      gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <span class="color-comment">// set background (clear) color</span>
      gl.glClearDepth(1.0f);      <span class="color-comment">// set clear depth value to farthest</span>
      gl.glEnable(GL_DEPTH_TEST); <span class="color-comment">// enables depth testing</span>
      gl.glDepthFunc(GL_LEQUAL);  <span class="color-comment">// the type of depth test to do</span>
      gl.glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); <span class="color-comment">// best perspective correction</span>
      gl.glShadeModel(GL_SMOOTH); <span class="color-comment">// blends colors nicely, and smoothes out lighting</span>
 
      <span class="color-comment">// ----- Your OpenGL initialization code here -----</span>
   }
 
   <span class="color-comment">/**
    * Call-back handler for window re-size event. Also called when the drawable is
    * first set to visible.
    */</span>
   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
 
      if (height == 0) height = 1;   <span class="color-comment">// prevent divide by zero</span>
      float aspect = (float)width / height;
 
      <span class="color-comment">// Set the view port (display area) to cover the entire window</span>
      gl.glViewport(0, 0, width, height);
 
      <span class="color-comment">// Setup perspective projection, with aspect ratio matches viewport</span>
      gl.glMatrixMode(GL_PROJECTION);  <span class="color-comment">// choose projection matrix</span>
      gl.glLoadIdentity();             <span class="color-comment">// reset projection matrix</span>
      glu.gluPerspective(45.0, aspect, 0.1, 100.0); <span class="color-comment">// fovy, aspect, zNear, zFar</span>
 
      <span class="color-comment">// Enable the model-view transform</span>
      gl.glMatrixMode(GL_MODELVIEW);
      gl.glLoadIdentity(); <span class="color-comment">// reset</span>
   }
 
   <span class="color-comment">/**
    * Called back by the animator to perform rendering.
    */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
      gl.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="color-comment">// clear color and depth buffers</span>
      gl.glLoadIdentity();  <span class="color-comment">// reset the model-view matrix</span>
 
      <span class="color-comment">// ----- Your OpenGL rendering code here (render a white triangle for testing) -----</span>
      gl.glTranslatef(0.0f, 0.0f, -6.0f); <span class="color-comment">// translate into the screen</span>
      gl.glBegin(GL_TRIANGLES); <span class="color-comment">// draw using triangles</span>
         gl.glVertex3f(0.0f, 1.0f, 0.0f);
         gl.glVertex3f(-1.0f, -1.0f, 0.0f);
         gl.glVertex3f(1.0f, -1.0f, 0.0f);
      gl.glEnd();
   }
 
   <span class="color-comment">/**
    * Called back before the OpenGL context is destroyed. Release resource such as buffers.
    */</span>
   @Override
   public void dispose(GLAutoDrawable drawable) { }
}</pre>
</td>
</tr>
</tbody>
</table>

<br />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.media.opengl.awt.GLCanvas;
import com.jogamp.opengl.util.FPSAnimator;
 
<span class="color-comment">/**
 * JOGL 2.0 Program Template (GLCanvas)
 * This is the top-level &quot;Container&quot;, which allocates and add GLCanvas (&quot;Component&quot;)
 * and animator.
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JOGL2Setup_RendererMain extends JFrame {
   <span class="color-comment">// Define constants for the top-level container</span>
   private static String TITLE = &quot;JOGL 2.0 Setup (GLCanvas)&quot;;  <span class="color-comment">// window's title</span>
   private static final int CANVAS_WIDTH = 640;  <span class="color-comment">// width of the drawable</span>
   private static final int CANVAS_HEIGHT = 480; <span class="color-comment">// height of the drawable</span>
   private static final int FPS = 60; <span class="color-comment">// animator's target frames per second</span>
 
   <span class="color-comment">/** Constructor to setup the top-level container and animator */</span>
   public JOGL2Setup_RendererMain() {
      <span class="color-comment">// Create the OpenGL rendering canvas</span>
      GLCanvas canvas = new JOGL2Setup_Renderer();
      canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
 
      <span class="color-comment">// Create a animator that drives canvas' display() at the specified FPS.</span>
      final FPSAnimator animator = new FPSAnimator(canvas, FPS, true);
 
      <span class="color-comment">// Create the top-level container frame</span>
      this.getContentPane().add(canvas);
      this.addWindowListener(new WindowAdapter() {
         @Override
         public void windowClosing(WindowEvent e) {
            <span class="color-comment">// Use a dedicate thread to run the stop() to ensure that the</span>
            <span class="color-comment">// animator stops before program exits.</span>
            new Thread() {
               @Override
               public void run() {
                  if (animator.isStarted()) animator.stop();
                  System.exit(0);
               }
            }.start();
         }
      });
      this.setTitle(TITLE);
      this.pack();
      this.setVisible(true);
      animator.start(); <span class="color-comment">// start the animation loop</span>
   }
 
   <span class="color-comment">/** The entry main() method */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes in the event-dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            new JOGL2Setup_RendererMain();  <span class="color-comment">// run the constructor</span>
         }
      });
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>In this approach, all the graphics rendering codes are kept in the <em>renderer</em> (<code>Component</code>) class. The <em>main</em> (<code>Container</code>) class can be left untouched.</p>

<h5> <span class="font-code">GLJPanel</span></h5>

<p>To use the light-weight <code>GLJPanel</code> instead of the heavy-weight <code>GLCanvas</code>, simply change all reference of <code>GLCanvas</code> to <code>GLJPanel</code>.</p>
<pre class="color-example">
public class JOGL2Setup_GLJPanel <span class="color-new">extends GLJPanel</span> implements GLEventListener {
   ......
   <span class="color-comment">/** The entry main() method to setup the top-level container and animator */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes in the event-dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            <span class="color-comment">// Create the OpenGL rendering canvas</span>
            <span class="color-new">GLJPanel</span> canvas = new JOGL2Setup_GLJPanel();
            ......
         }
      }
   }
   ......
}
GLJPanel canvas = new GLJPanel();  <span class="color-comment">// instead of GLCanvas</span></pre>

<h5>Running as an Applet</h5>

<p>As we followed the <em>Component-based Architecture</em> in our class design, we can plug the <code>GLCanvas</code> <code>Component</code> into other top-level <code>Container</code>, such as <code>JApplet</code> or <code>Applet</code> easily.</p>

<p>To run the program as an applet, you can simply add an applet launching class (as follow) to launch the main renderer class. Recall that an applet extends <code>javax.swing.JApplet</code> (or <code>java.awt.Frame</code>) and is managed via methods <code>init()</code> (instead of <code>main()</code> of an application), <code>start()</code>, <code>stop()</code> and <code>destroy()</code>.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></td>
<td>
<pre>
import java.lang.reflect.InvocationTargetException;
import javax.media.opengl.awt.GLCanvas;
import javax.swing.JApplet;
import javax.swing.SwingUtilities;
import com.jogamp.opengl.util.FPSAnimator;
 
<span class="color-comment">/**
 * JOGL 2.0 Applet Template (with GLCanvas and Swing JApplet)
 * This is the top-level &quot;Container&quot;, which allocates and add GLCanvas (&quot;Component&quot;)
 * and animator.
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JOGL2Setup_Applet <span class="color-new">extends JApplet</span> {
   <span class="color-comment">// Define constants for top-level container</span>
   private static final int FPS = 60; <span class="color-comment">// animator's target frames per second</span>
 
   FPSAnimator animator;
 
   @Override
   public void init() {
      <span class="color-comment">// Run the GUI codes in the event-dispatching thread for thread safety</span>
      try {
         SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
               <span class="color-comment">// Create the OpenGL rendering canvas</span>
               GLCanvas canvas = new JOGL2Setup_GLCanvas();
               getContentPane().add(canvas);
 
               <span class="color-comment">// Create a animator that drives canvas' display() at the specified FPS.</span>
               animator = new FPSAnimator(canvas, FPS, true);
               animator.start(); <span class="color-comment">// start the animation loop</span>
            }
         });
      } catch (InvocationTargetException e) {
         e.printStackTrace();
      } catch (InterruptedException e) {
         e.printStackTrace();
      }
   }
 
   @Override
   public void destroy() {
      if (animator.isStarted()) animator.stop();
   }
 
   @Override
   public void start() {
      animator.start();
   }
 
   @Override
   public void stop() {
      if (animator.isStarted()) animator.stop();
   }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>The <code>main()</code> method in the renderer class is ignored by applet.</p>

<h5>Running in Full-Screen Mode</h5>
<p>Games are often run in full-screen mode without decoration (title, status, scroll bars). The JOGL 2.0 program template for full screen mode operation is as follows:</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAnimatorControl;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.awt.GLCanvas;
import javax.media.opengl.glu.GLU;
import com.jogamp.opengl.util.FPSAnimator;
import static javax.media.opengl.GL.*;  <span class="color-comment">// GL constants</span>
import static javax.media.opengl.GL2.*; <span class="color-comment">// GL2 constants</span>
 
<span class="color-comment">/**
 * JOGL 2.0 Program Template (GLCanvas) in Full Screen Mode with ESC to quit
 * This is a &quot;Component&quot; which can be added into a top-level &quot;Container&quot;.
 * It also handles the OpenGL events to render graphics.
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JOGL2Setup_GLCanvasFullScreen extends GLCanvas
         implements GLEventListener, KeyListener {
   <span class="color-comment">// Define constants for top-level container</span>
   private static final int FPS = 60; <span class="color-comment">// animator's target frames per second</span>
 
   <span class="color-comment">/** The entry main() method to setup the top-level container and animator */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes in the event-dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            <span class="color-comment">// Create the OpenGL rendering canvas</span>
            GLCanvas canvas = new JOGL2Setup_GLCanvasFullScreen();
 
            <span class="color-comment">// Create a animator that drives canvas' display() at the specified FPS.</span>
            FPSAnimator animator = new FPSAnimator(canvas, FPS, true);
 
            <span class="color-comment">// Create the top-level container frame</span>
            JFrame frame = new JFrame(); <span class="color-comment">// Swing's JFrame or AWT's Frame</span>
            frame.getContentPane().add(canvas);
            frame.setUndecorated(true);     <span class="color-comment">// no decoration such as title bar</span>
            frame.setExtendedState(Frame.MAXIMIZED_BOTH);  <span class="color-comment">// full screen mode</span>
            frame.setVisible(true);
            animator.start(); <span class="color-comment">// start the animation loop</span>
         }
      });
   }
 
   <span class="color-comment">// Setup OpenGL Graphics Renderer</span>
 
   private GLU glu;  <span class="color-comment">// for the GL Utility</span>
 
   <span class="color-comment">/** Constructor to setup the GUI for this Component */</span>
   public JOGL2Setup_GLCanvasFullScreen() {
      this.addGLEventListener(this);   <span class="color-comment">// for handling GLEvents</span>
      this.addKeyListener(this); <span class="color-comment">// for Handling KeyEvents</span>
      this.setFocusable(true);
      this.requestFocus();
   }
 
   <span class="color-comment">// ------ Implement methods declared in GLEventListener ------</span>
 
   <span class="color-comment">/**
    * Called back immediately after the OpenGL context is initialized. Can be used
    * to perform one-time initialization. Run only once.
    */</span>
   @Override
   public void init(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();      <span class="color-comment">// get the OpenGL graphics context</span>
      glu = new GLU();                         <span class="color-comment">// get GL Utilities</span>
      gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <span class="color-comment">// set background (clear) color</span>
      gl.glClearDepth(1.0f);      <span class="color-comment">// set clear depth value to farthest</span>
      gl.glEnable(GL_DEPTH_TEST); <span class="color-comment">// enables depth testing</span>
      gl.glDepthFunc(GL_LEQUAL);  <span class="color-comment">// the type of depth test to do</span>
      gl.glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); <span class="color-comment">// best perspective correction</span>
      gl.glShadeModel(GL_SMOOTH); <span class="color-comment">// blends colors nicely, and smoothes out lighting</span>
 
      <span class="color-comment">// ----- Your OpenGL initialization code here -----</span>
   }
 
   <span class="color-comment">/**
    * Call-back handler for window re-size event. Also called when the drawable is
    * first set to visible.
    */</span>
   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
 
      if (height == 0) height = 1;   <span class="color-comment">// prevent divide by zero</span>
      float aspect = (float)width / height;
 
      <span class="color-comment">// Set the view port (display area) to cover the entire window</span>
      gl.glViewport(0, 0, width, height);
 
      <span class="color-comment">// Setup perspective projection, with aspect ratio matches viewport</span>
      gl.glMatrixMode(GL_PROJECTION);  <span class="color-comment">// choose projection matrix</span>
      gl.glLoadIdentity();             <span class="color-comment">// reset projection matrix</span>
      glu.gluPerspective(45.0, aspect, 0.1, 100.0); <span class="color-comment">// fovy, aspect, zNear, zFar</span>
 
      <span class="color-comment">// Enable the model-view transform</span>
      gl.glMatrixMode(GL_MODELVIEW);
      gl.glLoadIdentity(); <span class="color-comment">// reset</span>
   }
 
   <span class="color-comment">/**
    * Called back by the animator to perform rendering.
    */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
      gl.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="color-comment">// clear color and depth buffers</span>
      gl.glLoadIdentity();  <span class="color-comment">// reset the model-view matrix</span>
 
      <span class="color-comment">// ----- Your OpenGL rendering code here (render a white triangle for testing) -----</span>
      gl.glTranslatef(0.0f, 0.0f, -6.0f); <span class="color-comment">// translate into the screen</span>
      gl.glBegin(GL_TRIANGLES); <span class="color-comment">// draw using triangles</span>
         gl.glVertex3f(0.0f, 1.0f, 0.0f);
         gl.glVertex3f(-1.0f, -1.0f, 0.0f);
         gl.glVertex3f(1.0f, -1.0f, 0.0f);
      gl.glEnd();
   }
 
   <span class="color-comment">/**
    * Called back before the OpenGL context is destroyed. Release resource such as buffers.
    */</span>
   @Override
   public void dispose(GLAutoDrawable drawable) { }
 
   <span class="color-comment">// ------ Implement methods declared in KeyListener ------</span>
 
   @Override
   public void keyTyped(KeyEvent e) {}
 
   @Override
   public void keyPressed(KeyEvent e) {
      int keyCode = e.getKeyCode();
      switch (keyCode) {
         case KeyEvent.VK_ESCAPE: <span class="color-comment">// quit</span>
            <span class="color-comment">// Use a dedicate thread to run the stop() to ensure that the</span>
            <span class="color-comment">// animator stops before program exits.</span>
            new Thread() {
               @Override
               public void run() {
                  GLAnimatorControl animator = getAnimator();
                  if (animator.isStarted()) animator.stop();
                  System.exit(0);
               }
            }.start();
            break;
      }
   }
 
   @Override
   public void keyReleased(KeyEvent e) {}
}</pre>
</td>
</tr>
</tbody>
</table>

<p>To operate in full-screen mode, set the frame to:</p>
<pre class="color-example">
final JFrame frame = new JFrame();
frame.setUndecorated(true);  <span class="color-comment">// no decoration such as title and scroll bars</span>
frame.setExtendedState(Frame.MAXIMIZED_BOTH);  <span class="color-comment">// full screen mode</span>
......</pre>

<p>The &quot;window-close&quot; button is no longer available in the full-screen mode. Hence, we use the ESC key to exit the program. The renderer, hence, also implements the <code>KeyListener</code> interface and provide <code>KeyEvent</code> handlers, such as <code>keyPressed()</code> for processing the ESC key..</p>

<p>Note: Read the &quot;Graphics Programming&quot; section on how to switch between full-screen mode and windowed mode, if desired.</p>

<h4>Example 1: Rotating 2D Shapes</h4>

<img src="images/JOGLEx1Shape2D.png" />

<p>Modify the <code>GLEventListener</code> handlers <code>init()</code>, <code>display()</code> and <code>reshape()</code> of the  template (<code>GLCanvas</code> or <code>GLJPanel</code>) as follows:</p>

<pre class="color-example">
public class JOGL2Ex1Rotate2D extends GLJCanvas implements GLEventListener {
   ......
   ......
   private float angle = 0.0f;  <span class="color-comment">// rotation angle of the triangle</span>

   <span class="color-comment">/** Called back by the drawable to render OpenGL graphics */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
      render(drawable);
      update();
   }
   
   <span class="color-comment">// Render a triangle</span>
   private void render(GLAutoDrawable drawable) {
      <span class="color-comment">// Get the OpenGL graphics context</span>
      GL2 gl = drawable.getGL().getGL2();
      <span class="color-comment">// Clear the color and the depth buffers</span>
      gl.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      <span class="color-comment">// Reset the view (x, y, z axes back to normal)</span>
      gl.glLoadIdentity();   

      <span class="color-comment">// Draw a triangle</span>
      float sin = (float)Math.sin(angle);
      float cos = (float)Math.cos(angle);
      gl.glBegin(GL_TRIANGLES);
         gl.glColor3f(1.0f, 0.0f, 0.0f);   <span class="color-comment">// Red</span>
         gl.glVertex2d(-cos, -cos);
         gl.glColor3f(0.0f, 1.0f, 0.0f);   <span class="color-comment">// Green</span>
         gl.glVertex2d(0.0f, cos);
         gl.glColor3f(0.0f, 0.0f, 1.0f);   <span class="color-comment">// Blue</span>
         gl.glVertex2d(sin, -sin);
      gl.glEnd();
   }
   
   <span class="color-comment">// Update the angle of the triangle after each frame</span>
   private void update() {
      angle += 0.01f;
   }
   
   @Override
   public void init(GLAutoDrawable drawable) { }  <span class="color-comment">// set to empty</span>

   @Override
   public void dispose(GLAutoDrawable drawable) { }  <span class="color-comment">// set to empty</span>

   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) { }  <span class="color-comment">// set to empty</span>

   ......
   ......
}</pre>

<p>TRY:</p>
<ol>
  <li>Using <code>GLJPanel</code> on Swing's <code>JFrame</code>.</li>
  <li>Use <code>GLCanvas</code> on AWT's <code>Frame</code>.</li>
<li>Use <code>GLCanvas</code> on AWT's <code>Applet</code>.</li>
<li>Using <code>GLJPanel</code> on Swing's <code>JApplet</code>.</li>
</ol>
<p>Observe and compare the results.</p>

<h4><span class="font-code">GLEventListener</span> Handlers</h4>

<p><span class="line-heading font-code">init()</span>: called by the drawable immediately after the OpenGL graphics context is initialized. It can be used to perform one-time initialization tasks such as setting up of lights and display lists. The <code>init()</code> runs only once.</p>

<pre class="color-example">
   <span class="color-comment">/** Called after context is initialized, for one-time initialization tasks */</span>
   @Override
   public void init(GLAutoDrawable drawable) {
      <span class="color-comment">// Get the OpenGL graphics context</span>
      GL2 gl = drawable.getGL().getGL2();
      <span class="color-comment">// Get GL Utilities after the GL context created.</span>
      // glu = GLU.createGLU();
      <span class="color-comment">// Enable smooth shading, which blends colors nicely, and smoothes out lighting.</span>
      gl.glShadeModel(GLLightingFunc.GL_SMOOTH);
      <span class="color-comment">// Set background color in RGBA. Alpha: 0 (transparent) 1 (opaque)</span> 
      gl.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
      <span class="color-comment">// Setup the depth buffer and enable the depth testing</span>
      gl.glClearDepth(1.0f);         <span class="color-comment">// clear z-buffer to the farthest</span>
      gl.glEnable(GL.GL_DEPTH_TEST); <span class="color-comment">// enables depth testing</span>
      gl.glDepthFunc(GL.GL_LEQUAL);  <span class="color-comment">// the type of depth test to do</span>
      <span class="color-comment">// Do the best perspective correction</span>
      gl.glHint(GL2ES1.GL_PERSPECTIVE_CORRECTION_HINT, GL.GL_NICEST);
      
      <span class="color-comment">// ----- Your OpenGL initialization code here -----
      // ......</span>
   }</pre>

<br  />
<p><span class="line-heading font-code">reshape()</span>: called by the drawable when the drawable is first set to visible, and during the first repaint after the canvas has been resized.</p>

<pre class="color-example">
   <span class="color-comment">/** Called for the first-time display and after display's size changes. 
       To set up the view port, projection mode and view volume. */</span>
   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
      <span class="color-comment">// Get the OpenGL graphics context</span>
      GL2 gl = drawable.getGL().getGL2();
      
      height = (height == 0) ? 1 : height;  <span class="color-comment">// Prevent divide by zero</span>
      float aspect = (float)width / height; <span class="color-comment">// Compute aspect ratio</span>
      
      <span class="color-comment">// Set view port to cover full screen</span> 
      gl.glViewport(0, 0, width, height);
      
      <span class="color-comment">// Set up the projection matrix - choose perspective view</span>
      gl.glMatrixMode(GLMatrixFunc.GL_PROJECTION);  
      gl.glLoadIdentity();    <span class="color-comment">// reset</span>
      <span class="color-comment">// Angle of view (fovy) is 45 degrees (in the up y-direction). Based on this
      // canvas's aspect ratio. Clipping z-near is 0.1f and z-near is 100.0f.</span>
      glu.gluPerspective(45.0f, aspect, 0.1f, 100.0f); <span class="color-comment">// fovy, aspect, zNear, zFar</span>
      
      <span class="color-comment">// Switch to the model-view transform</span>
      gl.glMatrixMode(GLMatrixFunc.GL_MODELVIEW);
      gl.glLoadIdentity();    <span class="color-comment">// reset</span>
   }</pre>

<br />

<p><span class="line-heading font-code">display()</span>: called by the drawable to perform OpenGL graphics rendering.</p>

<pre class="color-example">
   <span class="color-comment">/** Called to render graphics */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
      <span class="color-comment">// Get the OpenGL graphics context</span>
      GL2 gl = drawable.getGL().getGL2();
      <span class="color-comment">// Clear the color and the depth buffers</span>
      gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
      <span class="color-comment">// Reset the view (x, y, z axes back to normal)</span>
      gl.glLoadIdentity();
      
      <span class="color-comment">// ----- Your OpenGL rendering code here -----
      // ......</span>
   }</pre>

<br  />
<p><span class="line-heading font-code">disposed()</span>: called by the drawbale before the OpenGL context is destroyed. It can be used to release all OpenGL resources, such as memory buffers.</p>
<pre class="color-example">@Override
public void disposed(GLAutoDrawable drawable) { 
   <span class="color-comment">// Hardly used.</span><br />}</pre>

<h4>Example 2: Rotating 3D Shapes</h4>

<p>The following example show a color-pyramid and color-cube (Nehe Lesson #5).</p>
<img src="images/JOGLEx1Shape3D.png" />

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227</pre>
</td>
<td>
<pre>
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.awt.GLCanvas;
import javax.media.opengl.glu.GLU;
import com.jogamp.opengl.util.FPSAnimator;
import static javax.media.opengl.GL.*;  <span class="color-comment">// GL constants</span>
import static javax.media.opengl.GL2.*; <span class="color-comment">// GL2 constants</span>
 
<span class="color-comment">/**
 * JOGL 2.0 Example 2: Rotating 3D Shapes (GLCanvas)
 */</span>
@SuppressWarnings(&quot;serial&quot;)
public class JOGL2Ex2Rotate3D_GLCanvas extends GLCanvas implements GLEventListener {
   <span class="color-comment">// Define constants for the top-level container</span>
   private static String TITLE = &quot;Rotating 3D Shapes (GLCanvas)&quot;;  <span class="color-comment">// window's title</span>
   private static final int CANVAS_WIDTH = 320;  <span class="color-comment">// width of the drawable</span>
   private static final int CANVAS_HEIGHT = 240; <span class="color-comment">// height of the drawable</span>
   private static final int FPS = 60; <span class="color-comment">// animator's target frames per second</span>
 
   <span class="color-comment">/** The entry main() method to setup the top-level container and animator */</span>
   public static void main(String[] args) {
      <span class="color-comment">// Run the GUI codes in the event-dispatching thread for thread safety</span>
      SwingUtilities.invokeLater(new Runnable() {
         @Override
         public void run() {
            <span class="color-comment">// Create the OpenGL rendering canvas</span>
            GLCanvas canvas = new JOGL2Ex2Rotate3D_GLCanvas();
            canvas.setPreferredSize(new Dimension(CANVAS_WIDTH, CANVAS_HEIGHT));
 
            <span class="color-comment">// Create a animator that drives canvas' display() at the specified FPS.</span>
            final FPSAnimator animator = new FPSAnimator(canvas, FPS, true);
 
            <span class="color-comment">// Create the top-level container</span>
            final JFrame frame = new JFrame(); <span class="color-comment">// Swing's JFrame or AWT's Frame</span>
            frame.getContentPane().add(canvas);
            frame.addWindowListener(new WindowAdapter() {
               @Override
               public void windowClosing(WindowEvent e) {
                  <span class="color-comment">// Use a dedicate thread to run the stop() to ensure that the</span>
                  <span class="color-comment">// animator stops before program exits.</span>
                  new Thread() {
                     @Override
                     public void run() {
                        if (animator.isStarted()) animator.stop();
                        System.exit(0);
                     }
                  }.start();
               }
            });
            frame.setTitle(TITLE);
            frame.pack();
            frame.setVisible(true);
            animator.start(); <span class="color-comment">// start the animation loop</span>
         }
      });
   }
 
   <span class="color-comment">// Setup OpenGL Graphics Renderer</span>
 
   private GLU glu;  <span class="color-comment">// for the GL Utility</span>
   private float anglePyramid = 0;    <span class="color-comment">// rotational angle in degree for pyramid</span>
   private float angleCube = 0;       <span class="color-comment">// rotational angle in degree for cube</span>
   private float speedPyramid = 2.0f; <span class="color-comment">// rotational speed for pyramid</span>
   private float speedCube = -1.5f;   <span class="color-comment">// rotational speed for cube</span>
 
   <span class="color-comment">/** Constructor to setup the GUI for this Component */</span>
   public JOGL2Ex2Rotate3D_GLCanvas() {
      this.addGLEventListener(this);
   }
 
   <span class="color-comment">// ------ Implement methods declared in GLEventListener ------</span>
 
   <span class="color-comment">/**
    * Called back immediately after the OpenGL context is initialized. Can be used
    * to perform one-time initialization. Run only once.
    */</span>
   @Override
   public void init(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();      <span class="color-comment">// get the OpenGL graphics context</span>
      glu = new GLU();                         <span class="color-comment">// get GL Utilities</span>
      gl.glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <span class="color-comment">// set background (clear) color</span>
      gl.glClearDepth(1.0f);      <span class="color-comment">// set clear depth value to farthest</span>
      gl.glEnable(GL_DEPTH_TEST); <span class="color-comment">// enables depth testing</span>
      gl.glDepthFunc(GL_LEQUAL);  <span class="color-comment">// the type of depth test to do</span>
      gl.glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); <span class="color-comment">// best perspective correction</span>
      gl.glShadeModel(GL_SMOOTH); <span class="color-comment">// blends colors nicely, and smoothes out lighting</span>
   }
 
   <span class="color-comment">/**
    * Call-back handler for window re-size event. Also called when the drawable is
    * first set to visible.
    */</span>
   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
 
      if (height == 0) height = 1;   <span class="color-comment">// prevent divide by zero</span>
      float aspect = (float)width / height;
 
      <span class="color-comment">// Set the view port (display area) to cover the entire window</span>
      gl.glViewport(0, 0, width, height);
 
      <span class="color-comment">// Setup perspective projection, with aspect ratio matches viewport</span>
      gl.glMatrixMode(GL_PROJECTION);  <span class="color-comment">// choose projection matrix</span>
      gl.glLoadIdentity();             <span class="color-comment">// reset projection matrix</span>
      glu.gluPerspective(45.0, aspect, 0.1, 100.0); <span class="color-comment">// fovy, aspect, zNear, zFar</span>
 
      <span class="color-comment">// Enable the model-view transform</span>
      gl.glMatrixMode(GL_MODELVIEW);
      gl.glLoadIdentity(); <span class="color-comment">// reset</span>
   }
 
   <span class="color-comment">/**
    * Called back by the animator to perform rendering.
    */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
      GL2 gl = drawable.getGL().getGL2();  <span class="color-comment">// get the OpenGL 2 graphics context</span>
      gl.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="color-comment">// clear color and depth buffers</span>
 
      <span class="color-comment">// ----- Render the Pyramid -----</span>
      gl.glLoadIdentity();                 <span class="color-comment">// reset the model-view matrix</span>
      gl.glTranslatef(-1.6f, 0.0f, -6.0f); <span class="color-comment">// translate left and into the screen</span>
      gl.glRotatef(anglePyramid, -0.2f, 1.0f, 0.0f); <span class="color-comment">// rotate about the y-axis</span>
 
      gl.glBegin(GL_TRIANGLES); <span class="color-comment">// of the pyramid</span>
 
      <span class="color-comment">// Font-face triangle</span>
      gl.glColor3f(1.0f, 0.0f, 0.0f); <span class="color-comment">// Red</span>
      gl.glVertex3f(0.0f, 1.0f, 0.0f);
      gl.glColor3f(0.0f, 1.0f, 0.0f); <span class="color-comment">// Green</span>
      gl.glVertex3f(-1.0f, -1.0f, 1.0f);
      gl.glColor3f(0.0f, 0.0f, 1.0f); <span class="color-comment">// Blue</span>
      gl.glVertex3f(1.0f, -1.0f, 1.0f);
 
      <span class="color-comment">// Right-face triangle</span>
      gl.glColor3f(1.0f, 0.0f, 0.0f); <span class="color-comment">// Red</span>
      gl.glVertex3f(0.0f, 1.0f, 0.0f);
      gl.glColor3f(0.0f, 0.0f, 1.0f); <span class="color-comment">// Blue</span>
      gl.glVertex3f(1.0f, -1.0f, 1.0f);
      gl.glColor3f(0.0f, 1.0f, 0.0f); <span class="color-comment">// Green</span>
      gl.glVertex3f(1.0f, -1.0f, -1.0f);
 
      <span class="color-comment">// Back-face triangle</span>
      gl.glColor3f(1.0f, 0.0f, 0.0f); <span class="color-comment">// Red</span>
      gl.glVertex3f(0.0f, 1.0f, 0.0f);
      gl.glColor3f(0.0f, 1.0f, 0.0f); <span class="color-comment">// Green</span>
      gl.glVertex3f(1.0f, -1.0f, -1.0f);
      gl.glColor3f(0.0f, 0.0f, 1.0f); <span class="color-comment">// Blue</span>
      gl.glVertex3f(-1.0f, -1.0f, -1.0f);
 
      <span class="color-comment">// Left-face triangle</span>
      gl.glColor3f(1.0f, 0.0f, 0.0f); <span class="color-comment">// Red</span>
      gl.glVertex3f(0.0f, 1.0f, 0.0f);
      gl.glColor3f(0.0f, 0.0f, 1.0f); <span class="color-comment">// Blue</span>
      gl.glVertex3f(-1.0f, -1.0f, -1.0f);
      gl.glColor3f(0.0f, 1.0f, 0.0f); <span class="color-comment">// Green</span>
      gl.glVertex3f(-1.0f, -1.0f, 1.0f);
 
      gl.glEnd(); <span class="color-comment">// of the pyramid</span>
 
      <span class="color-comment">// ----- Render the Color Cube -----</span>
      gl.glLoadIdentity();                <span class="color-comment">// reset the current model-view matrix</span>
      gl.glTranslatef(1.6f, 0.0f, -7.0f); <span class="color-comment">// translate right and into the screen</span>
      gl.glRotatef(angleCube, 1.0f, 1.0f, 1.0f); <span class="color-comment">// rotate about the x, y and z-axes</span>
 
      gl.glBegin(GL_QUADS); <span class="color-comment">// of the color cube</span>
 
      <span class="color-comment">// Top-face</span>
      gl.glColor3f(0.0f, 1.0f, 0.0f); <span class="color-comment">// green</span>
      gl.glVertex3f(1.0f, 1.0f, -1.0f);
      gl.glVertex3f(-1.0f, 1.0f, -1.0f);
      gl.glVertex3f(-1.0f, 1.0f, 1.0f);
      gl.glVertex3f(1.0f, 1.0f, 1.0f);
 
      <span class="color-comment">// Bottom-face</span>
      gl.glColor3f(1.0f, 0.5f, 0.0f); <span class="color-comment">// orange</span>
      gl.glVertex3f(1.0f, -1.0f, 1.0f);
      gl.glVertex3f(-1.0f, -1.0f, 1.0f);
      gl.glVertex3f(-1.0f, -1.0f, -1.0f);
      gl.glVertex3f(1.0f, -1.0f, -1.0f);
 
      <span class="color-comment">// Front-face</span>
      gl.glColor3f(1.0f, 0.0f, 0.0f); <span class="color-comment">// red</span>
      gl.glVertex3f(1.0f, 1.0f, 1.0f);
      gl.glVertex3f(-1.0f, 1.0f, 1.0f);
      gl.glVertex3f(-1.0f, -1.0f, 1.0f);
      gl.glVertex3f(1.0f, -1.0f, 1.0f);
 
      <span class="color-comment">// Back-face</span>
      gl.glColor3f(1.0f, 1.0f, 0.0f); <span class="color-comment">// yellow</span>
      gl.glVertex3f(1.0f, -1.0f, -1.0f);
      gl.glVertex3f(-1.0f, -1.0f, -1.0f);
      gl.glVertex3f(-1.0f, 1.0f, -1.0f);
      gl.glVertex3f(1.0f, 1.0f, -1.0f);
 
      <span class="color-comment">// Left-face</span>
      gl.glColor3f(0.0f, 0.0f, 1.0f); <span class="color-comment">// blue</span>
      gl.glVertex3f(-1.0f, 1.0f, 1.0f);
      gl.glVertex3f(-1.0f, 1.0f, -1.0f);
      gl.glVertex3f(-1.0f, -1.0f, -1.0f);
      gl.glVertex3f(-1.0f, -1.0f, 1.0f);
 
      <span class="color-comment">// Right-face</span>
      gl.glColor3f(1.0f, 0.0f, 1.0f); <span class="color-comment">// magenta</span>
      gl.glVertex3f(1.0f, 1.0f, -1.0f);
      gl.glVertex3f(1.0f, 1.0f, 1.0f);
      gl.glVertex3f(1.0f, -1.0f, 1.0f);
      gl.glVertex3f(1.0f, -1.0f, -1.0f);
 
      gl.glEnd(); <span class="color-comment">// of the color cube</span>
 
      <span class="color-comment">// Update the rotational angle after each refresh.</span>
      anglePyramid += speedPyramid;
      angleCube += speedCube;
   }
 
   <span class="color-comment">/**
    * Called back before the OpenGL context is destroyed. Release resource such as buffers.
    */</span>
   @Override
   public void dispose(GLAutoDrawable drawable) { }
}</pre>
</td>
</tr>
</tbody>
</table>

<p>TRY:</p>

<ol>
<li>Modify the program to run as an applet.</li>
<li>Modify the program to run in full screen mode.</li>
</ol>

<h4>JOGL's NEWT (Native Windowing Toolkit) - <span class="font-code">GLWindow</span></h4>

<p>Besides relying on AWT/Swing, JOGL provides its own windowing toolkit called NEWT. The base class for NEWT is <code>GLWindow</code>. To allocate a <code>GLWindow:</code></p>
<pre class="color-example">
<span class="color-comment">// Get the default OpenGL profile, reflecting the best for your running platform</span>
GLProfile glp = GLProfile.getDefault();
<span class="color-comment">// Specifies a set of OpenGL capabilities, based on your profile.</span>
GLCapabilities caps = new GLCapabilities(glp);
<span class="color-comment">// Allocate a GLWindow and add GLEventListener</span>
GLWindow window = GLWindow.create(caps);
window.addGLEventListener(......);</pre>


<p>Let's rewrite Example 1 using JOGL's NEWT.</p>

<table class="table-program">
<col class="col-line-number" />
<col class="col-program" />
<tbody>
<tr>
<td>
<pre class="text-right">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100</pre></td>
<td>
<pre>
import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.GLProfile;
import com.jogamp.newt.event.WindowAdapter;
import com.jogamp.newt.event.WindowEvent;
import com.jogamp.newt.opengl.GLWindow;
import com.jogamp.opengl.util.FPSAnimator;
 
public class JOGL2NewtDemo implements GLEventListener {  <span class="color-comment">// Renderer</span>
   private static String TITLE = &quot;JOGL 2 with NEWT&quot;;  <span class="color-comment">// window's title</span>
   private static final int WINDOW_WIDTH = 640;  <span class="color-comment">// width of the drawable</span>
   private static final int WINDOW_HEIGHT = 480; <span class="color-comment">// height of the drawable</span>
   private static final int FPS = 60; <span class="color-comment">// animator's target frames per second</span>
 
   private double theta = 0.0f;  <span class="color-comment">// rotational angle</span>
 
   <span class="color-comment">/** Constructor */</span>
   public JOGL2NewtDemo() {}
 
   <span class="color-comment">/** The entry main() method */</span>
   public static void main(String[] args) {
       <span class="color-comment">// Get the default OpenGL profile, reflecting the best for your running platform</span>
       GLProfile glp = GLProfile.getDefault();
       <span class="color-comment">// Specifies a set of OpenGL capabilities, based on your profile.</span>
       GLCapabilities caps = new GLCapabilities(glp);
       <span class="color-comment">// Create the OpenGL rendering canvas</span>
       GLWindow window = GLWindow.create(caps);
 
       <span class="color-comment">// Create a animator that drives canvas' display() at the specified FPS.</span>
       final FPSAnimator animator = new FPSAnimator(window, FPS, true);
 
       window.addWindowListener(new WindowAdapter() {
          @Override
          public void windowDestroyNotify(WindowEvent arg0) {
             <span class="color-comment">// Use a dedicate thread to run the stop() to ensure that the</span>
             <span class="color-comment">// animator stops before program exits.</span>
             new Thread() {
                @Override
                public void run() {
                   animator.stop(); <span class="color-comment">// stop the animator loop</span>
                   System.exit(0);
                }
             }.start();
          };
       });
 
       window.addGLEventListener(new JOGL2NewtDemo());
       window.setSize(WINDOW_WIDTH, WINDOW_HEIGHT);
       window.setTitle(TITLE);
       window.setVisible(true);
       animator.start();
   }
 
   <span class="color-comment">/** Called back by the drawable to render OpenGL graphics */</span>
   @Override
   public void display(GLAutoDrawable drawable) {
       render(drawable);
       update();
   }
 
   <span class="color-comment">/** Render the shape (triangle) */</span>
   private void render(GLAutoDrawable drawable) {
       GL2 gl = drawable.getGL().getGL2();
 
       gl.glClear(GL.GL_COLOR_BUFFER_BIT);
 
       <span class="color-comment">// Draw a triangle</span>
       float sine = (float)Math.sin(theta);
       float cosine = (float)Math.cos(theta);
       gl.glBegin(GL.GL_TRIANGLES);
       gl.glColor3f(1, 0, 0);
       gl.glVertex2d(-cosine, -cosine);
       gl.glColor3f(0, 1, 0);
       gl.glVertex2d(0, cosine);
       gl.glColor3f(0, 0, 1);
       gl.glVertex2d(sine, -sine);
       gl.glEnd();
   }
 
   <span class="color-comment">/** Update the rotation angle after each frame refresh */</span>
   private void update() {
       theta += 0.01;
   }
 
   <span class="color-comment">/** Called back immediately after the OpenGL context is initialized */</span>
   @Override
   public void init(GLAutoDrawable drawable) { }
 
   <span class="color-comment">/** Called back before the OpenGL context is destroyed. */</span>
   @Override
   public void dispose(GLAutoDrawable drawable) { }
 
   <span class="color-comment">/** Called back by the drawable when it is first set to visible,
   and during the first repaint after the it has been resized. */</span>
   @Override
   public void reshape(GLAutoDrawable drawable, int x, int y, int weight, int height) { }
}</pre>
</td>
</tr>
</tbody>
</table>

<h4>OpenGL Profile and Capabilities</h4>

<p>[TODO] Revised</p>
<p>You can create drawables to support different OpenGL profiles and capabilities:</p>
<ol>
<li>First, construct a <code>GLProfile</code>, which specifies the target profile of your application, e.g., <code>OpenGL2</code>, <code>OpenGL3</code>, <code>OpenGL4</code>, <code>OpenGL|ES1</code>, <code>OpenGL|ES2</code>, etc. The profiles are beyond the scope of this tutorial. Read &quot;<a href="http://michael-bien.com/mbien/entry/jogl_2_opengl_profiles_explained">JOGL 2 - OpenGL Profiles explained</a>&quot; if you are interested. We shall use the following statement to get the default profile, which best reflects your running platform.
  <pre class="color-example">
<span class="color-comment">// Get the default OpenGL profile, reflecting the best for your running platform</span>
GLProfile glp = GLProfile.getDefault();</pre></li>

<li>Next, construct a <code>GLCapabilities</code>, based on your chosen profile, which maintain a set of OpenGL capabilities.
<pre class="color-example">
<span class="color-comment">// Specifies a set of OpenGL capabilities, based on your profile.</span>
GLCapabilities caps = new GLCapabilities(glp);</pre></li>

<li>Now, you can construct your desired drawing canvas: <code>GLCanvas</code> for AWT, <code>GLJPanel</code> for Swing, and <code>GLWindow</code> for Newt.  All these canvas are <code>GLDrawable</code>.
<pre class="color-example"><span class="color-example"><span class="color-comment">// Allocate a GLDrawable, based on your OpenGL capabilities.</span>
<span class="color-comment">// Using GLCanvas for AWT</span> 
GLCanvas canvas = new GLCanvas(caps);</span>
this.add(canvas);            <span class="color-comment">// &quot;this&quot; is a subclass of AWT's Frame</span>
   
<span class="color-comment">// Using GLJPanel for Swing</span>
GLJPanel panel = new GLJPanel(caps);
this.setContentPane(panel);  <span class="color-comment">// &quot;this&quot; is a subclass of Swing's JFrame</span>
   
<span class="color-comment">// Using GLWindow for Newt</span>
GLWindow window = GLWindow.create(caps);
window.setVisible(true);</pre></li>

</ol>

<h3>Nehe's JOGL 2 Port</h3>

<p>I have ported some of the Nehe's lessons into JOGL. Refer to <a href="http://nehe.gamedev.net/">Nehe</a> for the problem descriptions.</p>

<h5>Setting Up</h5>
<p>Download Source Codes: &quot;<a href="codes/JOGL2Nehe01to08.zip">JOGL2Nehe01to08.zip</a>&quot;.</p>
<ul>
<li>Nehe's Lesson #1 &quot;Setting Up&quot;:<br />
- Using <code>GLCanvas</code>: <code>JOGL2Setup_GLCanvas.java</code>.<br />
- Using <code>GLJPanel</code>: <code>JOGL2Setup_GLJPanel.java</code>.<br />
- Run as an applet with <code>GLCanvas</code>: <code>JOGL2Setup</code><code>_Applet.java</code>.
<br />
- Run in full-screen mode: <code>JOGL2Setup_GLCanvasFullScreen</code>.</li></ul>
<p>Expected output: blank black screen.</p>

<h5>OpenGL Basics</h5>
<p>I consider Lessons #2 - #8 as OpenGL basic lessons, that are extremely important! I use <code>GLCanvas</code> on Swing's <code>JFrame</code> for all these exercises, as <code>GLJPanel</code> does not seem to run properly.</p>

<p>Download Source Codes: &quot;<a href="codes/JOGL2Nehe01to08.zip">JOGL2Nehe01To08.zip</a>&quot;.</p>

<ul>
<li>Nehe's Lesson #2 &quot;Basic Shape&quot;: <code>JOGL2Nehe02Basic2D.java</code>.
<br /><img src="images/NeheJOGL02.png" /></li>

<li>Nehe's Lesson #3 &quot;Color&quot;: <code>J2Nehe03Color.java</code>.
<br /><img src="images/NeheJOGL03.png" /></li>

<li>Nehe's Lesson #4 &quot;Rotation&quot;: <code>JOGL2Nehe04Rotation.java</code>.
<br /><img src="images/NeheJOGL04.png" /></li>

<li>Nehe's Lesson #5 &quot;3D Shape&quot;: <code>JOGL2Nehe05Shape3D.java</code>.
<br /><img src="images/NeheJOGL05.png" /></li>

<li>Nehe's Lesson #6 &quot;Texture&quot;: <code>JOGL2Nehe06Texture.java</code>.
<br /><img src="images/NeheJOGL06.png" /></li>

<li>Nehe's Lesson #7 &quot;Texture Filter, Lighting, and key-controlled&quot;: <code>JOGL2Nehe07TextureFilterLightKey.java</code>.
<br /><img src="images/NeheJOGL07.png" /></li>

<li>Nehe's Lesson #8 &quot;Blending&quot;: <code>JOGL2Nehe08Blending.java</code> and <code>JOGL2Nehe08Blending_FullScreen.java</code><br />
<a href="AppletNehe08Blending.html"><img src="images/NeheJOGL08.png" /></a>&nbsp;&nbsp;Click imge to run the applet (not working - JNLP not supported under my server?!)</li>

</ul>

<h5>OpenGL Intermediates</h5>

<p>Download Source Code: &quot;<a href="codes/JOGL2NeheIntermediate.zip">JOGL2NeheIntermediate.zip</a>&quot;.</p>

<ul>
<li>Nehe's Lesson #9 &quot;Moving Bitmaps in 3D space&quot;: <code>J2NeheEx09Stars.java</code>.
<br /><img src="images/NeheJOGL09.png" /></li>

<li>Nehe's Lesson #10: Building and moving in a 3D world <code>J2NeheEx10World3D.java</code>.
<br /><img src="images/NeheJOGL10.png" /></li>

<li>Nehe's Lesson #11 &quot;Waving Effect&quot;: <code>J2NeheEx11Flag.java</code>.
<br /><img src="images/NeheJOGL11.png" /></li>

<li>Nehe's Lesson #12 &quot;Using Display List&quot;: <code>J2NeheEx12DisplayList.java</code>.
<br /><img src="images/NeheJOGL12.png" /></li>

<li>Nehe's Lesson #13 &quot;2D Texts&quot;: <code>J2NeheEx13Text2D.java</code>.
<br /><img src="images/NeheJOGL13.png" /></li>

<li>Nehe's Lesson #14 &quot;3D Texts&quot;: <code>J2NeheEx14Text3D.java</code>.
<br /><img src="images/NeheJOGL14.png" /></li>

<li>Nehe's Lesson #16 &quot;Fog Effect&quot;: <code>J2NeheEx16Fog.java</code>.
<br /><img src="images/NeheJOGL16.png" /></li>

<li>Nehe's Lesson #18 &quot;Quadrics&quot;: <code>J2NeheEx18Quadrics.java</code>.
<br /><img src="images/NeheJOGL18.png" /></li>

<li>Nehe's Lesson #19 &quot;Particle Engine&quot;: (a) <code>J2NeheEx19Particle.java</code>, (b) <code>J2NeheEx19Firework.java</code>.
<br />
<img src="images/NeheJOGL19.png"/>&nbsp;&nbsp;<img src="images/NeheJOGL19a.png" /></li>

<li>Nehe's Lesson #26 &quot;Reflection&quot;: <code>J2NeheEx26Reflection.java</code>.
<br /><img src="images/NeheJOGL26.png" /></li>

</ul>

<h3>More JOGL Ports/Examples</h3>

<p>JOGL comes with many excellent demos. You can get the latest demo source codes from <a href="https://github.com/sgothel/">https://github.com/sgothel/</a> &rArr; &quot;jogl demos&quot; &rArr; &quot;src&quot; &rArr; &quot;demos&quot;. However, many of these demos are not properly explained (?).</p>

<h5>Gears/JGears</h5>
<p>You can get the source codes &quot;<code>Gears.java</code>&quot; from JOGL demos; or get the latest code from <a href="https://github.com/sgothel/">https://github.com/sgothel/</a> &rArr; &quot;jogl demos&quot; &rArr; &quot;src&quot; &rArr; &quot;demos&quot; &rArr; &quot;gears&quot; &rArr; &quot;<code>Gears.java</code>&quot;.</p>
<p>&quot;<code>Gears.java</code>&quot; run the JOGL's NEWT window. [TODO] more.</p>
<p>There is a variation called &quot;<code>JGears.java</code>&quot;, which included 2 images and texts in the display.</p>


<p>[TODO] Photo-Cube</p>
<p>[TODO] Bouncing Balls inside a Cube</p>
<p>[TODO] JOGL Demos</p>
<p>[TODO] Redbook Examples</p>

<h3>Deploying JOGL Applications, Applets and Web Start Apps</h3>

<p>Read &quot;<a href="../java/J4c_AppletWebstart.html#javaria">Java's Rich Internet Applications (RIA) - Applets &amp; Web Start Apps</a>&quot;.</p>

<h4>Deploying JOGL 2.0 WebStart App</h4>

<h5>Jarring Up JOGL App</h5>
<p>Jar-up your JOGL application's classes and relevant resources.</p>

<h5>Preparing JNLP file</h5>

<pre class="color-example">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;jnlp&gt;
   &lt;information&gt;
      &lt;title&gt;My JOGL App&lt;/title&gt;
      &lt;vendor&gt;My Company&lt;/vendor&gt;
      &lt;offline-allowed /&gt;
   &lt;/information&gt;
   &lt;resources&gt;
      &lt;j2se version=&quot;1.4+&quot; href=&quot;http://java.sun.com/products/autodl/j2se&quot; /&gt;
      &lt;jar href=&quot;<span class="color-new">my_app.jar</span>&quot; main=&quot;true&quot; /&gt;
      &lt;extension name=&quot;jogl-all-awt&quot; href=&quot;http://jogamp.org/deployment/<span class="color-new">v2.0-rc8</span>/jogl-all-awt.jnlp&quot; /&gt;
   &lt;/resources&gt;
   &lt;application-desc main-class=&quot;<span class="color-new">mydemo.myAppMain</span>&quot; /&gt;
&lt;/jnlp&gt;</pre>

<p>The above <code>&lt;extension&gt;</code> is meant for JOGL application. The necessary JOGL jar-files are provide by the jogamp server. Choose the appropriate JOGL version that you used to compile your application, e.g., &quot;<code>v2.0-rc8</code>&quot;.</p>

<h4>Deploying JOGL 2.0 Applet</h4>

<p><strong>Reference</strong>:</p>
<ol>
<li>Java Network Launch Protocol (JNLP) Support @ <a href="http://www.oracle.com/technetwork/java/javase/jnlp-136707.html">http://www.oracle.com/technetwork/java/javase/jnlp-136707.html</a></li>
<li>JNLPAppletLauncher @ <a href="http://jogamp.org/applet-launcher/www/">http://jogamp.org/applet-launcher/www/</a>.</li>
<li>Test page for JOGL Applets @ <a href="http://jogamp.org/deployment/jogamp-current/jogl-test-applets.html">http://jogamp.org/deployment/jogamp-current/jogl-test-applets.html</a>.</li>
<li>JOGL: Applets @ <a href="http://jausoft.com/blog/2009/07/03/jogl-applets-part-1/">http://jausoft.com/blog/2009/07/03/jogl-applets-part-1</a>.</li>
</ol>

<h5>JNLP Applet (JDK 6u10)</h5>

<p>Starting from JDK 6u10 Standard &quot;<acronym title="Java Network Launch Protocol">JNLP</acronym> Applets&quot; are supported, in which the Java Plug-In (for web browser) provides support for launching applets directly from JNLP files. To launch an applet from a JNLP file, use the &quot;<code>jnlp_href</code>&quot; parameter in the <code>&lt;applet&gt;</code> tag. </p>
<p>For example, the following HTML file contains an applet which references JNLP file &quot;<code>my_applet.jnlp</code>&quot;.</p>

<pre class="color-example">
&lt;applet width=&quot;300&quot; height=&quot;300&quot; &gt;
&lt;param name=&quot;jnlp_href&quot; value=&quot;my_applet.jnlp&quot;&gt;
&lt;/applet&gt;</pre>

<p>The JNLP file &quot;<code>my_applet.jnlp</code>&quot; is as follows:</p>

<pre class="color-example">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;jnlp href=&quot;my_applet.jnlp&quot;&gt;
   &lt;information&gt;
      &lt;title&gt;My Applet&lt;/title&gt;
      &lt;vendor&gt;My Company&lt;/vendor&gt;
      &lt;offline-allowed /&gt;
   &lt;/information&gt;
   &lt;resources&gt;
      &lt;j2se version=&quot;1.6+&quot; /&gt;
      &lt;jar href=&quot;my_applet.jar&quot; main=&quot;true&quot; /&gt;
      &lt;extension name=&quot;jogl-all-awt&quot; href=&quot;http://jogamp.org/deployment/v2.0-rc8/jogl-all-awt.jnlp&quot; /&gt;
   &lt;/resources&gt;
   &lt;applet-desc
      name=&quot;My Applet&quot;
      main-class=&quot;mydemo.MyApplet&quot;
      width=&quot;300&quot;
      height=&quot;300&quot;&gt;
   &lt;/applet-desc&gt;
&lt;/jnlp&gt;</pre>

<p>The above extension is meant for JOGL app, where you should choose the appropriate JOGL version that you used to compile your application, e.g., &quot;<code>v2.0-rc8</code>&quot;.</p>

<h5>Applet Launcher (JDK 6u10)</h5>
<p>JDK 1.6u10 has greatly improved the efficiency of Java applet, and it is now feasible and practical to deploy a huge Java program as an applet, via a so-called &quot;Applet Launcher&quot;.</p>
<p>JNLP applet is support since JDK 6u14. However, you may need to fall back to the Applet-Launcher to support the older releases.</p>

<h5>Depolying JOGL Applet as &quot;Standard JNLP Applet&quot; / &quot;JNLPAppletLauncher&quot;</h5>
<p>We shall deploy JOGL applet as &quot;JNLP Applet&quot; if the web browser JRE Plug-in supports it (above JDK 6u14); otherwise, we fall back to JNLPAppletLauncher, as follow:</p>
<p>Prepare a JNLP file as follow:</p>

<pre class="color-example">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;jnlp&gt;
  &lt;information&gt;
    &lt;title&gt;JOGL Test&lt;/title&gt;
    &lt;vendor&gt;SomeOne&lt;/vendor&gt;
  &lt;/information&gt;
  &lt;resources&gt;
      &lt;j2se version=&quot;1.6+&quot;/&gt;
      &lt;property name=&quot;sun.java2d.noddraw&quot; value=&quot;true&quot;/&gt;
      &lt;jar href=&quot;<span class="color-new">YourJoglApp.jar</span>&quot; main=&quot;true&quot;/&gt;
      &lt;extension name=&quot;jogl-all-awt&quot; href=&quot;http://jogamp.org/deployment/<span class="color-new">v2.0-rc8</span>/jogl-all-awt.jnlp&quot; /&gt;
  &lt;/resources&gt;
 
  &lt;applet-desc
      name=&quot;Test Applet&quot;
      main-class=&quot;<span class="color-new">YourAppletClass</span>&quot;
      width=&quot;640&quot;
      height=&quot;480&quot;&gt;
  &lt;/applet-desc&gt;
&lt;/jnlp&gt;</pre>

<p>In the <code>&lt;extension&gt;</code>'s <code>href</code>, set to the appropriate JOGL version that you used to compile your program, e.g., &quot;<code>v2.0-rc8</code>&quot; in my case.</p>

<p>Use the following <code>&lt;applet&gt;</code> tag with a reference to the JNLP file in parameter &quot;<code>jnlp_href</code>&quot;:</p>

<pre class="color-example">
&lt;applet code=&quot;org.jdesktop.applet.util.JNLPAppletLauncher&quot;
      width=600
      height=400
      archive=
      &quot;http://jogamp.org/deployment/v2.0-rc8/jar/applet-launcher.jar,
       http://jogamp.org/deployment/v2.0-rc8/jar/nativewindow.all.jar,
       http://jogamp.org/deployment/v2.0-rc8/jar/gluegen-rt.jar,
       http://jogamp.org/deployment/v2.0-rc8/jar/jogl.all.jar,
       <span class="color-new">YourJOGLApp.jar</span>&quot;&gt;
   &lt;param name=&quot;codebase_lookup&quot; value=&quot;false&quot;&gt;
   &lt;param name=&quot;subapplet.classname&quot; value=&quot;<span class="color-new">YourAppletClass</span>&quot;&gt;
   &lt;param name=&quot;subapplet.displayname&quot; value=&quot;JOGL Applet Test&quot;&gt;
   &lt;param name=&quot;noddraw.check&quot; value=&quot;true&quot;&gt;
   &lt;param name=&quot;progressbar&quot; value=&quot;true&quot;&gt;
   &lt;param name=&quot;jnlpNumExtensions&quot; value=&quot;1&quot;&gt;
   &lt;param name=&quot;jnlpExtension1&quot; value=&quot;http://jogamp.org/deployment/<span class="color-new">v2.0-rc8</span>/jogl-core.jnlp&quot;&gt;
   &lt;param name=&quot;java_arguments&quot; value=&quot;-Dsun.java2d.noddraw=true&quot;&gt;
   &lt;param name=&quot;jnlp_href&quot; value=&quot;<span class="color-new">YourJnlpFile.jnlp</span>&quot;&gt;
&lt;/applet&gt;</pre>

<p>where:</p>
<ul>
  <li>Attribute &quot;<code>code</code>&quot; is pointing at &quot;<code>JNLPAppletLauncher</code>&quot;, which is downloaded from <code>http://jogamp.org/deployment/v2.0-rc8/jar/applet-launcher.jar</code>, instead of your local server.</li>
  <li>Attribute &quot;<code>archive</code>&quot; includes all the jar files for running JOGL program. Again, they are downloaded from the server. &quot;<code>archive</code>&quot; also include your JOGL JAR file.</li>
  <li>Attributes &quot;<code>width</code>&quot; and &quot;<code>height</code>&quot; specify the width and height of your applet's display area inside the browser's window.</li>
  <li>The name of your main applet is specified in the parameter &quot;<code>subapplet.classname</code>&quot;.</li>
  <li>The parameter &quot;<code>codebase_lookup</code>&quot; is set to <code>false</code>, as this applet does not need to fetch other files from your local server's code base path.</li>
  <li>The parameter &quot;<code>noddraw.check</code>&quot; is set to true, to check if DirectDraw is enabled and, if so, will prompt the user   to disable it for all applets. DirectDraw is incompatible with OpenGL. Disabling it is unlikely to slow   down other non-3D applets significantly.</li>
</ul>


<p class="references">REFERENCES &amp; RESOURCES</p>
<ol>
<li>JOGL mother site @ <a href="http://jogamp.org/jogl/www/">http://jogamp.org/jogl/www/</a>; JOGL tutorial @ <a href="http://jogamp.org/wiki/index.php/Jogl_Tutorial">http://jogamp.org/wiki/index.php/Jogl_Tutorial</a>; JOGL Wiki @ <a href="http://jogamp.org/wiki/index.php/Main_Page">http://jogamp.org/wiki/index.php/Main_Page</a>.</li>

<li>JOGL Developer and master repository (including source and demos) @ <a href="https://github.com/sgothel/">https://github.com/sgothel/</a>.</li>

<li>OpenGL mother site @ <a href="http://www.opengl.org/">www.opengl.org</a>.</li>
<li>Nehe OpenGL tutorials @ <a href="http://nehe.gamedev.net/">http://nehe.gamedev.net</a>.</li>
<li>OpenGL Programming Guide (Red book); OpenGL Superbible (Blue book)</li>
</ol>


</div> 
<!-- End the content-main division -->

<div id="content-footer">
<p>Latest version tested: JOGL 2.0_rc8, JDK 1.7.2, Eclispe 3.7.2<br />
Last modified: May, 2012</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p>&nbsp;</p></div>

</div>  <!-- End the wrap-outer division -->
</body>
</html>
